<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>Chapter&nbsp;4.&nbsp;Configuration</title><link rel="stylesheet" href="css/docbook-style.css" type="text/css"><meta name="generator" content="DocBook XSL Stylesheets V1.72.0"><link rel="start" href="user-guide.html" title="SymmetricDS 2 User Guide"><link rel="up" href="user-guide.html" title="SymmetricDS 2 User Guide"><link rel="prev" href="planning.html" title="Chapter&nbsp;3.&nbsp;Planning an Implementation"><link rel="next" href="advanced-topics.html" title="Chapter&nbsp;5.&nbsp;Advanced Topics"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div xmlns:fo="http://www.w3.org/1999/XSL/Format" id="banner"><a style="border:none;" href="http://www.symmetricds.org/" title="SymmetricDS User Guide"><img style="border:none;" alt="SymmetricDS" src="images/banner-logo.gif"></a></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="configuration"></a>Chapter&nbsp;4.&nbsp;Configuration</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="section"><a href="configuration.html#configuration-node-properties">4.1. Node Properties</a></span></dt><dt><span class="section"><a href="configuration.html#configuration-node">4.2. Node</a></span></dt><dt><span class="section"><a href="configuration.html#configuration-node-group">4.3. Node Group</a></span></dt><dt><span class="section"><a href="configuration.html#configuration-node-group-link">4.4. Node Group Link</a></span></dt><dt><span class="section"><a href="configuration.html#configuration-channel">4.5. Channel</a></span></dt><dt><span class="section"><a href="configuration.html#configuration-triggers-and-routers">4.6. Triggers and Routers</a></span></dt><dd><dl><dt><span class="section"><a href="configuration.html#configuration-trigger">4.6.1. Trigger</a></span></dt><dt><span class="section"><a href="configuration.html#configuration-router">4.6.2. Router</a></span></dt><dd><dl><dt><span class="section"><a href="configuration.html#configuration-default-router">4.6.2.1. Default Router</a></span></dt><dt><span class="section"><a href="configuration.html#configuration-column-match-router">4.6.2.2. Column Match Router</a></span></dt><dt><span class="section"><a href="configuration.html#configuration-lookup-table-router">4.6.2.3. Lookup Table Router</a></span></dt><dt><span class="section"><a href="configuration.html#configuration-subselect-router">4.6.2.4. Subselect Router</a></span></dt><dt><span class="section"><a href="configuration.html#configuration-scripted-router">4.6.2.5. Scripted Router</a></span></dt></dl></dd><dt><span class="section"><a href="configuration.html#configuration-trigger-router">4.6.3. Trigger / Router Mappings</a></span></dt><dd><dl><dt><span class="section"><a href="configuration.html#configuration-initial-load">4.6.3.1. Initial Load</a></span></dt><dt><span class="section"><a href="configuration.html#configuration-dead-triggers">4.6.3.2. Dead Triggers</a></span></dt><dt><span class="section"><a href="configuration.html#configuration-trigger-router-ping-back">4.6.3.3. Enabling "Ping Back"</a></span></dt></dl></dd></dl></dd><dt><span class="section"><a href="configuration.html#configuration-registration">4.7. Opening Registration</a></span></dt><dt><span class="section"><a href="configuration.html#transform-data">4.8. Transforming Data</a></span></dt><dd><dl><dt><span class="section"><a href="configuration.html#transform-data-tables">4.8.1. Transform Configuration Tables</a></span></dt><dt><span class="section"><a href="configuration.html#transform-data-types">4.8.2. Transformation Types</a></span></dt></dl></dd></dl></div>
    
    <p>
    <a href="planning.html" title="Chapter&nbsp;3.&nbsp;Planning an Implementation">Chapter&nbsp;3</a> introduced numerous concepts and the analysis and design needed to create an implementation of SymmetricDS.
    This chapter re-visits each analysis step and documents how to turn a SymmetricDS design into reality through configuration of
    the various SymmetricDS tables.  In addition, several advanced configuration options, not presented previously, will also be covered.
     </p>
    
    <div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="configuration-node-properties"></a>4.1.&nbsp;Node Properties</h2></div></div></div>
    
    <p>
        To get a SymmetricDS node running, it needs to be given an identity and it needs to know how
        to connect to the database it will be synchronizing.  A typical way to specify this is to place properties
        in the <code class="filename">symmetric.properties</code> file.  When started up, SymmetricDS reads the configuration
        and state from the database.  If the configuration tables are missing, they are created
        automatically (auto creation can be disabled).  Basic configuration is described by inserting into the following tables (the complete 
        data model is defined in <a href="data-model.html" title="Appendix&nbsp;A.&nbsp;Data Model">Appendix&nbsp;A, <i xmlns:xlink="http://www.w3.org/1999/xlink">Data Model</i></a>).
            </p><div class="itemizedlist"><ul type="disc"><li>
                    <p><a href="data-model.html#table_node_group" title="A.4.&nbsp;NODE_GROUP">NODE_GROUP</a> - specifies the tiers that exist in a SymmetricDS network</p>
                </li><li>
                    <p><a href="data-model.html#table_node_group_link" title="A.5.&nbsp;NODE_GROUP_LINK">NODE_GROUP_LINK</a> - links two node groups together for synchronization</p>
                </li><li>
                    <p><a href="data-model.html#table_channel" title="A.10.&nbsp;CHANNEL">CHANNEL</a> - grouping and priority of synchronizations</p>
                </li><li>
                    <p><a href="data-model.html#table_trigger" title="A.13.&nbsp;TRIGGER">TRIGGER</a> - specifies tables, channels, and conditions for which changes in the database should be captured</p>
                </li><li>
                    <p><a href="data-model.html#table_router" title="A.14.&nbsp;ROUTER">ROUTER</a> - specifies the routers defined for synchronization, along with other routing details</p>
                </li><li>
                    <p><a href="data-model.html#table_trigger_router" title="A.15.&nbsp;TRIGGER_ROUTER">TRIGGER_ROUTER</a> - provides mappings of routers and triggers</p>
                </li></ul></div><p>
        </p>
        <p>
        During start up, triggers are verified against the database, and database triggers
        are installed on tables that require data changes to be captured.  The Route, Pull and Push Jobs
        begin running to synchronize changes with other nodes.
      </p>
        <p>
            Each node requires properties that allow it to connect to a database and register
            with a parent node.  To give a node its identity, the following properties are used:
        </p>
        <div class="variablelist"><dl><dt><span class="term">
                    <span><strong class="command">group.id</strong></span>
                </span></dt><dd>
                    <p>
                        The node group that this node is a member of. Synchronization is specified
                        between node groups, which means you only need to specify it once for
                        multiple nodes in the same group. 
                    </p>
                </dd><dt><span class="term">
                    <span><strong class="command">external.id</strong></span>
                </span></dt><dd>
                    <p>
                        The external id for this node has meaning to the user and provides
                        integration into the system where it is deployed. For example, it might be a
                        retail store number or a region number. The external id can be used in
                        expressions for conditional and subset data synchronization. Behind the
                        scenes, each node has a unique sequence number for tracking synchronization
                        events. That makes it possible to assign the same external id to multiple
                        nodes, if desired.
                    </p>
                </dd><dt><span class="term">
                    <span><strong class="command">sync.url</strong></span>
                </span></dt><dd>
                    <p>
                        The URL where this node can be contacted for synchronization.
                        At startup and during each heartbeat, the node updates its entry in
                        the database with this URL.  
                    </p>
                </dd></dl></div>
        <p>
            When a new node is first started, it is has no information about synchronizing. It
            contacts the registration server in order to join the network and receive its
            configuration. The configuration for all nodes is stored on the registration server, and
            the URL must be specified in the following property:
        </p>
        <div class="variablelist"><dl><dt><span class="term">
                    <span><strong class="command">registration.url</strong></span>
                </span></dt><dd>
                    <p>
                        The URL where this node can connect for registration to receive its
                        configuration. The registration server is part of SymmetricDS and is enabled
                        as part of the deployment.
                    </p>
                </dd></dl></div>
        <div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Important</h3><p>
        Note that a <span class="emphasis"><em>registration server node</em></span> is defined as one whose <code class="literal">registration.url</code> is either (a) blank, or (b)
        identical to its <code class="literal">sync.url</code>.</p></div>
        <p>
            When deploying to an application server, it is common for database connection pools
            to be found in the Java naming directory (JNDI).  In this case, set the following property:
        </p>
        <div class="variablelist"><dl><dt><span class="term">
                    <span><strong class="command">db.jndi.name</strong></span>
                </span></dt><dd>
                    <p>
                        The name of the database connection pool to use, which is registered in the JNDI
                        directory tree of the application server. It is recommended that this DataSource is
                        NOT transactional, because SymmetricDS will handle its own transactions.
                    </p>
                </dd></dl></div>
        <p>
            For a deployment where the database connection pool should be created using a JDBC driver,
            set the following properties:
        </p>
        <div class="variablelist"><dl><dt><span class="term">
                    <span><strong class="command">db.driver</strong></span>
                </span></dt><dd>
                    <p>
                        The class name of the JDBC driver.
                    </p>
                </dd><dt><span class="term">
                    <span><strong class="command">db.url</strong></span>
                </span></dt><dd>
                    <p>
                        The JDBC URL used to connect to the database.
                    </p> 
                </dd><dt><span class="term">
                    <span><strong class="command">db.user</strong></span>
                </span></dt><dd>
                    <p>
                        The database username, which is used to login, create, and update SymmetricDS tables.
                    </p>
                </dd><dt><span class="term">
                    <span><strong class="command">db.password</strong></span>
                </span></dt><dd>
                    <p>
                        The password for the database user.
                    </p>
                </dd></dl></div>
       
      
    </div>
    
     <div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="configuration-node"></a>4.2.&nbsp;Node</h2></div></div></div>
            
            <p>
                A <span class="emphasis"><em>node</em></span>, a single instance of SymmetricDS, is defined in the  <a href="data-model.html#table_node" title="A.1.&nbsp;NODE">NODE</a> table.
                Two other tables play a direct role
            in defining a node, as well  The first is <a href="data-model.html#table_node_identity" title="A.3.&nbsp;NODE_IDENTITY">NODE_IDENTITY</a>. The <span class="emphasis"><em>only</em></span> row in this table
            is inserted in the database when the node first <span class="emphasis"><em>registers</em></span> with a parent node.  In the case 
            of a root node, the row is entered by the user.  The row is used by a node instance to determine its node identity.
            </p>
            <p>
            The following SQL statements set up a top-level registration server as a node identified
            as "00000" in the "corp" node group.
            
            </p><pre class="programlisting">
insert into SYM_NODE 
  (node_id, node_group_id, external_id, sync_enabled)
values
  ('00000', 'corp', '00000', 1);

insert into SYM_NODE_IDENTITY values ('00000');</pre><p>
        </p>
        <p>
        The second table, <a href="data-model.html#table_node_security" title="A.2.&nbsp;NODE_SECURITY">NODE_SECURITY</a> has rows
        created for each <span class="emphasis"><em>child</em></span> node that registers with the node, assuming auto-registration is enabled.
        If auto registration is not enabled, you must create a row in <a href="data-model.html#table_node" title="A.1.&nbsp;NODE">NODE</a> 
        and <a href="data-model.html#table_node_security" title="A.2.&nbsp;NODE_SECURITY">NODE_SECURITY</a> for the node to be able to register.  You can also, with this table,
        manually cause a node to re-register or do a re-initial load by setting the corresponding
        columns in the table itself.  Registration is discussed in more detail in
        <a href="configuration.html#configuration-registration" title="4.7.&nbsp;Opening Registration">Section&nbsp;4.7, &#8220;Opening Registration&#8221;</a>.
        </p>
    </div>
   
    <div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="configuration-node-group"></a>4.3.&nbsp;Node Group</h2></div></div></div>
        
        <p>
        Node Groups are straightforward to configure and are defined in the <a href="data-model.html#table_node_group" title="A.4.&nbsp;NODE_GROUP">NODE_GROUP</a> table.    
            The following SQL statements would create node groups for "corp" and "store" based on our retail store example. 

            </p><pre class="programlisting">
insert into SYM_NODE_GROUP 
  (node_group_id, description)
values
  ('store', 'A retail store node');

insert into SYM_NODE_GROUP 
  (node_group_id, description)
values
  ('corp', 'A corporate node');</pre><p>
        </p>
    </div>
    <div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="configuration-node-group-link"></a>4.4.&nbsp;Node Group Link</h2></div></div></div>
        
         <p>
           Similarly, Node Group links are established using a data event action of 'P' for Push and 'W' for Pull ("wait").
            The following SQL statements links the "corp" and "store" node groups for synchronization.
            It configures the "store" nodes to push their data changes to the "corp" nodes,
            and the "corp" nodes to send changes to "store" nodes by waiting for a pull.
            
            </p><pre class="programlisting">
insert into SYM_NODE_GROUP_LINK
  (source_node_group, target_node_group, data_event_action)
values
  ('store', 'corp', 'P');

insert into SYM_NODE_GROUP_LINK
  (source_node_group, target_node_group, data_event_action)
values
  ('corp', 'store', 'W');</pre><p>
        </p>
    </div>
   
    <div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="configuration-channel"></a>4.5.&nbsp;Channel</h2></div></div></div>
        
        <p>
            By categorizing data into channels and assigning them to <a href="data-model.html#table_trigger" title="A.13.&nbsp;TRIGGER">TRIGGER</a>s, the user gains more control and visibility into
            the flow of data.  In addition, SymmetricDS allows for synchronization to be enabled, suspended, or scheduled by channels as well. 
            The frequency of synchronization and order that data gets synchronized is also controlled at the channel level.
        </p>
        <p>
            The following SQL statements setup channels for a retail store.  An "item" channel includes
            data for items and their prices, while a "sale_transaction" channel includes data for ringing
            sales at a register. 
            
            </p><pre class="programlisting">
insert into SYM_CHANNEL 
  (channel_id, processing_order, max_batch_size, max_batch_to_send, 
   extract_period_millis, batch_algorithm, enabled, description)
values
  ('item', 10, 1000, 10,  0, 'default', 1, 'Item and pricing data');

insert into SYM_CHANNEL 
  (channel_id, processing_order, max_batch_size, max_batch_to_send, 
   extract_period_millis, batch_algorithm, enabled, description)
values
  ('sale_transaction', 1, 1000, 10,  60000, 'transactional', 1, 
   'retail sale transactions from register');</pre><p>
        </p>
        <p>
            Batching is the grouping of data, by channel, to be transferred and committed at 
            the client together.  There are three different out-of-the-box batching algorithms which 
            may be configured in the batch_algorithm column on channel.  
         </p><div class="variablelist"><dl><dt><span class="term">
                    <span><strong class="command">default</strong></span>
                </span></dt><dd>
                    <p>
                        All changes that happen in a transaction are guaranteed to be batched 
                        together.  Multiple transactions will be batched and committed together
                        until there is no more data to be sent or the max_batch_size is reached.
                    </p>
                </dd><dt><span class="term">
                    <span><strong class="command">transactional</strong></span>
                </span></dt><dd>
                    <p>
                        Batches will map directly to database transactions.  If there are many
                        small database transactions, then there will be many batches.  The max_batch_size
                        column has no effect.
                    </p> 
                </dd><dt><span class="term">
                    <span><strong class="command">nontransactional</strong></span>
                </span></dt><dd>
                    <p>
                        Multiple transactions will be batched and committed together
                        until there is no more data to be sent or the max_batch_size is reached.  
                        The batch will be cut off at the max_batch_size regardless of whether
                        it is in the middle of a transaction. 
                    </p>
                </dd></dl></div><p>
        </p>
        <p>
        There are also several size-related parameters that can be set by channel.  They include:
         </p><div class="variablelist"><dl><dt><span class="term">
                    <span><strong class="command">max_batch_size</strong></span>
                </span></dt><dd>
                    <p>
                       Specifies the maximum number of data events to process within a batch for this channel.
                    </p>
                </dd><dt><span class="term">
                    <span><strong class="command">max_batch_to_send</strong></span>
                </span></dt><dd>
                    <p>
                        Specifies the maximum number of batches to send for a given channel during a 'synchronization' between two nodes.
                        A 'synchronization' is equivalent to a push or a pull.
                        For example, if there are 12 batches ready to be sent for a channel and max_batch_to_send is equal to 10,
                        then only the first 10 batches will be sent even though 12 batches are ready.
                        </p>
                </dd><dt><span class="term">
                    <span><strong class="command">max_data_to_route</strong></span>
                </span></dt><dd>
                    <p>
                        Specifices the maximum number of data rows to route for a channel at a time.
                     </p>
                </dd></dl></div><p>
        </p>
        <p>
        Based on your particular synchronization requirements, you can also specify whether old, new, and primary key data should be read and included during routing for a given channel.  These are controlled by
        the columns use_old_data_to_route, use_row_data_to_route, and use_pk_data_to_route, respectively.  By default, they are all 1 (true).
        </p>
        <p>
        Finally, if data on a particular channel contains big lobs, you can set the column  contains_big_lob to 1 (true) to provide SymmetricDS the hint that the channel contains big lobs.  
        Some databases have shortcuts that SymmetricDS can take advantage of if it knows that the lob columns in <a href="data-model.html#table_data" title="A.20.&nbsp;DATA">DATA</a>
         aren't going to contain large lobs.  The definition of how large a 'big' lob is varies from database to database.
        </p>
    </div>
       
    <div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="configuration-triggers-and-routers"></a>4.6.&nbsp;Triggers and Routers</h2></div></div></div>
                 
            
    <div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="configuration-trigger"></a>4.6.1.&nbsp;Trigger</h3></div></div></div>
        
        <p>
            SymmetricDS captures synchronization data using database triggers. SymmetricDS' Triggers are defined in the 
              <a href="data-model.html#table_trigger" title="A.13.&nbsp;TRIGGER">TRIGGER</a> table.  
            Each record is used by SymmetricDS when generating database triggers.  Database triggers are only generated when a trigger 
            is associated with a <a href="data-model.html#table_router" title="A.14.&nbsp;ROUTER">ROUTER</a> whose <code class="literal">source_node_group_id</code> matches the node group id of the current node.
        </p>
        <p>
        When determining whether a data change has occurred or not, by defalt the triggers will
        record a change even if the data was updated to the same value(s) they were originally.
        For example, a data change will be captured if an update of one column in a row
        updated the value to the same value it already was.
        There is a global property, <code class="literal">trigger.update.capture.changed.data.only.enabled</code> (false by default),
        that allows you to override this behavior. When set to true, SymmetricDS will only capture a change if
        the data has truly changed (i.e., when the new column data is not equal to the old column data).
        </p>
        <div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Important</h3>
        The property <code class="literal">trigger.update.capture.changed.data.only.enabled</code> 
        is currently only supported in the MySQL and Oracle dialects.
        </div>
        
        <p>
            The following SQL statement defines a trigger that will capture data for a table named "item"
            whenever data is inserted, updated, or deleted. The trigger is assigned to a channel also called 'item'.            
            </p><pre class="programlisting">
insert into SYM_TRIGGER 
    (trigger_id,source_table_name,channel_id,last_update_time,create_time)
  values
    ('item', 'item', 'item', current_timestamp, current_timestamp);
</pre><p>
        </p>
        
        <p>
        Two lobs-related settings are also available on  <a href="data-model.html#table_trigger" title="A.13.&nbsp;TRIGGER">TRIGGER</a>:
        
       </p><div class="variablelist"><dl><dt><span class="term">
                <span><strong class="command">use_stream_lobs</strong></span>
            </span></dt><dd>
                <p>
                    Specifies whether to capture lob data as the trigger is firing or to stream lob columns from the source tables using callbacks during extraction.
                    A value of 1 indicates to stream from the source via callback; a value of 0, lob data is captured by the trigger.
               </p>
            </dd><dt><span class="term">
                <span><strong class="command">use_capture_lobs</strong></span>
            </span></dt><dd>
                <p>
                 Provides a hint as to whether this trigger will capture big lobs data.  If set to 1 every effort will be made during data capture in trigger and during data selection for initial load 
                 to use lob facilities to extract and store data in the database.
                </p>
            </dd></dl></div><p>
        </p>
            
        <div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Important</h3>
        <p>
            Note that many databases allow for multiple triggers of the same type to be defined.  
            Each database defines the order in which the triggers fire differently.  If you have
            additional triggers beyond those SymmetricDS installs on your table, please consult
            your database documentation to determine if there will be issues with
            the ordering of the triggers.
        </p>
    </div>
    </div>
    <div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="configuration-router"></a>4.6.2.&nbsp;Router</h3></div></div></div>
        
      <p>
                Routers provided in the base implementation currently include:
                </p><div class="itemizedlist"><ul type="disc"><li>Default Router - a router that sends all data to all nodes that belong to the target node group defined in the router.</li><li>Column Match Router - a router that compares old or new column values to a constant value or the
                        value of a node's external_id or node_id.</li><li>Lookup Router - a router which can be configured to determine routing based on an existing or ancillary table specifically for the
                    purpose of routing data.        
                    </li><li>Subselect Router - a router that executes a SQL expression against the database to select nodes to
                        route to. This SQL expression can be passed values of old and new column values.</li><li>Scripted Router - a router that executes a Bean Shell script expression in order to select nodes to route to.
                        The script can use the the old and new column values.</li><li>Xml Publishing Router - a router the publishes data changes directly to a messaging solution instead
                        of transmitting changes to registered nodes.  This router must be configured manually in XML as an extension point.</li></ul></div><p>
                The mapping between the set of triggers and set of routers is many-to-many.  This means that one trigger can capture changes and route
                to multiple locations.  It also means that one router can be defined an associated with many different triggers.
            </p>
    
    
    <div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="configuration-default-router"></a>4.6.2.1.&nbsp;Default Router</h4></div></div></div>
        
        <p>
            The simplest router is a router that sends all the data that is captured by its 
            associated triggers to all the nodes that belong to the target node group defined
            in the router.  A router is defined as a row in the <a href="data-model.html#table_router" title="A.14.&nbsp;ROUTER">ROUTER</a> table.
            It is then linked to triggers in the <a href="data-model.html#table_trigger_router" title="A.15.&nbsp;TRIGGER_ROUTER">TRIGGER_ROUTER</a> table.  
        </p>
        <p>
            The following SQL statement defines a router that will send data from the 'corp' group to the 'store' group.            
            </p><pre class="programlisting">
insert into SYM_ROUTER 
  (router_id, source_node_group_id, target_node_group_id, 
    create_time, last_update_time)
values
  ('corp-2-store','corp', 'store', current_timestamp, current_timestamp);

</pre><p>
        </p>
        <p>
            The following SQL statement maps the 'corp-2-store' router to the item trigger.            
            </p><pre class="programlisting">
insert into SYM_TRIGGER_ROUTER 
  (trigger_id, router_id, initial_load_order,  create_time, last_update_time)
values
  ('item', 'corp-2-store', 1, current_timestamp, current_timestamp);

</pre><p>
        </p>        
    </div>
   
    <div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="configuration-column-match-router"></a>4.6.2.2.&nbsp;Column Match Router</h4></div></div></div>
        
        <p>
            Sometimes requirements may exist that require data to be routed based on the current value or the old value of a 
            column in the table that is being routed.  Column routers are configured by setting the <code class="literal">router_type</code> column on the 
              <a href="data-model.html#table_router" title="A.14.&nbsp;ROUTER">ROUTER</a> table
            to <code class="literal">column</code> and setting the <code class="literal">router_expression</code> column to an equality expression that represents
            the expected value of the column.
        </p>
        <p>             
            The first part of the expression is always the column name.  The column name should always be defined in upper case.
            The upper case column name prefixed by OLD_ can be used for a comparison being done with the old column data value.
        </p>
        <p>
            The second part of the expression can be a constant value, a token that represents another column, or a token
            that represents some other SymmetricDS concept.  Token values always begin with a colon (:).
        </p>                  
        <p>
            Consider a table that needs to be routed to all nodes in the target group only when a status column is set to 'OK.'  The following 
            SQL statement will insert a column router to accomplish that.            
            </p><pre class="programlisting">
insert into SYM_ROUTER 
(router_id, source_node_group_id, target_node_group_id, router_type, 
 router_expression, create_time, last_update_time)
values
('corp-2-store-ok','corp', 'store', 'column', 
 'STATUS=OK', current_timestamp, current_timestamp);

</pre><p>
         </p>            
        <p>
            Consider a table that needs to be routed to all nodes in the target group only when a status column changes values.  The following 
            SQL statement will insert a column router to accomplish that.  Note the use of OLD_STATUS, where the OLD_ prefix gives access to the old column value.          
            </p><pre class="programlisting">
insert into SYM_ROUTER 
  (router_id, source_node_group_id, target_node_group_id, router_type, 
    router_expression, create_time, last_update_time)
values
  ('corp-2-store-status','corp', 'store', 'column', 
    'STATUS!=:OLD_STATUS', current_timestamp, current_timestamp);

</pre><p>
         </p>            
        <p>
            Consider a table that needs to be routed to only nodes in the target group whose STORE_ID column matches the external id of a node.  The following 
            SQL statement will insert a column router to accomplish that.            
            </p><pre class="programlisting">
insert into SYM_ROUTER 
  (router_id, source_node_group_id, target_node_group_id, router_type, 
    router_expression, create_time, last_update_time)
values
  ('corp-2-store-id','corp', 'store', 'column', 
    'STORE_ID=:EXTERNAL_ID', current_timestamp, current_timestamp);

</pre><p>
            Attributes on a <a href="data-model.html#table_node" title="A.1.&nbsp;NODE">NODE</a> that can be referenced with tokens include:
            </p><div class="itemizedlist"><ul type="disc"><li>NODE_ID</li><li>EXTERNAL_ID</li><li>NODE_GROUP_ID</li></ul></div><p>
        </p>   
        <p>
            Consider a table that needs to be routed to a redirect node defined by its external id in the <a href="data-model.html#table_registration_redirect" title="A.17.&nbsp;REGISTRATION_REDIRECT">REGISTRATION_REDIRECT</a> table.  The following 
            SQL statement will insert a column router to accomplish that.            
            </p><pre class="programlisting">
insert into SYM_ROUTER 
  (router_id, source_node_group_id, target_node_group_id, router_type, 
    router_expression, create_time, last_update_time)
values
  ('corp-2-store-redirect','corp', 'store', 'column', 
    'STORE_ID=:REDIRECT_NODE', current_timestamp, current_timestamp);
</pre><p>                        
         </p>
         <p>
            More than one column may be configured in a router_expression.  When more than one column is configured, all matches are added to the list of nodes to route to.  The following is
            an example where the STORE_ID column may contain the STORE_ID to route to or the constant of ALL which indicates that all nodes should receive the update.       
            </p><pre class="programlisting">
insert into SYM_ROUTER 
  (router_id, source_node_group_id, target_node_group_id, router_type, 
    router_expression, create_time, last_update_time)
values
  ('corp-2-store-multiple-matches','corp', 'store', 'column', 
   'STORE_ID=ALL or STORE_ID=:EXTERNAL_ID', current_timestamp, current_timestamp);
</pre><p>                        
         </p>    
         <p>
         The NULL keyword may be used to check if a column is null.  If the column is null, then data will be routed to all nodes who qualify for the update.  This following is an example 
         where the STORE_ID column is used to route to a set of nodes who have a STORE_ID equal to their EXTERNAL_ID, or to all nodes if the STORE_ID is null.
          </p><pre class="programlisting">
insert into SYM_ROUTER 
  (router_id, source_node_group_id, target_node_group_id, router_type, 
    router_expression, create_time, last_update_time)
values
  ('corp-2-store-multiple-matches','corp', 'store', 'column', 
   'STORE_ID=NULL or STORE_ID=:EXTERNAL_ID', current_timestamp, current_timestamp);
</pre><p>    
         </p>                    
    </div>    
    
    <div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="configuration-lookup-table-router"></a>4.6.2.3.&nbsp;Lookup Table Router</h4></div></div></div>
        
        <p>
            A lookup table may contain the id of the node where data needs to be routed.  This could be an existing table or an ancillary table that is added
            specifically for the purpose of routing data.  Lookup table routers are configured by setting the <code class="literal">router_type</code> column on the 
              <a href="data-model.html#table_router" title="A.14.&nbsp;ROUTER">ROUTER</a> table
            to <code class="literal">lookuptable</code> and setting a list of configuration parameters in the <code class="literal">router_expression</code> column.
        </p>
        <p>     
            Each of the following configuration parameters are required.          
            </p><div class="variablelist"><dl><dt><span class="term">
                        <span><strong class="command">LOOKUP_TABLE</strong></span>
                    </span></dt><dd>
                        <p>
                        This is the name of the lookup table.
                        </p>
                    </dd><dt><span class="term">
                        <span><strong class="command">KEY_COLUMN</strong></span>
                    </span></dt><dd>
                        <p>
                        This is the name of the column on the table that is being routed.  It will be used as a key into the lookup table.
                        </p>
                    </dd><dt><span class="term">
                        <span><strong class="command">LOOKUP_KEY_COLUMN</strong></span>
                    </span></dt><dd>
                        <p>
                        This is the name of the column that is the key on the lookup table.
                        </p>
                    </dd><dt><span class="term">
                        <span><strong class="command">EXTERNAL_ID_COLUMN</strong></span>
                    </span></dt><dd>
                        <p>
                        This is the name of the column that contains the external_id of the node to route to on the lookup table.
                        </p>
                    </dd></dl></div><p>
        </p>
        <p>
            Note that the lookup table will be read into memory and cached for the duration of a routing pass for a single channel.
        </p>                  
        <p>
            Consider a table that needs to be routed to a specific store, but the data in the changing table only contains brand information.  In this case,
            the STORE table may be used as a lookup table.            
            </p><pre class="programlisting">
insert into SYM_ROUTER 
(router_id, source_node_group_id, target_node_group_id, router_type, 
 router_expression, create_time, last_update_time)
values
('corp-2-store-ok','corp', 'store', 'lookuptable', 
 'LOOKUP_TABLE=STORE
KEY_COLUMN=BRAND_ID
LOOKUP_KEY_COLUMN=BRAND_ID
EXTERNAL_ID_COLUMN=STORE_ID', current_timestamp, current_timestamp);

</pre><p>
         </p>            
     </div>

    <div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="configuration-subselect-router"></a>4.6.2.4.&nbsp;Subselect Router</h4></div></div></div>
        
        <p>
            Sometimes routing decisions need to be made based on data that is not in the current row being synchronized.  Consider an 
            example where an Order table and a OrderLineItem table need to be routed to a specific store.  The Order table has a column 
            named order_id and STORE_ID.  A store node has an external_id that is equal to the STORE_ID on the Order table.  OrderLineItem, 
            however, only has a foreign key to its Order of order_id.  To route OrderLineItems to the same nodes that the Order will be routed
            to, we need to reference the master Order record.
        </p>
        <p>             
            There are two possible ways to route the OrderLineItem in SymmetricDS.  One is to configure a 'subselect' router_type on the <a href="data-model.html#table_router" title="A.14.&nbsp;ROUTER">ROUTER</a> table
            and the other is to configure an external_select on the <a href="data-model.html#table_trigger" title="A.13.&nbsp;TRIGGER">TRIGGER</a> table. 
        </p>
        <p>
            A 'subselect' is configured with a router_expression that is a SQL select statement which returns a result set of the node_ids that need routed to.  Column tokens can
            be used in the SQL expression and will be replaced with row column data.  The overhead of using this router type is high because the 'subselect' statement runs for each row 
            that is routed.  It should not be used for tables that have a lot of rows that are updated.  It also has the disadvantage that if the Order master record is deleted, 
            then no results would be returned and routing would not happen.  The router_expression is appended to the following
            SQL statement in order to select the node ids.
            </p><pre class="programlisting">

select c.node_id from sym_node c where 
  c.node_group_id=:NODE_GROUP_ID and c.sync_enabled=1 and 
</pre><p>  
        </p>                  
        <p>
            Consider a table that needs to be routed to all nodes in the target group only when a status column is set to 'OK.'  The following 
            SQL statement will insert a column router to accomplish that.            
            </p><pre class="programlisting">
insert into SYM_ROUTER 
  (router_id, source_node_group_id, target_node_group_id, router_type, 
    router_expression, create_time, last_update_time)
values
  ('corp-2-store','corp', 'store', 'subselect', 
    'c.external_id in (select STORE_ID from order where order_id=:ORDER_ID)', 
    current_timestamp, current_timestamp);
</pre><p>
         </p>            
        <p>
            Alternatively, when using an external_select on the <a href="data-model.html#table_trigger" title="A.13.&nbsp;TRIGGER">TRIGGER</a> table, data is captured in the EXTERNAL_DATA column of the <a href="data-model.html#table_data" title="A.20.&nbsp;DATA">DATA</a> table at the time a trigger 
            fires.  The EXTERNAL_DATA can then be used for routing by using a router_type of 'column'.  The advantage of this approach is that it is very unlikely that the master Order table
            will have been deleted at the time any DML accures on the OrderLineItem table.  It also is a bit more effcient than the 'subselect' approach, although the triggers produced do run 
            the extra external_select inline with application database updates.  
        </p>            
        <p>
            In the following example, the STORE_ID is captured from the Order table in the EXTERNAL_DATA column.  EXTERNAL_DATA is always available for routing as a virtual column in a 'column'
            router.  The router is configured to route based on the captured EXTERNAL_DATA to all nodes whose external_id matches.  Note that other supported node attribute tokens can also be 
            used for routing.      
            </p><pre class="programlisting">

insert into SYM_TRIGGER 
  (trigger_id,source_table_name,channel_id,external_select,
    last_update_time,create_time)
values
  ('orderlineitem', 'orderlineitem', 'orderlineitem','select STORE_ID 
    from order where order_id=$(curTriggerValue).$(curColumnPrefix)order_id',
    current_timestamp, current_timestamp);

insert into SYM_ROUTER 
  (router_id, source_node_group_id, target_node_group_id, router_type, 
    router_expression, create_time, last_update_time)
values
  ('corp-2-store-ext','corp', 'store', 'column', 
    'EXTERNAL_DATA=:EXTERNAL_ID', current_timestamp, current_timestamp);
</pre><p>
         </p>   
         <p>
         Note the syntax $(curTriggerValue).$(curColumnPrefix).  This translates into "OLD_" or "NEW_" based on the DML type being run.  In the case of Insert or Update, it's NEW_.  For Delete, it's OLD_ (since there is no
         new data).  In this way, you can access the DML-appropriate value for your select statement.
         </p>         
    </div>  
    
    <div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="configuration-scripted-router"></a>4.6.2.5.&nbsp;Scripted Router</h4></div></div></div>
        
        <p>
            When more flexibility is needed in the logic to choose the nodes to route to, then the a scripted router may be used.  The currently available scripting language is Bean Shell. Bean Shell is a Java-like scripting language.  Documentation 
            for the Bean Shell scripting language can be found at <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.beanshell.org/" target="_top">http://www.beanshell.org</a>. 
        </p>
        <p>
            The router_type for a Bean Shell scripted router is 'bsh'.  The router_expression is a valid Bean Shell script that:
            </p><div class="itemizedlist"><ul type="disc"><li>adds node ids to the 'targetNodes' collection which is bound to the script</li><li>returns a new collection of node ids</li><li>returns a single node id</li><li>returns true to indicate that all nodes should be routed or returns false to indicate that no nodes should be routed</li></ul></div><p>                          
            Also bound to the script evaluation is a list of 'nodes'.  The list of 'nodes' is 
            a list of eligible Node objects.  The current data column values and the old data column values are bound to the script evaluation as Java object representations of the column data. 
            The columns are bound using the uppercase names of the columns.  Old values are bound to uppercase representations that are prefixed with 'OLD_'. 
        </p>        
        <p>
            In the following example, the node_id is a combination of STORE_ID and WORKSTATION_NUMBER, both of which are columns on the table that is being routed.
            </p><pre class="programlisting">

insert into SYM_ROUTER 
  (router_id, source_node_group_id, target_node_group_id, router_type, 
    router_expression, create_time, last_update_time)
values
  ('corp-2-store-bsh','corp', 'store', 'bsh', 
    'targetNodes.add(STORE_ID + "-" + WORKSTATION_NUMBER);', 
    current_timestamp, current_timestamp);
</pre><p>
        </p>
        <p>
            The same could also be accomplished by simply returning the node id.  The last line of a bsh script is always the return value.
            </p><pre class="programlisting">

insert into SYM_ROUTER 
  (router_id, source_node_group_id, target_node_group_id, router_type, 
    router_expression, create_time, last_update_time)
values
  ('corp-2-store-bsh','corp', 'store', 'bsh', 
    'STORE_ID + "-" + WORKSTATION_NUMBER', 
    current_timestamp, current_timestamp);
</pre><p>
         </p>     
         <p>
            The following example will synchronize to all nodes if the FLAG column has changed, otherwise
            no nodes will be synchronized.  Note that here we make use of OLD_, which provides access to the old column value.
            </p><pre class="programlisting">

insert into SYM_ROUTER 
  (router_id, source_node_group_id, target_node_group_id, router_type, 
    router_expression, create_time, last_update_time)
values
  ('corp-2-store-flag-changed','corp', 'store', 'bsh', 
    'FLAG != null &amp;&amp; !FLAG.equals(OLD_FLAG)', 
    current_timestamp, current_timestamp);
</pre><p>
        </p>   
    </div>  
    </div>
     <div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="configuration-trigger-router"></a>4.6.3.&nbsp;Trigger / Router Mappings</h3></div></div></div>
        
        <p>
        Two important controls can be configured for a specific Trigger / Router combination: Initial Load and Ping Back.
         The parameters for these can be found in the Trigger / Router mapping table,
        <a href="data-model.html#table_trigger_router" title="A.15.&nbsp;TRIGGER_ROUTER">TRIGGER_ROUTER</a>.
        </p>
       
        <div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="configuration-initial-load"></a>4.6.3.1.&nbsp;Initial Load</h4></div></div></div>
        
        <p>
            An initial load is the process of seeding tables at a target node with data from its parent node.
            When a node connects and data is extracted, after it is registered and if an initial load was requested, each table that is configured to synchronize to the target node
              group will be given a reload event in the order defined by the end user.  A SQL statement is run against each table to get the data load that will be streamed to the target node.  
              The selected data is filtered through the configured router for the table being loaded.  If the data set is going to be large, then SQL criteria can optionally be provided to pair 
              down the data that is selected out of the database.
            </p>
            <p>
            An initial load can not occur until after a node is registered.  An initial load is 
            requested by setting the <code class="literal">initial_load_enabled</code> column on <a href="data-model.html#table_node_security" title="A.2.&nbsp;NODE_SECURITY">NODE_SECURITY</a> to
            <span class="emphasis"><em>1</em></span> on the row for the target node in the parent node's database.  The next time the 
            target node synchronizes, reload batches will be inserted.  At the same time reload batches 
            are inserted, all previously pending batches for the node are marked as successfully sent.    
        </p>
         <div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Important</h3>
            <p>
            Note that if the parent node that a node is registering with is <span class="emphasis"><em>not</em></span> a registration server node 
            (as can happen with a registration redirect or certain non-tree structure node configurations)
            the parent node's <a href="data-model.html#table_node_security" title="A.2.&nbsp;NODE_SECURITY">NODE_SECURITY</a> entry must exist at the parent node and have a non-null value for
            column <code class="literal">initial_load_time</code>.  Nodes can't be registered to non-registration-server nodes without this value being set one way or another (i.e.,
            manually, or as a result of an initial load occuring at the parent node).
            </p>
        </div>   
        <p>
            SymmetricDS recognizes that an initial load has completed when the <code class="literal">initial_load_time</code> column on the
            target node is set to a non-null value.
        </p>
        <p>
            An initial load is accomplished by inserting reload batches in a defined order according to the <code class="literal">initial_load_order</code> column on
            <a href="data-model.html#table_trigger_router" title="A.15.&nbsp;TRIGGER_ROUTER">TRIGGER_ROUTER</a>.  Initial load data is always queried from the 
            source database table.  All data is passed through the configured router to filter out data that 
            might not be targeted at a node.  
        </p>
        <p>    
            An efficient way to select a subset of data from a table for an initial load is to provide an
            <code class="literal">initial_load_select</code> clause on <a href="data-model.html#table_trigger_router" title="A.15.&nbsp;TRIGGER_ROUTER">TRIGGER_ROUTER</a>.            
            This clause, if present, is applied as a <code class="literal">where</code> clause to the SQL used to select the data to be loaded.
            The clause may use "t" as an alias for the table being loaded, if needed.
            If an <code class="literal">initial_load_select</code> clause is provided, data will <span class="emphasis"><em>not</em></span> be passed through the 
            configured router during initial load.  In cases where routing is done using a feature like <a href="configuration.html#configuration-subselect-router" title="4.6.2.4.&nbsp;Subselect Router">Section&nbsp;4.6.2.4, &#8220;Subselect Router&#8221;</a>,
            an <code class="literal">initial_load_select</code> clause matching the subselect's criteria would be a more efficient approach.   
        </p>
        <p>
        One example of the use of an initial load select would be if you wished to only load data created more recently than the start of year 2011.  Say, for example,
        the column <code class="literal">created_time</code> contains the creation date.  Your <code class="literal">initial_load_select</code> would read
        <code class="literal">created_time &gt; ts {'2011-01-01 00:00:00.0000'}</code> (using whatever timestamp format works for your database).  This
        then gets applied as a <code class="literal">where</code> clause when selecting data from the table.
        </p>
        <div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Important</h3>
            <p>
            When providing an <code class="literal">initial_load_select</code> be sure to test out the criteria against production data in a query browser.  Do an explain plan to make sure you are properly using indexes.
            </p>
        </div>  
            
        </div>      
     <div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="configuration-dead-triggers"></a>4.6.3.2.&nbsp;Dead Triggers</h4></div></div></div>
        
           <p>
            Occasionally the decision of what data to load initially results in additional triggers.  These triggers, known as <span class="emphasis"><em>Dead Triggers</em></span>,
            are configured such that they do not capture any data changes.  
            A "dead" Trigger is one that does not capture data changes.
            In other words, the <code class="literal">sync_on_insert</code>, <code class="literal">sync_on_update</code>, and <code class="literal">sync_on_delete</code> properties
            for the Trigger are all set to false.  However, since the Trigger is specified, it <span class="emphasis"><em>will</em></span> 
            be included in the initial load of data for target Nodes.
        </p>
        <p>
           Why might you need a Dead Trigger?
            A dead Trigger might be used to load a read-only lookup table, for example.  It could also 
            be used
            to load a table that needs populated with example or default data.
            Another use is a recovery load of data for tables that have a single direction
            of synchronization.  For example, a retail store records sales transaction that
            synchronize in one direction by trickling back to the central office.
            If the retail store needs to recover all the sales transactions from the central office,
            they can be sent
            are part of an initial load from the central office by setting up dead Triggers
            that "sync" in that direction.
        </p>
     
        <p>
            The following SQL statement sets up a non-syncing dead Trigger that sends
            the <code class="literal">sale_transaction</code> table to the "store" Node Group from the "corp" Node Group during
            an initial load.
            </p><pre class="programlisting">

insert into sym_trigger (TRIGGER_ID,SOURCE_CATALOG_NAME,
  SOURCE_SCHEMA_NAME,SOURCE_TABLE_NAME,CHANNEL_ID,
  SYNC_ON_UPDATE,SYNC_ON_INSERT,SYNC_ON_DELETE,
  SYNC_ON_INCOMING_BATCH,NAME_FOR_UPDATE_TRIGGER,
  NAME_FOR_INSERT_TRIGGER,NAME_FOR_DELETE_TRIGGER,
  SYNC_ON_UPDATE_CONDITION,SYNC_ON_INSERT_CONDITION,
  SYNC_ON_DELETE_CONDITION,EXTERNAL_SELECT,
  TX_ID_EXPRESSION,EXCLUDED_COLUMN_NAMES,
  CREATE_TIME,LAST_UPDATE_BY,LAST_UPDATE_TIME) 
  values ('SALE_TRANSACTION_DEAD',null,null,
  'SALE_TRANSACTION','transaction',
  0,0,0,0,null,null,null,null,null,null,null,null,null,
  current_timestamp,'demo',current_timestamp);

insert into sym_router (ROUTER_ID,TARGET_CATALOG_NAME,TARGET_SCHEMA_NAME,
  TARGET_TABLE_NAME,SOURCE_NODE_GROUP_ID,TARGET_NODE_GROUP_ID,ROUTER_TYPE,
  ROUTER_EXPRESSION,SYNC_ON_UPDATE,SYNC_ON_INSERT,SYNC_ON_DELETE,
  CREATE_TIME,LAST_UPDATE_BY,LAST_UPDATE_TIME) 
  values ('CORP_2_STORE',null,null,null,
  'corp','store',null,null,1,1,1,
  current_timestamp,'demo',current_timestamp);
   
insert into sym_trigger_router (TRIGGER_ID,ROUTER_ID,INITIAL_LOAD_ORDER,
  INITIAL_LOAD_SELECT,CREATE_TIME,LAST_UPDATE_BY,LAST_UPDATE_TIME) 
  values ('SALE_TRANSACTION_DEAD','CORP_2_REGION',100,null,
   current_timestamp,'demo',current_timestamp);
   </pre><p>
        </p>
    </div>
    
      <div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="configuration-trigger-router-ping-back"></a>4.6.3.3.&nbsp;Enabling "Ping Back"</h4></div></div></div>
           
           
           <p>
           As discussed in <a href="planning.html#defining-data-changes-trigger-routers-ping-back" title="3.6.3.2.&nbsp;Circular References and &#34;Ping Back&#34;">Section&nbsp;3.6.3.2, &#8220;Circular References and "Ping Back"&#8221;</a> SymmetricDS, by default, avoids circular
           data changes.   When a trigger fires as a result of SymmetricDS itself (such as the case when sync on incoming batch is set),
           it records the originating source node of the data change in <code class="literal">source_node_id</code>.
           During routing, if routing results in sending the data back to the originating source node, the data is not routed by default.
           If instead you wish to route the data back to the originating node, you can set the <code class="literal">ping_back_enabled</code>
           column for the needed particular trigger / router combination.  This will cause the router to "ping" the data back to the originating
           node when it usually would not. 
           </p>
        </div>
    </div>
     </div>  
       <div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="configuration-registration"></a>4.7.&nbsp;Opening Registration</h2></div></div></div>
        
        <p>
        Node registration is the act of setting up a new <a href="data-model.html#table_node" title="A.1.&nbsp;NODE">NODE</a> and
         <a href="data-model.html#table_node_security" title="A.2.&nbsp;NODE_SECURITY">NODE_SECURITY</a> so that when the new node is brought online
         it is allowed to join the system.  Nodes are only allowed to register if rows exist for the
         node and the <code class="literal">registration_enabled</code> flag is set to 1.  If the <code class="literal">auto.registration</code>
         SymmetricDS property is set to true, then when a node attempts to register, if registration
         has not already occurred, the node will automatically be registered.
       </p>
       <p> 
        SymmetricDS allows you to have multiple nodes with the same <code class="literal">external_id</code>.  Out of the box, openRegistration 
        will open a new registration if a registration already exists for a node with the same external_id.  A new 
        registration means a new node with a new <code class="literal">node_id</code> and the same <code class="literal">external_id</code> will be created.  
        If you want to re-register the same node you can use the <code class="literal">reOpenRegistration()</code> JMX
        method which takes a <code class="literal">node_id</code> as an argument.
        </p>
    </div>
  
    <div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="transform-data"></a>4.8.&nbsp;Transforming Data</h2></div></div></div>
        
        <p>
        New to SymmetricDS 2.4, SymmetricDS is now able to transform synchronized data by way of
        configuration (previously, for most cases a custom data loader would need to have been written).  This transformation can take
        place on a source node or on a target node, as the data is being loaded or extracted.
        With this new feature you can, for example:
        </p>
        <div class="itemizedlist"><ul type="disc"><li>
                    <p>Copy a column from a source table to two (or more) target table columns,</p>
                </li><li>
                    <p>Merge columns from two or more source tables into a single row in a target table,</p>
                </li><li>
                    <p>Insert constants in columns in target tables based on source data synchronizations,</p>
                </li><li>
                    <p>Insert multiple rows of data into a single target table based on one change in a source table,</p>
                </li><li>
                    <p>Apply a Bean Shell script to achieve a custom transform when loading into the target database.</p>
                </li></ul></div>
         <p>
         These transformations can take place either on the target or on the source, and as data is either being extracted or loaded.  In either case, the transformation is
         initiated due to existence of a source
         synchronization trigger.  The source trigger creates the synchronization data, while the transformation configuration decides
         what to do with the sychronization data as it is either being extracted from the source or loaded into the target.
         You have the flexibility of defining different transformation behavior depending on whether the source
         change that triggered the synchronization was an Insert, Update, or Delete.  In the case of Delete, you even have options on what exactly to do on the target side, 
         be it a delete of a row, setting columns to specific values, or absolutely nothing at all.
         </p>
         <p>
         A few key concepts are important to keep in mind to understand how SymmetricDS performs transformations.  The first concept is that of the
         "source operation" or "source DML type", which is the type of operation that occurred to generate the synchronization data in the first place (i.e., an insert, a delete, or an update).
         Your transformations can be configured to act differently based on the source DML type, if desired.  When transforming, by
         default the DML action taken on the target matches that of the action taken on the row in the source (although this behavior can be altered through configuration if needed).  If the
         source DML type is an Insert, for example, the resulting transformation DML(s) will be Insert(s).
         </p>
         <p>
         Another important concept is the way in which transforms are applied.  Each source operation may map to one or more transforms and result in one
         or more operations on the target tables.  Each of these target operations are performed as independent operations in sequence and must be "complete" from a SQL perspective.  In other words, you
         must define columns for the transformation that are sufficient to fill in any primary key or other required data in the target table if the source operation
         was an Insert, for example.
         </p>  
         <p>
         Finally, please note that the tranformation engine relies on a source trigger / router existing to supply the source data for the transformation.  The transform configuration will never be
         used if the source table and target node group does not have a defined trigger / router combination for that source table and target node group.
         </p>
        <div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="transform-data-tables"></a>4.8.1.&nbsp;Transform Configuration Tables</h3></div></div></div>
        
        <p>
        SymmetricDS stores its transformation configuration in two configuration tables,  <a href="data-model.html#table_transform_table" title="A.27.&nbsp;TRANSFORM_TABLE">TRANSFORM_TABLE</a> and  
        <a href="data-model.html#table_transform_column" title="A.28.&nbsp;TRANSFORM_COLUMN">TRANSFORM_COLUMN</a>.  Defining a transformation involves configuration in both tables, with the first table
        defining which source and destination tables are involved, and the second defining the columns involved in the transformation and the behavior of
        the data for those columns.  We will explain the various options available in both tables and the various pre-defined transformation types.
        </p>
        <p>
        To define a transformation, you will first define the source table and target table that applies to a particular transformation.  The source and target tables, along with
        a unique identifier (the transform_id column) are defined in <a href="data-model.html#table_transform_table" title="A.27.&nbsp;TRANSFORM_TABLE">TRANSFORM_TABLE</a>.  In addition, you will specify the 
        source_node_group_id and target_node_group_id to which the transform will apply, along with whether the transform should occur on the Extract step or the Load step (transform_point).
        All of these values are required.
        </p>
        
        <p>
        Three additional configuration settings are also defined at the source-target table level:  the order of the transformations, the behavior when deleting, and whether an update should
        always be attempted first.  More specifically, 
        </p><div class="itemizedlist"><ul type="disc"><li>transform_order:  For a single source operation that is mapped to a transformation,
         there could be more than one target operation that takes place.  You may control the order in which the target operations are applied
         through a configuration parameter defined for each source-target table combination.  This might be important, for example, if
         the foreign key relationships on the target tables require you to execute the transformations in a particular order.         
            </li><li>delete_action: When a source operation of Delete takes place, there are three possible ways to handle the transformation at the target.  The options include:
             <div class="itemizedlist"><ul type="circle"><li>
                NONE - The delete results in no target changes.
                </li><li>
                DEL_ROW - The delete results in a delete of the row as specified by the pk columns defined in the transformation configuration.
                </li><li>
                UPDATE_COL - The delete results in an Update operation on the target which updates the specific rows and columns based on the defined transformation.
                </li></ul></div>
            </li><li>update_first: This option overrides the default behavior for an Insert operation.  Instead of attempting the Insert first,
            SymmetricDS will always perform an Update first and then fall back to an Insert if that fails.  Note that, by default, fall back
            logic <span class="emphasis"><em>always</em></span> applies for Insert and Updates.  Here, all you a specifying is whether to always do an Update first, which
            can have performance benefits under certain situations you may run into.            
            </li></ul></div><p>
        </p>
        
         <p>
        For each transformation defined in <a href="data-model.html#table_transform_table" title="A.27.&nbsp;TRANSFORM_TABLE">TRANSFORM_TABLE</a>, the columns to be transformed (and how they are transformed) are defined
        in <a href="data-model.html#table_transform_column" title="A.28.&nbsp;TRANSFORM_COLUMN">TRANSFORM_COLUMN</a>.  This column-level table typically has several rows for each transformation id, each of which defines
        the source column name, the target column name, as well as the following details:
          </p><div class="itemizedlist"><ul type="disc"><li>
                include_on:  Defines whether this entry applies to source operations of Insert (I), Update (U), or Delete (D), or any source operation.
                </li><li>
                pk:  Indicates that this mapping is used to define the "primary key" for identifying the target row(s) (which may or may not be the true primary key of the target table).
                This is used to define the "where" clause when an Update or Delete on the target is occurring.  At least one row marked as a pk should be present for each transform_id.
                </li><li>
                transform_type, transform_expression:  Specifies how the data is modified, if at all.  The available transform types are discussed below, and the default is 'copy', which just copies the data
                from source to target.
                </li><li>
                transform_order: In the event there are more than one columns to transform, this defines the relative order in which the transformations are applied.
                </li></ul></div><p>
        </p>
        </div>
        
        <div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="transform-data-types"></a>4.8.2.&nbsp;Transformation Types</h3></div></div></div>
        
            <p> There are several pre-defined transform types available in SymmetricDS.  Additional ones can be defined by creating and configuring an
             extension point which implements the <code class="code">IColumnTransform</code> interface.  The pre-defined transform types include the following (the transform_type
             entry is shown in parentheses):
             </p><div class="itemizedlist"><ul type="disc"><li>
                    Copy Column Transform ('copy'):  This transformation type copies the source column value to the target column.  This is the default behavior.
                </li><li>
                    Constant Transform ('const'):  This transformation type allows you to map a constant value to the given target column.  The constant itself is placed in transform_expression.   
                </li><li>
                    Variable Transform ('variable'):  This transformation type allows you to map a built-in variable to the given target column.  The variable name is placed in transform_expression.
                    The following variables are available: <code class="code">system_date</code> is the current system date, and <code class="code">system_timestamp</code> is the current system date and time.
                </li><li>
                    Additive Transform ('additive'): This transformation type is used for numeric data.  It computes the change between the old and new values on the source
                    and then adds (or subtracts) the value from the existing value in the target column.  For example, if the source column changed from a 2 to a 4, and the target
                    column is currently 10, the effect of the transform will be to change the target column to a value of 12 ( 10+(4-2) =&gt; 12 ).
                </li><li>
                    Substring Transform ('substr'):  This transformation computes a substring of the source column data and uses the substring as the target column value.  The transform_expression can
                    be a single integer (<code class="code">n</code>, the beginning index), or a pair of comma-separated integers (<code class="code">n,m</code> - the beginning and ending index).  
                    The transform behaves as the Java substring function would using the specified values in transform_expression.
                </li><li>
                    Lookup Transform ('lookup'):  This transformation allows for the lookup of a column value from a single row using a SQL statement provided in the transform_expression.
                    The SQL statement can access the current source row using parameters with a name of the source column name in upper case prefixed by a colon.
                    For example, a SQL statement that looks up <code class="code">customer_id</code> from another table using the <code class="code">id</code> column of the current source row
                    is <code class="code">select customer_id from customers where group_id = :ID</code>.
                </li><li>
                    Multiplier Transform ('multiply'):  This transformation allows for the creation of multiple rows in the target table based on the transform_expression.  This transform type
                    can only be used on a primary key column.  The transform_expression is a SQL statement that returns the list to be used to create the multiple targets.
                </li><li>
                    Shell Script Transform ('bsh'):  This transformation allows you to provide a Bean Shell script in transform_expression and executes the script at the time of transformation.
                    Some variables are provided to the script: <code class="code">COLUMN_NAME</code> is a variable for a source column in the row, where the variable name is the column name in uppercase; 
                    <code class="code">currentValue</code> is the value of the current source column;
                    <code class="code">oldValue</code> is the old value of the source column for an updated row;
                    <code class="code">jdbcTemplate</code> is a Spring JdbcTemplate object for querying or updating the database.
                </li><li>
                    Variable Transform ('variable'):  This transformation allows you to place a dynamic variable (such as the current database time) into the target column.  The only transform_expression
                    value currently supported is <code class="code">system_timestamp</code>.
                 </li><li>
                    Identity Transform ('identity'):  This transformation allows you to insert into a identity column by computing a new identity, not copying the actual identity value from the source.
                 </li></ul></div><p>
            </p>
        </div>
        
        
    </div>
</div><div xmlns:fo="http://www.w3.org/1999/XSL/Format" class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="30%" align="left"><a accesskey="p" href="planning.html">Prev</a>&nbsp;</td><td width="40%" align="center"><a accesskey="h" href="user-guide.html">Home</a></td><td width="30%" align="right">&nbsp;<a accesskey="n" href="advanced-topics.html">Next</a></td></tr><tr><td width="30%" align="left" valign="top">Chapter&nbsp;3.&nbsp;Planning an Implementation&nbsp;</td><td width="40%" align="center"><span style="color:white;font-size:90%;"><a href="http://www.symmetricds.org/" title="SymmetricDS">SymmetricDS
                                        </a></span></td><td width="30%" align="right" valign="top">&nbsp;Chapter&nbsp;5.&nbsp;Advanced Topics</td></tr></table></div></body></html>