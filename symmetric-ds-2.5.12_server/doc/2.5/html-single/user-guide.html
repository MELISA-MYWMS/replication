<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>SymmetricDS 2 User Guide</title><link rel="stylesheet" href="css/docbook-style.css" type="text/css"><meta name="generator" content="DocBook XSL Stylesheets V1.72.0"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div xmlns:fo="http://www.w3.org/1999/XSL/Format" id="banner"><a style="border:none;" href="http://www.symmetricds.org/" title="SymmetricDS User Guide"><img style="border:none;" alt="SymmetricDS" src="images/banner-logo.gif"></a></div><div class="book" lang="en"><div class="titlepage"><div><div><h1 class="title"><a name="user-guide"></a>SymmetricDS 2 User Guide</h1></div><div><div xmlns:fo="http://www.w3.org/1999/XSL/Format" class="authorgroup"><h2>Authors</h2><p></p>
            <span class="author"><span class="firstname">Eric</span> <span class="surname">Long</span></span>
            , <span class="author"><span class="firstname">Chris</span> <span class="surname">Henson</span></span>
            , <span class="author"><span class="firstname">Mark</span> <span class="surname">Hanes</span></span>
            , <span class="author"><span class="firstname">Greg</span> <span class="surname">Wilmer</span></span>
        </div></div><div><p class="releaseinfo">
            v2.5
        </p></div><div><p class="copyright">Copyright &copy; 2007 - 2011 JumpMind, Inc</p></div><div><div class="legalnotice"><a name="d4e22"></a>
            <p>
                Permission to use, copy, modify, and distribute the SymmetricDS 2 User Guide Version
                2.5 for any purpose and without fee is hereby granted in perpetuity, provided that
                the above copyright notice and this paragraph appear in all copies.
            </p>
        </div></div></div><hr></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="preface"><a href="#d4e24">Preface</a></span></dt><dt><span class="chapter"><a href="#introduction">1. Introduction</a></span></dt><dd><dl><dt><span class="section"><a href="#definition">1.1. What is SymmetricDS?</a></span></dt><dt><span class="section"><a href="#background">1.2. Background</a></span></dt><dt><span class="section"><a href="#d4e57">1.3. SymmetricDS Features</a></span></dt><dd><dl><dt><span class="section"><a href="#notification">1.3.1. Notification Schemes</a></span></dt><dt><span class="section"><a href="#bi-sync">1.3.2. Two-Way Table Synchronization</a></span></dt><dt><span class="section"><a href="#data-channels">1.3.3. Data Channels</a></span></dt><dt><span class="section"><a href="#transactions">1.3.4. Transaction Awareness</a></span></dt><dt><span class="section"><a href="#plugins">1.3.5. Data Filtering and Rerouting</a></span></dt><dt><span class="section"><a href="#transports">1.3.6. HTTP(S) Transport</a></span></dt><dt><span class="section"><a href="#jmx">1.3.7. Remote Management</a></span></dt></dl></dd><dt><span class="section"><a href="#requirements">1.4. System Requirements</a></span></dt><dt><span class="section"><a href="#whats-new">1.5. What's new in SymmetricDS 2</a></span></dt></dl></dd><dt><span class="chapter"><a href="#tutorial">2. Hands-on Tutorial</a></span></dt><dd><dl><dt><span class="section"><a href="#tutorial-install">2.1. Installing SymmetricDS</a></span></dt><dt><span class="section"><a href="#ch02-create-database">2.2. Creating and Populating Your Databases</a></span></dt><dt><span class="section"><a href="#ch02-start-server">2.3. Starting SymmetricDS</a></span></dt><dt><span class="section"><a href="#ch02-register-node">2.4. Registering a Node</a></span></dt><dt><span class="section"><a href="#ch02-initial-load">2.5. Sending an Initial Load</a></span></dt><dt><span class="section"><a href="#ch02-pull">2.6. Pulling Data</a></span></dt><dt><span class="section"><a href="#ch02-push">2.7. Pushing Data</a></span></dt><dt><span class="section"><a href="#ch02-verify-outgoing">2.8. Verifying Outgoing Batches</a></span></dt><dt><span class="section"><a href="#ch02-verify-incoming">2.9. Verifying Incoming Batches</a></span></dt></dl></dd><dt><span class="chapter"><a href="#planning">3. Planning an Implementation</a></span></dt><dd><dl><dt><span class="section"><a href="#identifying-nodes">3.1. Identifying Nodes</a></span></dt><dt><span class="section"><a href="#organizing-nodes">3.2. Organizing Nodes</a></span></dt><dt><span class="section"><a href="#grouping-nodes">3.3. Defining Node Groups</a></span></dt><dt><span class="section"><a href="#linking-nodes">3.4. Linking Nodes</a></span></dt><dt><span class="section"><a href="#choosing-channels">3.5. Choosing Data Channels</a></span></dt><dt><span class="section"><a href="#defining-data-changes">3.6. Defining Data Changes to be Captured and Routed</a></span></dt><dd><dl><dt><span class="section"><a href="#defining-data-changes-triggers">3.6.1. Defining Triggers</a></span></dt><dt><span class="section"><a href="#defining-data-changes-routers">3.6.2. Defining Routers</a></span></dt><dt><span class="section"><a href="#defining-data-changes-trigger-routers">3.6.3. Mapping Triggers to Routers</a></span></dt><dd><dl><dt><span class="section"><a href="#defining-data-changes-trigger-routers-initial-load">3.6.3.1. Planning Initial Loads</a></span></dt><dt><span class="section"><a href="#defining-data-changes-trigger-routers-ping-back">3.6.3.2. Circular References and "Ping Back"</a></span></dt></dl></dd><dt><span class="section"><a href="#planning-registration">3.6.4. Planning for Registering Nodes</a></span></dt></dl></dd><dt><span class="section"><a href="#defining-transformation">3.7. Planning Data Transformations</a></span></dt></dl></dd><dt><span class="chapter"><a href="#configuration">4. Configuration</a></span></dt><dd><dl><dt><span class="section"><a href="#configuration-node-properties">4.1. Node Properties</a></span></dt><dt><span class="section"><a href="#configuration-node">4.2. Node</a></span></dt><dt><span class="section"><a href="#configuration-node-group">4.3. Node Group</a></span></dt><dt><span class="section"><a href="#configuration-node-group-link">4.4. Node Group Link</a></span></dt><dt><span class="section"><a href="#configuration-channel">4.5. Channel</a></span></dt><dt><span class="section"><a href="#configuration-triggers-and-routers">4.6. Triggers and Routers</a></span></dt><dd><dl><dt><span class="section"><a href="#configuration-trigger">4.6.1. Trigger</a></span></dt><dt><span class="section"><a href="#configuration-router">4.6.2. Router</a></span></dt><dd><dl><dt><span class="section"><a href="#configuration-default-router">4.6.2.1. Default Router</a></span></dt><dt><span class="section"><a href="#configuration-column-match-router">4.6.2.2. Column Match Router</a></span></dt><dt><span class="section"><a href="#configuration-lookup-table-router">4.6.2.3. Lookup Table Router</a></span></dt><dt><span class="section"><a href="#configuration-subselect-router">4.6.2.4. Subselect Router</a></span></dt><dt><span class="section"><a href="#configuration-scripted-router">4.6.2.5. Scripted Router</a></span></dt></dl></dd><dt><span class="section"><a href="#configuration-trigger-router">4.6.3. Trigger / Router Mappings</a></span></dt><dd><dl><dt><span class="section"><a href="#configuration-initial-load">4.6.3.1. Initial Load</a></span></dt><dt><span class="section"><a href="#configuration-dead-triggers">4.6.3.2. Dead Triggers</a></span></dt><dt><span class="section"><a href="#configuration-trigger-router-ping-back">4.6.3.3. Enabling "Ping Back"</a></span></dt></dl></dd></dl></dd><dt><span class="section"><a href="#configuration-registration">4.7. Opening Registration</a></span></dt><dt><span class="section"><a href="#transform-data">4.8. Transforming Data</a></span></dt><dd><dl><dt><span class="section"><a href="#transform-data-tables">4.8.1. Transform Configuration Tables</a></span></dt><dt><span class="section"><a href="#transform-data-types">4.8.2. Transformation Types</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#advanced-topics">5. Advanced Topics</a></span></dt><dd><dl><dt><span class="section"><a href="#advanced-sync">5.1. Advanced Synchronization</a></span></dt><dd><dl><dt><span class="section"><a href="#bi-direction-sync">5.1.1. Bi-Directional Synchronization</a></span></dt><dt><span class="section"><a href="#multi-tier">5.1.2. Multi-Tiered Synchronization</a></span></dt><dd><dl><dt><span class="section"><a href="#registration-redirect">5.1.2.1. Registration Redirect</a></span></dt></dl></dd></dl></dd><dt><span class="section"><a href="#jobs">5.2. Jobs</a></span></dt><dd><dl><dt><span class="section"><a href="#routing-job">5.2.1. Route Job</a></span></dt><dd><dl><dt><span class="section"><a href="#routing-job-overview">5.2.1.1. Overview</a></span></dt><dt><span class="section"><a href="#data-gaps">5.2.1.2. Data Gaps</a></span></dt></dl></dd><dt><span class="section"><a href="#controlling-synchronization">5.2.2. Controlling Synchronization Frequency</a></span></dt><dt><span class="section"><a href="#sync-triggers">5.2.3. Sync Triggers Job</a></span></dt></dl></dd><dt><span class="section"><a href="#jms-publishing">5.3. JMS Publishing</a></span></dt><dt><span class="section"><a href="#deployment-options">5.4. Deployment Options</a></span></dt><dd><dl><dt><span class="section"><a href="#deployment-options-web-archive">5.4.1. Web Archive</a></span></dt><dt><span class="section"><a href="#deployment-options-standalone">5.4.2. Standalone</a></span></dt><dt><span class="section"><a href="#deployment-options-embedded">5.4.3. Embedded</a></span></dt></dl></dd><dt><span class="section"><a href="#running-service">5.5. Running SymmetricDS as a Service</a></span></dt><dd><dl><dt><span class="section"><a href="#running-service-windows">5.5.1. Running as a Windows Service</a></span></dt><dt><span class="section"><a href="#running-service-unix">5.5.2. Running as a *nix Service</a></span></dt></dl></dd><dt><span class="section"><a href="#clustering">5.6. Clustering</a></span></dt><dt><span class="section"><a href="#encrypted-passwords">5.7. Encrypted Passwords</a></span></dt><dt><span class="section"><a href="#secure-transport">5.8. Secure Transport</a></span></dt><dd><dl><dt><span class="section"><a href="#secure-transport-sym">5.8.1. Sym Launcher</a></span></dt><dt><span class="section"><a href="#secure-transport-tomcat">5.8.2. Tomcat</a></span></dt><dt><span class="section"><a href="#secure-transport-keystore">5.8.3. Keystores</a></span></dt><dt><span class="section"><a href="#secure-transport-keys">5.8.4. Generating Keys</a></span></dt></dl></dd><dt><span class="section"><a href="#basic-auth">5.9. Basic Authentication</a></span></dt><dt><span class="section"><a href="#multi-server">5.10. Multi-Server Mode</a></span></dt></dl></dd><dt><span class="chapter"><a href="#extensions">6. Extending SymmetricDS</a></span></dt><dd><dl><dt><span class="section"><a href="#extensions-parameter-filter">6.1. IParameterFilter</a></span></dt><dt><span class="section"><a href="#extensions-data-loader-filter">6.2. IDataLoaderFilter</a></span></dt><dt><span class="section"><a href="#extensions-table-column-filter">6.3. ITableColumnFilter</a></span></dt><dt><span class="section"><a href="#extensions-batch-listener">6.4. IBatchListener</a></span></dt><dt><span class="section"><a href="#extensions-acknowledge-event-listener">6.5. IAcknowledgeEventListener</a></span></dt><dt><span class="section"><a href="#extensions-reload-listener">6.6. IReloadListener</a></span></dt><dt><span class="section"><a href="#extensions-extractor-filter">6.7. IExtractorFilter</a></span></dt><dt><span class="section"><a href="#extensions-sync-url-extension">6.8. ISyncUrlExtension</a></span></dt><dt><span class="section"><a href="#extensions-node-id-generator">6.9. INodeIdGenerator</a></span></dt><dt><span class="section"><a href="#extensions-trigger-creation-listener">6.10. ITriggerCreationListener</a></span></dt><dt><span class="section"><a href="#extensions-batch-algorithm">6.11. IBatchAlgorithm</a></span></dt><dt><span class="section"><a href="#extensions-data-router">6.12. IDataRouter</a></span></dt><dt><span class="section"><a href="#extensions-heartbeat-listener">6.13. IHeartbeatListener</a></span></dt><dt><span class="section"><a href="#extensions-offline-client-listener">6.14. IOfflineClientListener</a></span></dt><dt><span class="section"><a href="#extensions-offline-server-listener">6.15. IOfflineServerListener</a></span></dt><dt><span class="section"><a href="#extensions-node-password">6.16. INodePasswordFilter</a></span></dt></dl></dd><dt><span class="chapter"><a href="#administration">7. Administration</a></span></dt><dd><dl><dt><span class="section"><a href="#solving-synchronization-issues">7.1. Solving Synchronization Issues</a></span></dt><dd><dl><dt><span class="section"><a href="#solving-synchronization-issues-analysis">7.1.1. Analyzing the Issue</a></span></dt><dt><span class="section"><a href="#solving-synchronization-issues-resolution">7.1.2. Resolving the Issue</a></span></dt></dl></dd><dt><span class="section"><a href="#changing-triggers">7.2. Changing Triggers</a></span></dt><dt><span class="section"><a href="#resync-data">7.3. Re-synchronizing Data</a></span></dt><dt><span class="section"><a href="#changing-configuration">7.4. Changing Configuration</a></span></dt><dt><span class="section"><a href="#logging">7.5. Logging Configuration</a></span></dt><dt><span class="section"><a href="#admin-jmx">7.6. Java Management Extensions</a></span></dt><dt><span class="section"><a href="#temporary-files">7.7. Temporary Files</a></span></dt><dt><span class="section"><a href="#purge">7.8. Database Purging</a></span></dt></dl></dd><dt><span class="appendix"><a href="#data-model">A. Data Model</a></span></dt><dd><dl><dt><span class="section"><a href="#table_node">A.1. NODE</a></span></dt><dt><span class="section"><a href="#table_node_security">A.2. NODE_SECURITY</a></span></dt><dt><span class="section"><a href="#table_node_identity">A.3. NODE_IDENTITY</a></span></dt><dt><span class="section"><a href="#table_node_group">A.4. NODE_GROUP</a></span></dt><dt><span class="section"><a href="#table_node_group_link">A.5. NODE_GROUP_LINK</a></span></dt><dt><span class="section"><a href="#table_node_host">A.6. NODE_HOST</a></span></dt><dt><span class="section"><a href="#table_node_host_channel_stats">A.7. NODE_HOST_CHANNEL_STATS</a></span></dt><dt><span class="section"><a href="#table_node_host_stats">A.8. NODE_HOST_STATS</a></span></dt><dt><span class="section"><a href="#table_node_host_job_stats">A.9. NODE_HOST_JOB_STATS</a></span></dt><dt><span class="section"><a href="#table_channel">A.10. CHANNEL</a></span></dt><dt><span class="section"><a href="#table_node_channel_ctl">A.11. NODE_CHANNEL_CTL</a></span></dt><dt><span class="section"><a href="#table_node_group_channel_window">A.12. NODE_GROUP_CHANNEL_WINDOW</a></span></dt><dt><span class="section"><a href="#table_trigger">A.13. TRIGGER</a></span></dt><dt><span class="section"><a href="#table_router">A.14. ROUTER</a></span></dt><dt><span class="section"><a href="#table_trigger_router">A.15. TRIGGER_ROUTER</a></span></dt><dt><span class="section"><a href="#table_parameter">A.16. PARAMETER</a></span></dt><dt><span class="section"><a href="#table_registration_redirect">A.17. REGISTRATION_REDIRECT</a></span></dt><dt><span class="section"><a href="#table_registration_request">A.18. REGISTRATION_REQUEST</a></span></dt><dt><span class="section"><a href="#table_trigger_hist">A.19. TRIGGER_HIST</a></span></dt><dt><span class="section"><a href="#table_data">A.20. DATA</a></span></dt><dt><span class="section"><a href="#table_data_ref">A.21. DATA_REF</a></span></dt><dt><span class="section"><a href="#table_data_gap">A.22. DATA_GAP</a></span></dt><dt><span class="section"><a href="#table_data_event">A.23. DATA_EVENT</a></span></dt><dt><span class="section"><a href="#table_outgoing_batch">A.24. OUTGOING_BATCH</a></span></dt><dt><span class="section"><a href="#table_incoming_batch">A.25. INCOMING_BATCH</a></span></dt><dt><span class="section"><a href="#table_lock">A.26. LOCK</a></span></dt><dt><span class="section"><a href="#table_transform_table">A.27. TRANSFORM_TABLE</a></span></dt><dt><span class="section"><a href="#table_transform_column">A.28. TRANSFORM_COLUMN</a></span></dt></dl></dd><dt><span class="appendix"><a href="#parameters">B. Parameters</a></span></dt><dd><dl><dt><span class="section"><a href="#ap01-startup">B.1. Startup Parameters</a></span></dt><dt><span class="section"><a href="#ap01-runtime">B.2. Runtime Parameters</a></span></dt></dl></dd><dt><span class="appendix"><a href="#databases">C. Database Notes</a></span></dt><dd><dl><dt><span class="section"><a href="#ap02-oracle">C.1. Oracle</a></span></dt><dt><span class="section"><a href="#ap02-mysql">C.2. MySQL</a></span></dt><dt><span class="section"><a href="#ap02-postgresql">C.3. PostgreSQL</a></span></dt><dt><span class="section"><a href="#ap02-sql-server">C.4. MS SQL Server</a></span></dt><dt><span class="section"><a href="#ap02-hsqldb">C.5. HSQLDB</a></span></dt><dt><span class="section"><a href="#ap02-h2">C.6. H2</a></span></dt><dt><span class="section"><a href="#ap02-derby">C.7. Apache Derby</a></span></dt><dt><span class="section"><a href="#ap02-db2">C.8. IBM DB2</a></span></dt><dt><span class="section"><a href="#ap02-firebird">C.9. Firebird</a></span></dt><dt><span class="section"><a href="#ap02-informix">C.10. Informix</a></span></dt><dt><span class="section"><a href="#ap02-interbase">C.11. Interbase</a></span></dt></dl></dd><dt><span class="appendix"><a href="#data-format">D. Data Format</a></span></dt><dt><span class="appendix"><a href="#version-numbering">E. Version Numbering</a></span></dt></dl></div>
    
    <div class="preface" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="d4e24"></a>Preface</h2></div></div></div>
        
        <p>
            SymmetricDS is an open-source, web-enabled, database independent, data synchronization software application. It uses
            web and database technologies to replicate tables between relational databases in near
            real time. The software was designed to scale for a large number of databases, work
            across low-bandwidth connections, and withstand periods of network outages.
        </p>
        <p>
            This User Guide introduces SymmetricDS and its uses for data synchronization. It is
            intended for users who want to be quickly familiarized with the software, configure it,
            and use its many features.  This version of the guide was generated on 2012-05-01 at 20:48:53.
        </p>
        
    </div>

    <div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="introduction"></a>Chapter&nbsp;1.&nbsp;Introduction</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="#definition">1.1. What is SymmetricDS?</a></span></dt><dt><span class="section"><a href="#background">1.2. Background</a></span></dt><dt><span class="section"><a href="#d4e57">1.3. SymmetricDS Features</a></span></dt><dd><dl><dt><span class="section"><a href="#notification">1.3.1. Notification Schemes</a></span></dt><dt><span class="section"><a href="#bi-sync">1.3.2. Two-Way Table Synchronization</a></span></dt><dt><span class="section"><a href="#data-channels">1.3.3. Data Channels</a></span></dt><dt><span class="section"><a href="#transactions">1.3.4. Transaction Awareness</a></span></dt><dt><span class="section"><a href="#plugins">1.3.5. Data Filtering and Rerouting</a></span></dt><dt><span class="section"><a href="#transports">1.3.6. HTTP(S) Transport</a></span></dt><dt><span class="section"><a href="#jmx">1.3.7. Remote Management</a></span></dt></dl></dd><dt><span class="section"><a href="#requirements">1.4. System Requirements</a></span></dt><dt><span class="section"><a href="#whats-new">1.5. What's new in SymmetricDS 2</a></span></dt></dl></div>
    
    
        <p>This User Guide will introduce both basic and advanced concepts in the configuration
            of SymmetricDS. By the end of this chapter, you will have a better understanding of SymmetricDS' capabilities, and
            many of its basic concepts.</p>
        <div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="definition"></a>1.1.&nbsp;What is SymmetricDS?</h2></div></div></div>
            
            <p>SymmetricDS is an asynchronous data replication software package that supports multiple subscribers and
                bi-directional synchronization. It uses web and database technologies to replicate tables between relational
                databases, in near real time if desired. The software was designed to scale for a large number of databases, work across
                low-bandwidth connections, and withstand periods of network outage.  The software can be installed as a standalone process, as a web application in a Java application server, or it
                can be embedded into another Java application.</p>
            <p>
                A single installation of SymmetricDS attached to a target database
                is called a <span class="emphasis"><em>node</em></span>.
                A node is initialized by a properties file and is configured by inserting configuration data into a series of
                database tables. It then creates database triggers on the application tables to be synchronized so that database
                events are captured for delivery to other SymmetricDS nodes.
            </p>
            <p>
                In most databases, the transaction id is also captured by the database triggers so that the insert, update, and delete 
                events can be replicated transactionally via the transport layer to other nodes.  The transport layer is typically a CSV protocol over HTTP or HTTPS.
            </p>
            <p>
                SymmetricDS supports synchronization across different database platforms through the concept of <span class="emphasis"><em>Database
                Dialects</em></span>. A Database Dialect is an abstraction layer that SymmetricDS uses to insulate the main synchronization
                logic from database-specific implementation details.
            </p>
            <p>
            In addition to synchronization, SymmetricDS is also capable of performing fairly complex <span class="emphasis"><em>transformations</em></span> of
            data as the synchronization data is loaded into a target database.  The transformations can be used to merge source data,
            make multiple copies of source data across multiple target tables, set defaults in the target tables, etc.  The types of transformation
            can also be extended to create even more custom transformations. 
            </p>
            <p>
                SymmetricDS is extendable through extension points.  Extension points are custom, reusable Java code that are
                configured via XML.  Extension points hook into key points in the life-cycle of a synchronization to allow custom 
                behavior to be injected.  Extension points allow custom behavior such as: publishing data to other sources, transforming data,
                and taking different actions based on the content or status of a synchronization.
            </p>
        </div>
        <div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="background"></a>1.2.&nbsp;Background</h2></div></div></div>
            
            <p>The idea of SymmetricDS was born from a real-world need. Several of the original developers were, several years
                ago, implementing a commercial Point of Sale (POS) system for a large retailer. The development team came to the
                conclusion that the software available for trickling back transactions to corporate headquarters 
                (frequently known as the 'central office' or 'general office')
                did not meet the
                project needs. The list of project requirements made finding the ideal solution difficult:</p>
            <div class="itemizedlist"><ul type="disc"><li>
                    <p> Sending and receiving data with up to 2000 stores during peak holiday loads.</p>
                </li><li>
                    <p> Supporting one database platform at the store and a different one at the central office.</p>
                </li><li>
                    <p> Synchronizing some data in one direction, and other data in both directions.</p>
                </li><li>
                    <p> Filtering out sensitive data and re-routing it to a protected database.</p>
                </li><li>
                    <p> Preparing the store database with an initial load of data from the central office.</p>
                </li></ul></div>
            <p> The team ultimately created a custom solution that met the requirements and led to a successful project. From
                this work came the knowledge and experience that SymmetricDS benefits from today.</p>
        </div>
        <div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d4e57"></a>1.3.&nbsp;SymmetricDS Features</h2></div></div></div>
            
            <p>At a high level, SymmetricDS comes with a number of features that you are likely to need or want when doing data
                synchronization. A majority of these features were created as a direct result of real-world use of SymmetricDS in
                production settings.</p>
       
        <div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="notification"></a>1.3.1.&nbsp;Notification Schemes</h3></div></div></div>
            
            <p>
                After a change to the database is recorded, the SymmetricDS nodes interested in the change are notified. Change
                notification is configured to perform either a
                <span class="emphasis"><em>push</em></span>
                (trickle-back) or a
                <span class="emphasis"><em>pull</em></span>
                (trickle-poll) of data. When several nodes target their changes to a central node, it is efficient to push the
                changes instead of waiting for the central node to pull from each source node. If the network configuration protects
                a node with a firewall, a pull configuration could allow the node to receive data changes that might otherwise be
                blocked using push. The frequency of the change notification is configurable and defaults to once per minute.
            </p>
        </div>
        <div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="bi-sync"></a>1.3.2.&nbsp;Two-Way Table Synchronization</h3></div></div></div>
            
            <p> In practice, much of the data in a typical synchronization requires synchronization in just one direction.
                For example, a retail store sends its sales transactions to a
                central office, and the central office sends its stock items and pricing to the store. Other data may synchronize in both
                directions. For example, the retail store sends the central office an inventory document, and the central office
                updates the document status, which is then sent back to the store. SymmetricDS supports bi-directional or two-way table synchronization
                and avoids getting into update loops by only recording data changes outside of synchronization.</p>
        </div>
        <div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="data-channels"></a>1.3.3.&nbsp;Data Channels</h3></div></div></div>
            
            <p> SymmetricDS supports the concept of <span class="emphasis"><em>channels</em></span> of data.  
                Data synchronization is defined at the table (or table subset) level, and each managed table can be assigned to a
                <span class="emphasis"><em>channel</em></span> that helps control the flow of data. A channel is a category of data that can be enabled, prioritized and
                synchronized independently of other channels. For example, in a retail environment, users may be waiting for
                inventory documents to update while a promotional sale event updates a large number of items. If processed in
                order, the item updates would delay the inventory updates even though the data is unrelated. By assigning changes to the item
                tables to an <span class="emphasis"><em>item</em></span> channel and inventory tables' changes to an <span class="emphasis"><em>inventory</em></span> channel, the changes are
                processed independently so inventory can get through despite the large amount of item data.</p>  Channels are discussed
                in more detail in <a href="#choosing-channels" title="3.5.&nbsp;Choosing Data Channels">Section&nbsp;3.5, &#8220;Choosing Data Channels&#8221;</a>.
        </div>
        <div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="transactions"></a>1.3.4.&nbsp;Transaction Awareness</h3></div></div></div>
            
            <p> Many databases provide a unique transaction identifier associated with the rows that are committed together as a transaction.
                SymmetricDS stores the transaction identifier, along with the data that changed, so it can play back the transaction exactly
                as it occurred originally. This means the target database maintains the same transactional integrity as its source. Support for
                transaction identification for supported databases is documented in the appendix of this guide.</p>
        </div>
        <div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="plugins"></a>1.3.5.&nbsp;Data Filtering and Rerouting</h3></div></div></div>
            
            <p>
                Using SymmetricDS, data can be filtered as it is recorded, extracted, and loaded.
                </p><div class="itemizedlist"><ul type="disc"><li>
                        <p>
                            Data routing is accomplished by assigning a router type to a  <a href="#table_router" title="A.14.&nbsp;ROUTER">ROUTER</a> configuration.
                            Routers are responsible for identifying what target nodes captured changes should be delivered to.  Custom 
                            routers are possible by providing a class implementing <code class="literal">IDataRouter</code>. 
                        </p>
                    </li><li>
                        <p>
                            As data changes are loaded in the target database, a class implementing
                            <a href="#extensions-data-loader-filter" title="6.2.&nbsp;IDataLoaderFilter">IDataLoaderFilter</a>
                            can change the data in a column or route it somewhere else. One possible use might be to route credit
                            card data to a secure database and blank it out as it loads into a centralized sales database. The
                            filter can also prevent data from reaching the database altogether, effectively replacing the default
                            data loading process.
                        </p>
                    </li><li>
                        <p>
                            Columns can be excluded from synchronization so they are never recorded when the table is changed. As
                            data changes are loaded into the target database, a class implementing
                            <code class="literal">IColumnFilter</code>
                            can  remove a column altogether from the synchronization. For example, an employee table may be
                            synchronized to a retail store database, but the employee's password is only synchronized on the
                            initial insert.
                        </p>
                    </li><li>
                        <p>
                            As data changes are extracted from the source database, a class implementing the
                            <code class="literal">IExtractorListener</code>
                            interface is called to filter data or route it somewhere else. By default, SymmetricDS provides a
                            handler that transforms and streams data as CSV. Optionally, an alternate implementation may be
                            provided to take some other action on the extracted data.
                        </p>
                    </li></ul></div><p>
            </p>
        </div>
        <div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="transports"></a>1.3.6.&nbsp;HTTP(S) Transport</h3></div></div></div>
            
            <p>
                By default, SymmetricDS uses web-based HTTP or HTTPS in a style called Representation State Transfer (REST).  It is
                lightweight and easy to manage. A series of filters are also provided to enforce authentication and to restrict
                the number of simultaneous synchronization streams. The
                <code class="literal">ITransportManager</code>
                interface allows other transports to be implemented. 
            </p>
        </div>
        <div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="jmx"></a>1.3.7.&nbsp;Remote Management</h3></div></div></div>
            
            <p> Administration functions are exposed through Java Management Extensions (JMX) and can be accessed from the
                Java JConsole or through an application server. Functions include opening registration, reloading data, purging
                old data, and viewing batches. A number of configuration and runtime properties are available to be viewed as
                well.</p>
            <p> SymmetricDS also provides functionality to send SQL events through the same synchronization mechanism that is
                used to send data. The data payload can be any SQL statement. The event is processed and acknowledged just like
                any other event type.</p>
        </div>
    
     </div>
    <div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="requirements"></a>1.4.&nbsp;System Requirements</h2></div></div></div>
        
        <p> SymmetricDS is written in Java 5 and requires a Java SE Runtime Environment (JRE) or Java SE Development Kit (JDK)
            version 5.0 or above.</p>
        <p> Any database with trigger technology and a JDBC driver has the potential to run SymmetricDS. The database is
            abstracted through a <span class="emphasis"><em>Database Dialect</em></span> in order to support specific features of each database. The following Database
            Dialects have been included with this release:</p>
        <div class="itemizedlist"><ul type="disc"><li>
                <p>MySQL version 5.0.2 and above</p>
            </li><li>
                <p>Oracle version 8.1.7 and above</p>
            </li><li>
                <p>PostgreSQL version 8.2.5 and above</p>
            </li><li>
                <p>Sql Server 2005</p>
            </li><li>
                <p>HSQLDB 1.8</p>
            </li><li>
                <p>H2 1.x</p>
            </li><li>
                <p>Apache Derby 10.3.2.1 and above</p>
            </li><li>
                <p>IBM DB2 9.5</p>
            </li><li>
                <p>Firebird 2.0 and above</p>
            </li></ul></div>
        <p>
            See <a href="#databases" title="Appendix&nbsp;C.&nbsp;Database Notes">Appendix&nbsp;C, <i xmlns:xlink="http://www.w3.org/1999/xlink">Database Notes</i></a>,          
            for compatibility notes and other details for your specific database.
        </p>
    </div>
<div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="whats-new"></a>1.5.&nbsp;What's new in SymmetricDS 2</h2></div></div></div>
            
            <p> SymmetricDS 2 builds upon the existing SymmetricDS 1.x software base and incorporates a number of
                architectural changes and performance improvements. If you are brand new to SymmetricDS, you can safely skip this
                section. If you have used SymmetricDS 1.x in the past, this section summarizes the key differences you will
                encounter when moving to SymmetricDS 2.</p>
            <p>The first significant architectural change involves SymmetricDS's use of triggers. In 1.x, triggers capture and
                record data changes as well as the nodes to which the changes must be applied as row inserts into the <a href="#table_data_event" title="A.23.&nbsp;DATA_EVENT">DATA_EVENT</a>
                table. Thus, the number of row-inserts grows linearly with the number of client nodes. This can lead to an obvious
                performance issue as the number of nodes increases. In addition, the problem is made worse at times due to
                synchronizing nodes updating the same <a href="#table_data_event" title="A.23.&nbsp;DATA_EVENT">DATA_EVENT</a> table as part
                 of the batching process while the row-inserts are
                being created.</p>
            <p>In SymmetricDS 2, triggers capture <span class="emphasis"><em>only</em></span> data changes, not the node-specific details. The node-specific
                row-inserts are replaced with a new routing mechanism that does both the routing and the batching of data on one
                thread. Thus, the real-time inserts into <a href="#table_data_event" title="A.23.&nbsp;DATA_EVENT">DATA_EVENT</a> by applications using synchronized
                tables have been eliminated, and database performance is therefore improved. The database contention on <a href="#table_data_event" title="A.23.&nbsp;DATA_EVENT">DATA_EVENT</a>
                has also been eliminated, since the router job is the only thread inserting data into that table. 
                The only other access to the <a href="#table_data_event" title="A.23.&nbsp;DATA_EVENT">DATA_EVENT</a>
                table is from selects by synchronizing nodes.</p>
            <p>
                As a result of these changes, we gain the following benefits:
                </p><div class="itemizedlist"><ul type="disc"><li>Synchronizing client nodes will spend less time connected to a server node,</li><li>Applications updating database tables that are being synchronized to a large number of nodes will
                        not degrade in performance as more nodes are added, and</li><li> There should be almost no database contention on the <code class="literal">data_event</code> table, unlike the possible contention in 1.X.
                    </li></ul></div><p>
                Because routing no longer takes place in the SymmetricDS database triggers, a new mechanism for routing was needed. In
                SymmetricDS 1.x, the <code class="literal">node_select</code> expression was used for specifying the desired data routing. It was a SQL
                expression that qualified the insert into <a href="#table_data_event" title="A.23.&nbsp;DATA_EVENT">DATA_EVENT</a> from the SymmetricDS triggers. In SymmetricDS 2 there is a
                new extension point called the data router. Data routers are configured in the router table with a <code class="literal">router_type</code> and
                a <code class="literal">router_expression</code>. Several different routers have been provided to serve the majority of users' routing
                needs, but the framework is in place for a SymmetricDS programmer to develop domain- or application-specific
                routers.  See <a href="#configuration-router" title="4.6.2.&nbsp;Router">Section&nbsp;4.6.2, &#8220;Router&#8221;</a> for a complete list of provided routers.
            </p>
          
            <p>Since the routing and capturing of data are now performed with two separate mechanisms, the two concepts have
                been separated into separate configuration tables in the database, with a join table (<a href="#table_trigger_router" title="A.15.&nbsp;TRIGGER_ROUTER">TRIGGER_ROUTER</a>) specifying
                the relationships between routing (<a href="#table_router" title="A.14.&nbsp;ROUTER">ROUTER</a>) and capturing of data (<a href="#table_trigger" title="A.13.&nbsp;TRIGGER">TRIGGER</a>). This solves a long standing issue with
                some databases which only allow one trigger per table. On those database platforms, we can now route data in
                multiple directions since we only require one SymmetricDS trigger to capture data. This also helps performance in
                those scenarios, since we only capture the data once instead of once per routing instance.</p>
            <p>
                As part of the new routing job, we have introduced another new extension point to allow more flexibility in the
                way data events get batched. A batch is the unit by with captured data is sent and committed on target nodes. In
                SymmetricDS 2, batching is now configured on the channel configuration table. This provides additional flexibility
                for batching:
                </p><div class="itemizedlist"><ul type="disc"><li>Batching can have the traditional SymmetricDS 1.x behavior of batching up to a max batch size, but
                        never breaking on a database transaction boundary.</li><li>Batching can be completely tied to a database transaction. One batch per database transaction.
                    </li><li>Batching can ignore database transactions altogether and always batch based on a max batch size.
                    </li></ul></div><p>
            </p>
            <p> Another significant change to note in SymmetricDS 2 is the removal of the incoming and outgoing batch history
                tables. This change was made because it was found that over 95% of the time the statistics the end user truly
                wanted to see were those for the most recent synchronization attempt, not to mention that the outgoing batch
                history table was difficult to query. The most valuable information in the batch history tables, the batch
                statistics, have been moved over to the batch tables themselves. The statistics in the batch tables now always represent the
                latest synchronization attempt.</p>
        </div>
</div>
    <div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="tutorial"></a>Chapter&nbsp;2.&nbsp;Hands-on Tutorial</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="#tutorial-install">2.1. Installing SymmetricDS</a></span></dt><dt><span class="section"><a href="#ch02-create-database">2.2. Creating and Populating Your Databases</a></span></dt><dt><span class="section"><a href="#ch02-start-server">2.3. Starting SymmetricDS</a></span></dt><dt><span class="section"><a href="#ch02-register-node">2.4. Registering a Node</a></span></dt><dt><span class="section"><a href="#ch02-initial-load">2.5. Sending an Initial Load</a></span></dt><dt><span class="section"><a href="#ch02-pull">2.6. Pulling Data</a></span></dt><dt><span class="section"><a href="#ch02-push">2.7. Pushing Data</a></span></dt><dt><span class="section"><a href="#ch02-verify-outgoing">2.8. Verifying Outgoing Batches</a></span></dt><dt><span class="section"><a href="#ch02-verify-incoming">2.9. Verifying Incoming Batches</a></span></dt></dl></div>
    
    <p>Now that several of the features of SymmetricDS have been discussed, a quick working example of SymmetricDS is in order. 
        This section contains a hands-on tutorial that demonstrates how to synchronize a sample database between two running
        instances of SymmetricDS. This example models a retail business that has a central office database (called "root") and
        multiple retail store databases (called "client").  For the tutorial, we will have only one "client", as shown in <a href="#figure-tutorial" title="Figure&nbsp;2.1.&nbsp;Simplified Two Tiered Retail Store Tutorial Example">Figure&nbsp;2.1</a>.
        </p>
        
        <p>
                </p><div class="figure"><a name="figure-tutorial"></a><div class="figure-contents">
                    
                    <div class="mediaobject"><img src="images/tutorial-arch.gif" alt="Simplified Two Tiered Retail Store Tutorial Example"></div>
                </div><p class="title"><b>Figure&nbsp;2.1.&nbsp;Simplified Two Tiered Retail Store Tutorial Example</b></p></div><p><br class="figure-break">
            </p>     
         <p>
        
        The root SymmetricDS instance sends changes to the client for item data, such as
        item number, description, and price. The client SymmetricDS sends changes to the root for sale transaction data, such as time
        of sale and items sold. The sample configuration specifies synchronization with a pull method for the client to receive
        data from root, and a push method for the root to receive data from client.</p>
    <p>This tutorial will walk you through:
      </p><div class="procedure"><ol type="1"><li><p>Installing instances of SymmetricDS for the tutorial,</p></li><li><p>Creating separate databases for the root and client,</p></li><li><p>Creating sample tables for client and root and sample data for the root,</p></li><li><p>Starting SymmetricDS and registering the client with the root,</p></li><li><p>Sending an initial load to the client,</p></li><li><p>Causing a data push and data pull operation, and</p></li><li><p>Verifying information about the batches that were sent and received.</p></li></ol></div><p>
       </p>
    
     
     <div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="tutorial-install"></a>2.1.&nbsp;Installing SymmetricDS</h2></div></div></div>
        
        <p> First, we will install the SymmetricDS software and configure it with your database connection information:</p>
        <div class="procedure"><ol type="1"><li>
                <p>
                    Download the
                    <a xmlns:xlink="http://www.w3.org/1999/xlink" href="https://sourceforge.net/projects/symmetricds/files/" target="_top">symmetric-ds-2.x.x-server.zip</a>
                    file from
                    <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.symmetricds.org/" target="_top">http://www.symmetricds.org/</a>
                </p>
            </li><li>
                <p>
                    Unzip the file in any directory you choose. This will create a
                    <code class="filename">symmetric-ds-2.x.x-server</code>
                    subdirectory, which corresponds to the version you downloaded.
                </p>
            </li><li>
                <p>Edit the database properties in the following property files for the root (central office) and client (store) nodes:</p>
                <p>
                    </p><div class="itemizedlist"><ul type="disc" compact><li>
                            <p>
                                <code class="filename">samples/root.properties</code>
                            </p>
                        </li><li>
                            <p>
                                <code class="filename">samples/client.properties</code>
                            </p>
                        </li></ul></div><p>
                </p>
            </li><li>
                <p>
                    Set the following properties in
                    <span class="emphasis"><em>both</em></span>
                    files to specify how to connect to the database:
                </p>
                <pre class="programlisting"># The class name for the JDBC Driver
db.driver=com.mysql.jdbc.Driver

# The JDBC URL used to connect to the database
db.url=jdbc:mysql://localhost/sample

# The user to login as who can create and update tables
db.user=symmetric

# The password for the user to login as
db.password=secret</pre>
            </li><li>
                <p>
                    Next, set the following property in the
                    <code class="filename">client.properties</code>
                    file to specify where the root node can be contacted:
                </p>
                <pre class="programlisting"># The HTTP URL of the root node to contact for registration
registration.url=http://localhost:8080/sync</pre>
                <p> For the tutorial, the client database starts out empty, and the node is not registered. Registration is the
                    process where the node receives its configuration and stores it in its database. The configuration describes
                    which database tables to synchronize and to which nodes. When an unregistered node starts up, it will
                    register with the node specified by the registration URL. The registration node centrally controls nodes on
                    the network by allowing registration and returning configuration. In this tutorial, the registration node is
                    the root node, which also participates in synchronization with other nodes.</p>
            </li></ol></div>
    </div>
    <div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="ch02-create-database"></a>2.2.&nbsp;Creating and Populating Your Databases</h2></div></div></div>
        
        <div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Important</h3>
            <p> You must first create the databases for your root and client nodes using the administration tools provided by
                your database vendor. Make sure the name of the databases you create match the settings in the properties files.
            </p>
            <p>
                See
                 <a href="#databases" title="Appendix&nbsp;C.&nbsp;Database Notes">Appendix&nbsp;C, <i xmlns:xlink="http://www.w3.org/1999/xlink">Database Notes</i></a>,
                for compatibility with your specific database.
            </p>
        </div>
        <p>
            First, create the sample tables in the
            <span class="emphasis"><em>root</em></span>
            node database, load the sample data, and load the sample configuration.
        </p>
        <div class="procedure"><ol type="1"><li>
                <p>
                    Open a command prompt and navigate to the
                    <code class="filename">samples</code>
                    subdirectory of your SymmetricDS installation.
                </p>
            </li><li>
                <p>Create the sample tables in the root database by executing the following command:</p>
                <p>
                    <span><strong class="command">../bin/sym -p root.properties --run-ddl create_sample.xml</strong></span>
                </p>
                <p> Note that the warning messages from the command are safe to ignore.</p>
            </li><li>
                <p>Next, create the SymmetricDS tables in the root node database. These tables will contain the configuration for
                    synchronization. The following command uses the auto-creation feature to create all the necessary SymmetricDS
                    system tables.</p>
                <p>
                    <span><strong class="command">../bin/sym -p root.properties --auto-create</strong></span>
                </p>
            </li><li>
                <p>Finally, load the sample data and configuration into the root node database by executing:</p>
                <p>
                    <span><strong class="command">../bin/sym -p root.properties --run-sql insert_sample.sql</strong></span>
                </p>
            </li></ol></div>
        <p>
            We have now created the root database tables and populated them with sample data.  Next, we create the sample tables in the
            <span class="emphasis"><em>client</em></span>
            node database to prepare it for receiving data.
        </p>
        <div class="procedure"><ol type="1"><li>
                <p>
                    Open a command prompt and navigate to the
                    <code class="filename">samples</code>
                    subdirectory of your SymmetricDS installation.
                </p>
            </li><li>
                <p>Create the sample tables in the client database by executing:</p>
                <p>
                    <span><strong class="command"> ../bin/sym -p client.properties --run-ddl create_sample.xml</strong></span>
                </p>
                <p> Note that the warning messages from the command are safe to ignore.</p>
            </li></ol></div>
        <p>
            Please verify
            <span class="emphasis"><em>both</em></span>
            databases by logging in and listing the tables.
        </p>
        <div class="procedure"><ol type="1"><li>
                <p> Find the item tables that sync from root to client: item and item_selling_price.</p>
            </li><li>
                <p> Find the sales tables that sync from client to root: sale_transaction and sale_return_line_item.</p>
            </li><li>
                <p> Find the SymmetricDS system tables, which have a prefix of "sym_".</p>
            </li><li>
                <p>Validate the root item tables have sample data.</p>
            </li></ol></div>
    </div>
    <div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="ch02-start-server"></a>2.3.&nbsp;Starting SymmetricDS</h2></div></div></div>
        
        <p> Database setup and configuration for the tutorial is now complete.  Time to put SymmetricDS into action.
        We will now start both SymmetricDS nodes and observe the logging output.</p>
        <div class="procedure"><ol type="1"><li>
                <p>
                    Open a command prompt and navigate to the
                    <code class="filename">samples</code>
                    subdirectory of your SymmetricDS installation.
                </p>
            </li><li>
                <p>Start the root node server by executing:</p>
                <p>
                    <span><strong class="command">../bin/sym -p root.properties --port 8080 --server</strong></span>
                </p>
                <p> The root node server starts up and creates all the triggers that were configured by the sample
                    configuration. It listens on port 8080 for synchronization and registration requests.</p>
            </li><li>
                <p>Start the client node server by executing:</p>
                <p>
                    <span><strong class="command">../bin/sym -p client.properties --port 9090 --server</strong></span>
                </p>
                <p> The client node server starts up and uses the auto-creation feature to create the SymmetricDS system
                    tables. It begins polling the root node in order to register. Since registration is not yet open, the client
                    node receives an authorization failure (HTTP response of 403).</p>
            </li></ol></div>
        <div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Tip</h3>
            
            <p> If you want to change the port number used by SymmetricDS, you need to also set the sync.url runtime property to
                match. The default value is:</p>
            <pre class="programlisting">sync.url=http://localhost:8080/sync</pre>
        </div>
    </div>
    <div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="ch02-register-node"></a>2.4.&nbsp;Registering a Node</h2></div></div></div>
        
        <p> Next, we need to open registration for the client node so that it may receive its initial load of
         data and so that it may receive and send data from and to the root node. 
         There are several ways to do this.  We will use the administration feature on the root node.</p>
        <div class="procedure"><ol type="1"><li>
                <p>
                    Open a command prompt and navigate to the
                    <code class="filename">samples</code>
                    subdirectory of your SymmetricDS installation.
                </p>
            </li><li>
                <p>Open registration for the client node server by executing:</p>
                <p>
                    <span><strong class="command"> ../bin/sym -p root.properties --open-registration "store,1"</strong></span>
                </p>
                <p>
                    The registration is now opened for a node group called "store" with an external identifier of "1". This
                    information matches the settings in
                    <code class="filename">client.properties</code>
                    for the client node. Each node is assigned to a node group and is given an external ID that makes sense for the
                    application. In this tutorial, we have retail stores that run SymmetricDS, so we named our node group "store" and
                    we used numeric identifiers starting with "1".  More information about node groups will be covered in the next chapter.
                </p>
            </li><li>
                <p> Watch the logging output of the client node to see it successfully register with the root node. The client
                    is configured to attempt registration once per minute. Once registered, the root and client are enabled for
                    synchronization!</p>
            </li></ol></div>
    </div>
    <div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="ch02-initial-load"></a>2.5.&nbsp;Sending an Initial Load</h2></div></div></div>
        
        <p>Next, we will send an initial load of data to our store (that is, the client node), again using the root node administration feature.</p>
        <div class="procedure"><ol type="1"><li>
                <p>
                    Open a command prompt and navigate to the
                    <code class="filename">samples</code>
                    subdirectory of your SymmetricDS installation.
                </p>
            </li><li>
                <p>Send an initial load of data to the client node server by executing:</p>
                <p>
                    <span><strong class="command">../bin/sym -p root.properties --reload-node 1</strong></span>
                </p>
                <p> With this command, the root node queues up an initial load for the client node that will be sent the next
                    time the client performs its pull. The initial load includes data for each table that is configured for
                    synchronization.</p>
            </li><li>
                <p> Watch the logging output of both nodes to see the data transfer. The client is configured to pull data from
                    the root every minute.</p>
            </li></ol></div>
    </div>
    <div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="ch02-pull"></a>2.6.&nbsp;Pulling Data</h2></div></div></div>
        
        <p>Next, we will make a change to the item data in the central office (we'll add a new item), and observe the data being pulled down to
        the store.
        </p>
        <div class="procedure"><ol type="1"><li>
                <p>Open an interactive SQL session with the <span class="emphasis"><em>root</em></span> database.</p>
            </li><li>
                <p>Add a new item for sale:</p>
                <p>
                    <span><strong class="command"> insert into item_selling_price (price_id, price) values (55, 0.65);</strong></span>
                </p>
                <p>
                    <span><strong class="command"> insert into item (item_id, price_id, name) values (110000055, 55, 'Soft Drink');</strong></span>
                </p>
                <p> Once the statements are committed, the data change is captured by SymmetricDS and queued for the client node to pull.
                </p>
            </li><li>
                <p> Watch the logging output of both nodes to see the data transfer. The client is configured to pull data from
                    the root every minute.</p>
            </li><li>
                <p> Verify that the new data arrives in the client database using another interactive SQL session.</p>
            </li></ol></div>
    </div>
    <div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="ch02-push"></a>2.7.&nbsp;Pushing Data</h2></div></div></div>
        
        <p>We will now simulate a sale at the store and observe how SymmetricDS pushes the sale transaction to the central office.</p>
        <div class="procedure"><ol type="1"><li>
                <p>Open an interactive SQL session with the <span class="emphasis"><em>client</em></span> database.</p>
            </li><li>
                <p>Add a new sale to the client database:</p>
                <p>
                    <span><strong class="command"> insert into sale_transaction (tran_id, store, workstation, day, seq) values (1000, '1', '3',
                        '2007-11-01', 100);</strong></span>
                </p>
                <p>
                    <span><strong class="command"> insert into sale_return_line_item (tran_id, item_id, price, quantity) values (1000, 110000055, 0.65,
                        1);</strong></span>
                </p>
                <p> Once the statements are committed, the data change is captured and queued for the client node to push.
                </p>
            </li><li>
                <p> Watch the logging output of both nodes to see the data transfer. The client is configured to push data to
                    the root every minute.</p>
            </li></ol></div>
    </div>
    <div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="ch02-verify-outgoing"></a>2.8.&nbsp;Verifying Outgoing Batches</h2></div></div></div>
        
        <p>Now that we have pushed and pulled data, we will demonstrate how you can obtain information about what data has been batched and sent.
         A batch is used for tracking and sending data changes to nodes. The sending node creates a batch and the receiving
            node acknowledges it. A batch in error is retried during synchronization attempts, but only after data changes in
            other channels are allowed to be sent. Channels are categories assigned to tables for the purpose of independent
            synchronization and control. Batches for a channel are not created when a batch in the channel is in error status.
        </p>
        <div class="procedure"><ol type="1"><li>
                <p>Open an interactive SQL session with either the root or client database.</p>
            </li><li>
                <p> Verify that the data change you made was captured:</p>
                <p>
                    <span><strong class="command"> select * from sym_data order by data_id desc;</strong></span>
                </p>
                <p> Each row represents a row of data that was changed. The event_type is "I" for insert, "U" for update", or
                    "D" for delete. For insert and update, the captured data values are listed in row_data. For update and delete,
                    the primary key values are listed in pk_data.</p>
            </li><li>
                <p> Verify that the data change was routed to a node, using the data_id from the previous step:</p>
                <p>
                    <span><strong class="command"> select * from sym_data_event where data_id = ?;</strong></span>
                </p>
                <p> When the batched flag is set, the data change is assigned to a batch using a batch_id that is used to track
                    and synchronize the data. Batches are created and assigned during a push or pull synchronization.</p>
            </li><li>
                <p> Verify that the data change was batched, sent, and acknowledged, using the batch_id from the previous step:
                </p>
                <p>
                    <span><strong class="command"> select * from sym_outgoing_batch where batch_id = ?;</strong></span>
                </p>
                <p> A batch represents a collection of changes to be sent to a node. The batch is created during a push or pull
                    synchronization, when the status is set to "NE" for new. The receiving node acknowledges the batch with a
                    status of "OK" for success or "ER" for error.</p>
            </li></ol></div>
        <p>
        Understanding these three tables, along with a fourth table discussed in the next section, is key to diagnosing any synchronizaiton issues you might encounter.
        As you work with SymmetricDS, either when experimenting or starting to use SymmetricDS on your own data, spend time monitoring these tables to
        better understand how SymmetricDS works.
        </p>
    </div>
    <div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="ch02-verify-incoming"></a>2.9.&nbsp;Verifying Incoming Batches</h2></div></div></div>
        
        <p> The receiving node keeps track of the batches it acknowledges and records statistics about loading the data.
            Duplicate batches are skipped by default, but this behavior can be changed with the <code class="literal">incoming.batches.skip.duplicates</code>
            runtime property.</p>
        <div class="procedure"><ol type="1"><li>
                <p>Open an interactive SQL session with either the root or client database.</p>
            </li><li>
                <p> Verify that the batch was acknowledged, using a batch_id from the previous section:</p>
                <p>
                    <span><strong class="command"> select * from sym_incoming_batch where batch_id = ?;</strong></span>
                </p>
                <p> A batch represents a collection of changes loaded by the node. The sending node that created the batch is
                    recorded. The status is either "OK" for success or "ER" for error.</p>
            </li></ol></div>
    </div>
</div>
    <div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="planning"></a>Chapter&nbsp;3.&nbsp;Planning an Implementation</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="#identifying-nodes">3.1. Identifying Nodes</a></span></dt><dt><span class="section"><a href="#organizing-nodes">3.2. Organizing Nodes</a></span></dt><dt><span class="section"><a href="#grouping-nodes">3.3. Defining Node Groups</a></span></dt><dt><span class="section"><a href="#linking-nodes">3.4. Linking Nodes</a></span></dt><dt><span class="section"><a href="#choosing-channels">3.5. Choosing Data Channels</a></span></dt><dt><span class="section"><a href="#defining-data-changes">3.6. Defining Data Changes to be Captured and Routed</a></span></dt><dd><dl><dt><span class="section"><a href="#defining-data-changes-triggers">3.6.1. Defining Triggers</a></span></dt><dt><span class="section"><a href="#defining-data-changes-routers">3.6.2. Defining Routers</a></span></dt><dt><span class="section"><a href="#defining-data-changes-trigger-routers">3.6.3. Mapping Triggers to Routers</a></span></dt><dd><dl><dt><span class="section"><a href="#defining-data-changes-trigger-routers-initial-load">3.6.3.1. Planning Initial Loads</a></span></dt><dt><span class="section"><a href="#defining-data-changes-trigger-routers-ping-back">3.6.3.2. Circular References and "Ping Back"</a></span></dt></dl></dd><dt><span class="section"><a href="#planning-registration">3.6.4. Planning for Registering Nodes</a></span></dt></dl></dd><dt><span class="section"><a href="#defining-transformation">3.7. Planning Data Transformations</a></span></dt></dl></div>
    
    <p>
    In the previous Chapter we presented a high level introduction to some basic concepts
    in SymmetricDS, some of the high-level features, and a tutorial demonstrating a basic, working
    example of SymmetricDS in action.
    This chapter will focus on the key considerations and decisions one must make when planning a SymmetricDS implementation. 
    As needed, basic concepts will be reviewed or introduced throughout this Chapter.  By the
    end of the chapter you should be able to proceed forward and implement your planned design.  This Chapter
    will intentionally avoid discussing the underlying database tables that capture the configuration resulting
    from your analysis and design process.    
    Implementation of your design, along with discussion of the tables backing each concept, is covered in <a href="#configuration" title="Chapter&nbsp;4.&nbsp;Configuration">Chapter&nbsp;4, <i xmlns:xlink="http://www.w3.org/1999/xlink">Configuration</i></a>.
    </p>
    <p>
    When needed, we will rely on an example of a typical use of SymmetricDS in retail situations.  This
                example retail deployment of SymmetricDS might include many point-of-sale workstations located at stores that may have 
                intermittent network connection to a central location.  These workstations might have point-sale-software that uses a local
                relational database.  The database is populated with items, prices and tax information from a centralized
                database.  The point-of-sale software looks up item information from the local database and also saves 
                sale information to the same database.   The persisted sales need to be propagated back to the centralized database.  
               </p>
    
    
    <div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="identifying-nodes"></a>3.1.&nbsp;Identifying Nodes</h2></div></div></div>
    
    <p>
      A <span class="emphasis"><em>node</em></span> is a single instance of SymmetricDS. It can be thought of as a proxy for a database 
      which manages the synchronization of data to and/or from its database. 
      For our example retail application, the following would be SymmetricDS nodes:
                </p><div class="itemizedlist"><ul type="disc"><li>Each point-of-sale workstation.</li><li>The central office database server.</li></ul></div><p>
      Each node of SymmetricDS can be either embedded in another application, run stand-alone, or even run in the background as a service.  
      If desired, nodes can be clustered to help disperse load if they send and/or receive large volumes
      of data to or from a large number of nodes.
      </p>
      <p>
      Individual nodes are easy to identify when planning your implementation.  If a database
      exists in your domain that needs to send or receive data, there needs to be a corresponding
      SymmetricDS instance (a node) responsible for managing the synchronization for that database.
      
      </p>

      
    </div>
    <div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="organizing-nodes"></a>3.2.&nbsp;Organizing Nodes</h2></div></div></div>
            
            <p> Nodes in SymmetricDS are organized into an overall node network, with connections based on what data needs
            to be synchronized where.  The exact organization of your nodes will be very specific to your synchronization goals.
            As a starting point, lay out your nodes in diagram form and draw connections between nodes to represent cases in which 
            data is to flow in some manner.  Think in terms of what data is needed at which node, what data is in common to more than one node, etc.
            If it is helpful, you could also show data flow into and out of external systems.  As you will discover later,
            SymmetricDS can publish data changes from a node as well using JMS.
    </p>             
                
            <p>Our retail example, as shown in <a href="#figure-two-tier" title="Figure&nbsp;3.1.&nbsp;Two Tiered Retail Store Deployment Example">Figure&nbsp;3.1</a>, represents a tree hierarchy with a single central office node connected
            by lines to one or more children nodes (the POS workstations). Information flows from the central office node to an individual register
            and vice versa, but never flows between registers. </p>
            <p>
                </p><div class="figure"><a name="figure-two-tier"></a><div class="figure-contents">
                    
                    <div class="mediaobject"><img src="images/two-tier-arch.gif" alt="Two Tiered Retail Store Deployment Example"></div>
                </div><p class="title"><b>Figure&nbsp;3.1.&nbsp;Two Tiered Retail Store Deployment Example</b></p></div><p><br class="figure-break">
            </p>                
            <p>More complex organization can also be used. Consider, for example, if the same retail example is expanded to include 
              store <span class="emphasis"><em>servers</em></span> in each
              store to perform tasks such as opening the store for the day, reconciling registers, assigning employees, etc. 
              One approach to this new configuration would be to create a three-tier hierarchy (see  <a href="#figure-three-tier-store-server" title="Figure&nbsp;3.2.&nbsp;Three Tiered, In-Store Server, Retail Store Deployment Example">Figure&nbsp;3.2</a>).
              The highest tier, the centralized database, 
              connects with each store server's database. The store servers, in turn, communicate with the 
              individual point-of-sale workstations at the store. In this way data from each register could be accumulated at
              the store server, then sent on to the central office.  Similarly, data from the central office can be staged in the 
              store server and then sent on to each register, filtering the register's data based on which register it is.</p>                        
             <p>
                </p><div class="figure"><a name="figure-three-tier-store-server"></a><div class="figure-contents">
                    
                    <div class="mediaobject"><img src="images/three-tier-arch.gif" alt="Three Tiered, In-Store Server, Retail Store Deployment Example"></div>
                </div><p class="title"><b>Figure&nbsp;3.2.&nbsp;Three Tiered, In-Store Server, Retail Store Deployment Example</b></p></div><p><br class="figure-break">
            </p>    
        <p>One final example, show in <a href="#figure-three-tier-regional" title="Figure&nbsp;3.3.&nbsp;Three Tiered, Regional Server, Retail Store Deployment Example">Figure&nbsp;3.3</a>, again extending our original two-tier retail use case, would be to organize stores by "region" in the world.  
        This three tier architecture would introduce new regional servers (and corresponding regional databases)
        which would consolidate information specific to stores the regional server is responsible for.  The tiers in this case are
        therefore the central office server, regional servers, and individual store registers.         
        </p>
          <p>
                </p><div class="figure"><a name="figure-three-tier-regional"></a><div class="figure-contents">
                    
                    <div class="mediaobject"><img src="images/three-tier-regional-arch.gif" alt="Three Tiered, Regional Server, Retail Store Deployment Example"></div>
                </div><p class="title"><b>Figure&nbsp;3.3.&nbsp;Three Tiered, Regional Server, Retail Store Deployment Example</b></p></div><p><br class="figure-break">
            </p>    
        <p>
        These are just three common examples of how one might organize nodes in SymmetricDS.  While the examples above were for the retail industry, 
        the organization, they could apply to a variety of application domains.
        </p>
        </div>
        
     <div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="grouping-nodes"></a>3.3.&nbsp;Defining Node Groups</h2></div></div></div>
       
       <p>
         Once the organization of your SymmetricDS nodes has been chosen, you will need to <span class="emphasis"><em>group</em></span> your nodes
         based on which nodes share common functionality.  This is accomplished in SymmetricDS through the concept of a 
         <span class="emphasis"><em>Node Group</em></span>.  Frequently, an individual tier in your network will represent one Node Group. 
         Much of SymmetricDS' functionality is specified by Node Group and not an individual node. For example, when it comes 
         time to decide where to route data captured by SymmetricDS, the routing is configured by <span class="emphasis"><em>Node Group</em></span>. 
        </p> 
        <p>
        For the examples above, we might define Node Groups of:
                </p><div class="itemizedlist"><ul type="disc"><li>"workstation", to represent each point-of-sale workstation</li><li>"corp" or "central-office" to represent the centralized node.</li><li>"store" to represent the store server that interacts with store workstations and sends and
                        receives data from a central office server.</li><li>"region" to represent the a regional server that interacts with store workstations and sends and
                        receives data from a central office server.</li></ul></div><p>
                Considerable thought should be given to how you define the Node Groups.    Groups should be created for each set of nodes
                that synchronize common tables in a similar manner.  Also, give your Node Groups
                meaningful names, as they will appear in many, many places in your implementation of SymmetricDS.
          </p>
          <p>Note that there are other mechanisms in SymmetricDS to route to individual nodes 
                or smaller subsets of nodes within a Node Group, so do not choose Node Groups based on needing only subsets of data at
                specific nodes.
                For example, although you could, you would not want to create a Node Group
                for each store even though different tax rates need to be routed to each store.  
                Each store needs to synchronize the same tables
                to the same groups, so 'store' would be a good choice for a Node Group.
          </p>
     
     </div>
     
      <div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="linking-nodes"></a>3.4.&nbsp;Linking Nodes</h2></div></div></div>
       
       <p>
            Now that Node Groups have been chosen, the next step in planning is to document the individual links between
            Node Groups.  These <span class="emphasis"><em>Node Group Links</em></span> establish a source Node Group, a target Node Group, and a
            <span class="emphasis"><em>data event action</em></span>, namely whether the data changes are <span class="emphasis"><em>pushed</em></span> or <span class="emphasis"><em>pulled</em></span>.
               The push method causes the source Node Group to connect to the target, while a pull method
            causes it to wait for the target to connect to it.
        </p>
        <p>For our retail store example, there are two Node Group Links defined.  
        For the first link, the "store" Node Group pushes data to the "corp" central office Node Group.
        The second defines a "corp"
        to "store" link as a pull.  Thus, the store nodes will periodically pull data from the central office,
        but when it comes time to send data to the central office a store node will do a push.
        </p>
     </div>
     
       
     <div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="choosing-channels"></a>3.5.&nbsp;Choosing Data Channels</h2></div></div></div>
      
        <p>When SymmetricDS captures data changes in the database, the changes are captured in the 
        order in which they occur.  In addition, that order is preserved when synchronizing the 
        data to other nodes.
        Frequently, however, you will have cases where you have different "types" of data with
        differing priorities.  Some data might, for example, need priority for synchronization despite
        the normal order of events.   For example, in a retail environment, users may be waiting for
        inventory documents to update while a promotional sale event updates a large number of items.
        </p>
        <p>
           SymmetricDS supports this by allowing tables being synchronized to be grouped together into <span class="emphasis"><em>Channels</em></span> of data.
           A number of controls to the synchronization behavior of SymmetricDS are controlled at the Channel level.  For example,    
            Channels provide a processing order when synchronizing, a limit on the
            amount of data that will be batched together, and isolation from errors in other channels.  
            By categorizing data into channels and assigning them to <a href="#table_trigger" title="A.13.&nbsp;TRIGGER">TRIGGER</a>s, the user gains more control and visibility into
            the flow of data.  In addition, SymmetricDS allows for synchronization to be enabled, suspended, or scheduled by Channels as well.
            The frequency of synchronization can also be controlled at the channel level.
        </p>
 
        <p>
          Choosing Channels is fairly straightforward and can be changed over time, if needed.  Think about the
          differing "types" of data present in your application, the volume of data in the various types, etc.  What 
          data is considered must-have and can't be delayed due to a high volume load of another type of data?  For example,
          you might place employee-related data, such as clocking in or out, on one channel, but sales transactions on another.
          We will define which tables belong to which channels in the next sections.          
        </p>
        
        <div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Important</h3>
        <p>
            Be sure that, when defining Channels, all tables related by foreign keys are included in the same channel.
        </p>
    </div>    
    </div>  
       
    <div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="defining-data-changes"></a>3.6.&nbsp;Defining Data Changes to be Captured and Routed</h2></div></div></div>
      
      <p>
      At this point, you have designed the node-related aspects of your implementation, namely choosing nodes, grouping the nodes based on functionality, defining which node groups
      send and receive data to which others (and by what method).  You have defined data Channels based on the types and priority of data being synchronized.  The largest remaining
      task prior to starting your implementation is to define and document what data changes are to be captured (by defining SymmetricDS <span class="emphasis"><em>Triggers</em></span>), 
      and to decide to which node(s) the data changes are to be <span class="emphasis"><em>routed</em></span> to and under what conditions.  We will also, in this section, discuss the concept of
      an <span class="emphasis"><em>initial load</em></span> of data into a SymmetricDS node.        
      </p>
      <div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="defining-data-changes-triggers"></a>3.6.1.&nbsp;Defining Triggers</h3></div></div></div>
       
      
        <p> SymmetricDS uses <span class="emphasis"><em>database triggers</em></span> to capture and record changes to be synchronized to other nodes. Based on the configuration you provide, SymmetricDS
        creates the needed database triggers automatically for you.  There is a great deal of flexibility in terms of defining the exact conditions under which a data change is captured.
        SymmetricDS triggers are defined in a table named <a href="#table_trigger" title="A.13.&nbsp;TRIGGER">TRIGGER</a>.  Each trigger you define is for a particular table associated.  Each trigger can also specify:
           </p><div class="itemizedlist"><ul type="disc"><li>whether to install a trigger for updates, inserts, and/or deletes</li><li>conditions on which an insert, update, and/or delete fires</li><li>a list of columns that should not be synchronized from this table</li><li>a SQL select statement that can be used to hold data needed for routing (known as External Data)</li></ul></div><p>
        </p>
       <p>
       As you define your triggers, consider which data changes are relevant to your application and which ones ar not.  Consider under what special conditions
       you might want to route data, as well.  For our retail example, we likely want to have triggers defined for updating, inserting, and deleting pricing information
       in the central office so that the data can be routed down to the stores.  Similarly, we need triggers on sales transaction tables such that
       sales information can be sent back to the central office.
       </p>
       </div>
       
       <div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="defining-data-changes-routers"></a>3.6.2.&nbsp;Defining Routers</h3></div></div></div>
          
      
         <p>The triggers that have been defined in the previous section only define <span class="emphasis"><em>when</em></span> data changes are to be captured
         for synchronization.  They do not define <span class="emphasis"><em>where</em></span> the data changes are to be sent to.  Routers, plus a mapping between Triggers and Routers 
         (<a href="#table_trigger_router" title="A.15.&nbsp;TRIGGER_ROUTER">TRIGGER_ROUTER</a>),
         define the process for determining which nodes receive the data changes.
         </p>
         
         <p>Before we discuss Routers and Trigger Routers, we should probably take a break and discuss the process SymmetricDS uses to keep track
         of the changes and routing.  As we stated, SymmetricDS relies on auto-created database triggers to capture and record relevant data changes into a table, 
         the
          <a href="#table_data" title="A.20.&nbsp;DATA">DATA</a> table.  After the data is captured, a background process
            chooses the nodes that the data will be synchronized to.  This is called <span class="emphasis"><em>routing</em></span> and it is performed by the Routing Job.
            Note that the Routing Job does not actually send any data.  It just organizes and records the decisions on where to send data in a "staging"
            table called <a href="#table_data_event" title="A.23.&nbsp;DATA_EVENT">DATA_EVENT</a> and <a href="#table_outgoing_batch" title="A.24.&nbsp;OUTGOING_BATCH">OUTGOING_BATCH</a>.
        </p>
        <p> 
            Now we are ready to discuss Routers.  The router itself is what defines the configuration of where to send a data change.  Each Router
            you define can be associated with or assigned to any number of Triggers through a join table that defines the relationship.
            Routers are defined the SymmetricDS table named <a href="#table_router" title="A.14.&nbsp;ROUTER">ROUTER</a>.  For each router you define, you will need to specify:
            </p><div class="itemizedlist"><ul type="disc"><li>the target table on the destination node to route the data</li><li>the source node group and target node group for the nodes to route the data to</li><li>a router <span class="emphasis"><em>type</em></span> and router <span class="emphasis"><em>expression</em></span></li><li>whether to route updates, inserts, and/or deletes</li></ul></div><p>
             </p>
             <p>
             For now, do not worry about the specific routing types.  They will be covered later.  For your design simply make notes of the information needed
             and decisions to determine the list of nodes to route to.  You will find later that there is incredible flexibility and functionality available in routers.
             For example, you will find you can:
             
              </p><div class="itemizedlist"><ul type="disc"><li>send the changes to all nodes that belong to the target node group defined in the router.</li><li>compare old or new column values to a constant value or the value of a node's identity.</li><li>execute a SQL expression against the database to select nodes to
                        route to. This SQL expression can be passed values of old and new column values.</li><li>execute a Bean Shell expression in order to select nodes to route to.
                        The Bean Shell expression can use the the old and new column values.</li><li>publish data changes directly to a messaging solution instead
                        of transmitting changes to registered nodes.  (This router must be configured manually in XML as an extension point.)</li></ul></div><p>
             
        </p>
        <p>
        For each of your Triggers, decide which Router matches the behavior needed for that Trigger.  These Trigger Router combinations will be used to
        define a mapping between your Triggers and Routers when you implement your design.
        </p>
        </div>  
             
       
        <div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="defining-data-changes-trigger-routers"></a>3.6.3.&nbsp;Mapping Triggers to Routers</h3></div></div></div>
          
          
          <p>The mapping between Triggers and Routers, found in the table  <a href="#table_trigger_router" title="A.15.&nbsp;TRIGGER_ROUTER">TRIGGER_ROUTER</a>, 
          defines configuration specific to a particular Trigger and Router combination.</p>

            <div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="defining-data-changes-trigger-routers-initial-load"></a>3.6.3.1.&nbsp;Planning Initial Loads</h4></div></div></div>
                           
                  <p>SymmetricDS provides the ability to "load" or "seed" a node's database with specific sets of data from its parent node.  This concept is known as an <span class="emphasis"><em>Initial Load</em></span> of
                  data and is used to start off most synchronization scenarios.  The Trigger Router mapping defines how initial loads can occur, so now is a good time to plan how your <span class="emphasis"><em>Initial Loads</em></span> will work.
                  Using our retail example, consider a new store being opened.  Initially, you would like to pre-populate
                  a store database with all the item, pricing, and tax data for that specific store.  This is achieved through an initial load.  
                  A part of your planning, be sure to consider which tables, if any, will need to be loaded initially. SymmetricDS can also perform
                  an initial load on a table with just a subset of data.  Initial Loads are further discussed in <a href="#configuration-initial-load" title="4.6.3.1.&nbsp;Initial Load">Section&nbsp;4.6.3.1, &#8220;Initial Load&#8221;</a>.</p>
           </div>    
              
           <div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="defining-data-changes-trigger-routers-ping-back"></a>3.6.3.2.&nbsp;Circular References and "Ping Back"</h4></div></div></div>
                           
                  <p>
                  When routing data, SymmetricDS by default checks each data change and will not route a data change back to a node if it originated the change to begin with.  This prevents the possibility
                  of data changes resulting in an infinite loop of changes under certain circumstances.  You may find that, for some reason,
                  you need SymmetricDS to go ahead and send the data back to the originating node - a "ping back".  As part of the planning process, consider whether you have a special case for needing ping back.  
                  Ping Back control is further discussed in <a href="#configuration-trigger-router-ping-back" title="4.6.3.3.&nbsp;Enabling &#34;Ping Back&#34;">Section&nbsp;4.6.3.3, &#8220;Enabling "Ping Back"&#8221;</a>.
                  </p>     
          </div>               
      </div>
      <div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="planning-registration"></a>3.6.4.&nbsp;Planning for Registering Nodes</h3></div></div></div>
          
          <p>
          Our final step in planning an implementation of SymmetricDS involves deciding how a new node is connected to, or <span class="emphasis"><em>registered</em></span> with a parent node for the first time.
          </p>
          <p>
          The following are some options on ways you might register nodes:
              </p><div class="itemizedlist"><ul type="disc"><li>The tutorial uses the command line utility to register each individual node.</li><li>A JMX interface provides the same interface that the command line utility does.  JMX can be invoked programatically or via a web console.</li><li>Both the utility and the JMX method register a node by inserting into two tables.  A script can be written to directly register nodes by directly inserting into the database.</li><li>SymmetricDS can be configured to auto register nodes.  This means that any node that asks for a registration will be given one.</li></ul></div><p>
          </p>
    </div>
    </div>
    
    <div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="defining-transformation"></a>3.7.&nbsp;Planning Data Transformations</h2></div></div></div>
      
      <p>
      SymmetricDS also provides the abilty to <span class="emphasis"><em>transform</em></span> synchronized data instead of simply synchronizing it.  
      Your application might, for example require
      a particular column in your source data to be mapped to two different target tables with possibly different column names.  Or, you might
      need to "merge" one or more columns of data from two indepdentent tables into one table on the target. Or, you may want to
      set default column values on a target table based on a particular event on the source database. All of these operations, and many more,
      can be accomplished using SymmetricDS' transformation capabilities.   
      </p>
      <p>
      As you plan your SymmetricDS implementation, make notes of cases where a data transformation is needed.
      Include details such as when the transformation might occur (is it only on an insert, or a delete?), which tables or columns play a part, etc.  
      Complete details of all the transformation features, including how to configure a transformation, are discussed in <a href="#transform-data" title="4.8.&nbsp;Transforming Data">Section&nbsp;4.8, &#8220;Transforming Data&#8221;</a>.
      </p>
      </div>

    
 
</div>
    <div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="configuration"></a>Chapter&nbsp;4.&nbsp;Configuration</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="#configuration-node-properties">4.1. Node Properties</a></span></dt><dt><span class="section"><a href="#configuration-node">4.2. Node</a></span></dt><dt><span class="section"><a href="#configuration-node-group">4.3. Node Group</a></span></dt><dt><span class="section"><a href="#configuration-node-group-link">4.4. Node Group Link</a></span></dt><dt><span class="section"><a href="#configuration-channel">4.5. Channel</a></span></dt><dt><span class="section"><a href="#configuration-triggers-and-routers">4.6. Triggers and Routers</a></span></dt><dd><dl><dt><span class="section"><a href="#configuration-trigger">4.6.1. Trigger</a></span></dt><dt><span class="section"><a href="#configuration-router">4.6.2. Router</a></span></dt><dd><dl><dt><span class="section"><a href="#configuration-default-router">4.6.2.1. Default Router</a></span></dt><dt><span class="section"><a href="#configuration-column-match-router">4.6.2.2. Column Match Router</a></span></dt><dt><span class="section"><a href="#configuration-lookup-table-router">4.6.2.3. Lookup Table Router</a></span></dt><dt><span class="section"><a href="#configuration-subselect-router">4.6.2.4. Subselect Router</a></span></dt><dt><span class="section"><a href="#configuration-scripted-router">4.6.2.5. Scripted Router</a></span></dt></dl></dd><dt><span class="section"><a href="#configuration-trigger-router">4.6.3. Trigger / Router Mappings</a></span></dt><dd><dl><dt><span class="section"><a href="#configuration-initial-load">4.6.3.1. Initial Load</a></span></dt><dt><span class="section"><a href="#configuration-dead-triggers">4.6.3.2. Dead Triggers</a></span></dt><dt><span class="section"><a href="#configuration-trigger-router-ping-back">4.6.3.3. Enabling "Ping Back"</a></span></dt></dl></dd></dl></dd><dt><span class="section"><a href="#configuration-registration">4.7. Opening Registration</a></span></dt><dt><span class="section"><a href="#transform-data">4.8. Transforming Data</a></span></dt><dd><dl><dt><span class="section"><a href="#transform-data-tables">4.8.1. Transform Configuration Tables</a></span></dt><dt><span class="section"><a href="#transform-data-types">4.8.2. Transformation Types</a></span></dt></dl></dd></dl></div>
    
    <p>
    <a href="#planning" title="Chapter&nbsp;3.&nbsp;Planning an Implementation">Chapter&nbsp;3</a> introduced numerous concepts and the analysis and design needed to create an implementation of SymmetricDS.
    This chapter re-visits each analysis step and documents how to turn a SymmetricDS design into reality through configuration of
    the various SymmetricDS tables.  In addition, several advanced configuration options, not presented previously, will also be covered.
     </p>
    
    <div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="configuration-node-properties"></a>4.1.&nbsp;Node Properties</h2></div></div></div>
    
    <p>
        To get a SymmetricDS node running, it needs to be given an identity and it needs to know how
        to connect to the database it will be synchronizing.  A typical way to specify this is to place properties
        in the <code class="filename">symmetric.properties</code> file.  When started up, SymmetricDS reads the configuration
        and state from the database.  If the configuration tables are missing, they are created
        automatically (auto creation can be disabled).  Basic configuration is described by inserting into the following tables (the complete 
        data model is defined in <a href="#data-model" title="Appendix&nbsp;A.&nbsp;Data Model">Appendix&nbsp;A, <i xmlns:xlink="http://www.w3.org/1999/xlink">Data Model</i></a>).
            </p><div class="itemizedlist"><ul type="disc"><li>
                    <p><a href="#table_node_group" title="A.4.&nbsp;NODE_GROUP">NODE_GROUP</a> - specifies the tiers that exist in a SymmetricDS network</p>
                </li><li>
                    <p><a href="#table_node_group_link" title="A.5.&nbsp;NODE_GROUP_LINK">NODE_GROUP_LINK</a> - links two node groups together for synchronization</p>
                </li><li>
                    <p><a href="#table_channel" title="A.10.&nbsp;CHANNEL">CHANNEL</a> - grouping and priority of synchronizations</p>
                </li><li>
                    <p><a href="#table_trigger" title="A.13.&nbsp;TRIGGER">TRIGGER</a> - specifies tables, channels, and conditions for which changes in the database should be captured</p>
                </li><li>
                    <p><a href="#table_router" title="A.14.&nbsp;ROUTER">ROUTER</a> - specifies the routers defined for synchronization, along with other routing details</p>
                </li><li>
                    <p><a href="#table_trigger_router" title="A.15.&nbsp;TRIGGER_ROUTER">TRIGGER_ROUTER</a> - provides mappings of routers and triggers</p>
                </li></ul></div><p>
        </p>
        <p>
        During start up, triggers are verified against the database, and database triggers
        are installed on tables that require data changes to be captured.  The Route, Pull and Push Jobs
        begin running to synchronize changes with other nodes.
      </p>
        <p>
            Each node requires properties that allow it to connect to a database and register
            with a parent node.  To give a node its identity, the following properties are used:
        </p>
        <div class="variablelist"><dl><dt><span class="term">
                    <span><strong class="command">group.id</strong></span>
                </span></dt><dd>
                    <p>
                        The node group that this node is a member of. Synchronization is specified
                        between node groups, which means you only need to specify it once for
                        multiple nodes in the same group. 
                    </p>
                </dd><dt><span class="term">
                    <span><strong class="command">external.id</strong></span>
                </span></dt><dd>
                    <p>
                        The external id for this node has meaning to the user and provides
                        integration into the system where it is deployed. For example, it might be a
                        retail store number or a region number. The external id can be used in
                        expressions for conditional and subset data synchronization. Behind the
                        scenes, each node has a unique sequence number for tracking synchronization
                        events. That makes it possible to assign the same external id to multiple
                        nodes, if desired.
                    </p>
                </dd><dt><span class="term">
                    <span><strong class="command">sync.url</strong></span>
                </span></dt><dd>
                    <p>
                        The URL where this node can be contacted for synchronization.
                        At startup and during each heartbeat, the node updates its entry in
                        the database with this URL.  
                    </p>
                </dd></dl></div>
        <p>
            When a new node is first started, it is has no information about synchronizing. It
            contacts the registration server in order to join the network and receive its
            configuration. The configuration for all nodes is stored on the registration server, and
            the URL must be specified in the following property:
        </p>
        <div class="variablelist"><dl><dt><span class="term">
                    <span><strong class="command">registration.url</strong></span>
                </span></dt><dd>
                    <p>
                        The URL where this node can connect for registration to receive its
                        configuration. The registration server is part of SymmetricDS and is enabled
                        as part of the deployment.
                    </p>
                </dd></dl></div>
        <div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Important</h3><p>
        Note that a <span class="emphasis"><em>registration server node</em></span> is defined as one whose <code class="literal">registration.url</code> is either (a) blank, or (b)
        identical to its <code class="literal">sync.url</code>.</p></div>
        <p>
            When deploying to an application server, it is common for database connection pools
            to be found in the Java naming directory (JNDI).  In this case, set the following property:
        </p>
        <div class="variablelist"><dl><dt><span class="term">
                    <span><strong class="command">db.jndi.name</strong></span>
                </span></dt><dd>
                    <p>
                        The name of the database connection pool to use, which is registered in the JNDI
                        directory tree of the application server. It is recommended that this DataSource is
                        NOT transactional, because SymmetricDS will handle its own transactions.
                    </p>
                </dd></dl></div>
        <p>
            For a deployment where the database connection pool should be created using a JDBC driver,
            set the following properties:
        </p>
        <div class="variablelist"><dl><dt><span class="term">
                    <span><strong class="command">db.driver</strong></span>
                </span></dt><dd>
                    <p>
                        The class name of the JDBC driver.
                    </p>
                </dd><dt><span class="term">
                    <span><strong class="command">db.url</strong></span>
                </span></dt><dd>
                    <p>
                        The JDBC URL used to connect to the database.
                    </p> 
                </dd><dt><span class="term">
                    <span><strong class="command">db.user</strong></span>
                </span></dt><dd>
                    <p>
                        The database username, which is used to login, create, and update SymmetricDS tables.
                    </p>
                </dd><dt><span class="term">
                    <span><strong class="command">db.password</strong></span>
                </span></dt><dd>
                    <p>
                        The password for the database user.
                    </p>
                </dd></dl></div>
       
      
    </div>
    
     <div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="configuration-node"></a>4.2.&nbsp;Node</h2></div></div></div>
            
            <p>
                A <span class="emphasis"><em>node</em></span>, a single instance of SymmetricDS, is defined in the  <a href="#table_node" title="A.1.&nbsp;NODE">NODE</a> table.
                Two other tables play a direct role
            in defining a node, as well  The first is <a href="#table_node_identity" title="A.3.&nbsp;NODE_IDENTITY">NODE_IDENTITY</a>. The <span class="emphasis"><em>only</em></span> row in this table
            is inserted in the database when the node first <span class="emphasis"><em>registers</em></span> with a parent node.  In the case 
            of a root node, the row is entered by the user.  The row is used by a node instance to determine its node identity.
            </p>
            <p>
            The following SQL statements set up a top-level registration server as a node identified
            as "00000" in the "corp" node group.
            
            </p><pre class="programlisting">
insert into SYM_NODE 
  (node_id, node_group_id, external_id, sync_enabled)
values
  ('00000', 'corp', '00000', 1);

insert into SYM_NODE_IDENTITY values ('00000');</pre><p>
        </p>
        <p>
        The second table, <a href="#table_node_security" title="A.2.&nbsp;NODE_SECURITY">NODE_SECURITY</a> has rows
        created for each <span class="emphasis"><em>child</em></span> node that registers with the node, assuming auto-registration is enabled.
        If auto registration is not enabled, you must create a row in <a href="#table_node" title="A.1.&nbsp;NODE">NODE</a> 
        and <a href="#table_node_security" title="A.2.&nbsp;NODE_SECURITY">NODE_SECURITY</a> for the node to be able to register.  You can also, with this table,
        manually cause a node to re-register or do a re-initial load by setting the corresponding
        columns in the table itself.  Registration is discussed in more detail in
        <a href="#configuration-registration" title="4.7.&nbsp;Opening Registration">Section&nbsp;4.7, &#8220;Opening Registration&#8221;</a>.
        </p>
    </div>
   
    <div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="configuration-node-group"></a>4.3.&nbsp;Node Group</h2></div></div></div>
        
        <p>
        Node Groups are straightforward to configure and are defined in the <a href="#table_node_group" title="A.4.&nbsp;NODE_GROUP">NODE_GROUP</a> table.    
            The following SQL statements would create node groups for "corp" and "store" based on our retail store example. 

            </p><pre class="programlisting">
insert into SYM_NODE_GROUP 
  (node_group_id, description)
values
  ('store', 'A retail store node');

insert into SYM_NODE_GROUP 
  (node_group_id, description)
values
  ('corp', 'A corporate node');</pre><p>
        </p>
    </div>
    <div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="configuration-node-group-link"></a>4.4.&nbsp;Node Group Link</h2></div></div></div>
        
         <p>
           Similarly, Node Group links are established using a data event action of 'P' for Push and 'W' for Pull ("wait").
            The following SQL statements links the "corp" and "store" node groups for synchronization.
            It configures the "store" nodes to push their data changes to the "corp" nodes,
            and the "corp" nodes to send changes to "store" nodes by waiting for a pull.
            
            </p><pre class="programlisting">
insert into SYM_NODE_GROUP_LINK
  (source_node_group, target_node_group, data_event_action)
values
  ('store', 'corp', 'P');

insert into SYM_NODE_GROUP_LINK
  (source_node_group, target_node_group, data_event_action)
values
  ('corp', 'store', 'W');</pre><p>
        </p>
    </div>
   
    <div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="configuration-channel"></a>4.5.&nbsp;Channel</h2></div></div></div>
        
        <p>
            By categorizing data into channels and assigning them to <a href="#table_trigger" title="A.13.&nbsp;TRIGGER">TRIGGER</a>s, the user gains more control and visibility into
            the flow of data.  In addition, SymmetricDS allows for synchronization to be enabled, suspended, or scheduled by channels as well. 
            The frequency of synchronization and order that data gets synchronized is also controlled at the channel level.
        </p>
        <p>
            The following SQL statements setup channels for a retail store.  An "item" channel includes
            data for items and their prices, while a "sale_transaction" channel includes data for ringing
            sales at a register. 
            
            </p><pre class="programlisting">
insert into SYM_CHANNEL 
  (channel_id, processing_order, max_batch_size, max_batch_to_send, 
   extract_period_millis, batch_algorithm, enabled, description)
values
  ('item', 10, 1000, 10,  0, 'default', 1, 'Item and pricing data');

insert into SYM_CHANNEL 
  (channel_id, processing_order, max_batch_size, max_batch_to_send, 
   extract_period_millis, batch_algorithm, enabled, description)
values
  ('sale_transaction', 1, 1000, 10,  60000, 'transactional', 1, 
   'retail sale transactions from register');</pre><p>
        </p>
        <p>
            Batching is the grouping of data, by channel, to be transferred and committed at 
            the client together.  There are three different out-of-the-box batching algorithms which 
            may be configured in the batch_algorithm column on channel.  
         </p><div class="variablelist"><dl><dt><span class="term">
                    <span><strong class="command">default</strong></span>
                </span></dt><dd>
                    <p>
                        All changes that happen in a transaction are guaranteed to be batched 
                        together.  Multiple transactions will be batched and committed together
                        until there is no more data to be sent or the max_batch_size is reached.
                    </p>
                </dd><dt><span class="term">
                    <span><strong class="command">transactional</strong></span>
                </span></dt><dd>
                    <p>
                        Batches will map directly to database transactions.  If there are many
                        small database transactions, then there will be many batches.  The max_batch_size
                        column has no effect.
                    </p> 
                </dd><dt><span class="term">
                    <span><strong class="command">nontransactional</strong></span>
                </span></dt><dd>
                    <p>
                        Multiple transactions will be batched and committed together
                        until there is no more data to be sent or the max_batch_size is reached.  
                        The batch will be cut off at the max_batch_size regardless of whether
                        it is in the middle of a transaction. 
                    </p>
                </dd></dl></div><p>
        </p>
        <p>
        There are also several size-related parameters that can be set by channel.  They include:
         </p><div class="variablelist"><dl><dt><span class="term">
                    <span><strong class="command">max_batch_size</strong></span>
                </span></dt><dd>
                    <p>
                       Specifies the maximum number of data events to process within a batch for this channel.
                    </p>
                </dd><dt><span class="term">
                    <span><strong class="command">max_batch_to_send</strong></span>
                </span></dt><dd>
                    <p>
                        Specifies the maximum number of batches to send for a given channel during a 'synchronization' between two nodes.
                        A 'synchronization' is equivalent to a push or a pull.
                        For example, if there are 12 batches ready to be sent for a channel and max_batch_to_send is equal to 10,
                        then only the first 10 batches will be sent even though 12 batches are ready.
                        </p>
                </dd><dt><span class="term">
                    <span><strong class="command">max_data_to_route</strong></span>
                </span></dt><dd>
                    <p>
                        Specifices the maximum number of data rows to route for a channel at a time.
                     </p>
                </dd></dl></div><p>
        </p>
        <p>
        Based on your particular synchronization requirements, you can also specify whether old, new, and primary key data should be read and included during routing for a given channel.  These are controlled by
        the columns use_old_data_to_route, use_row_data_to_route, and use_pk_data_to_route, respectively.  By default, they are all 1 (true).
        </p>
        <p>
        Finally, if data on a particular channel contains big lobs, you can set the column  contains_big_lob to 1 (true) to provide SymmetricDS the hint that the channel contains big lobs.  
        Some databases have shortcuts that SymmetricDS can take advantage of if it knows that the lob columns in <a href="#table_data" title="A.20.&nbsp;DATA">DATA</a>
         aren't going to contain large lobs.  The definition of how large a 'big' lob is varies from database to database.
        </p>
    </div>
       
    <div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="configuration-triggers-and-routers"></a>4.6.&nbsp;Triggers and Routers</h2></div></div></div>
                 
            
    <div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="configuration-trigger"></a>4.6.1.&nbsp;Trigger</h3></div></div></div>
        
        <p>
            SymmetricDS captures synchronization data using database triggers. SymmetricDS' Triggers are defined in the 
              <a href="#table_trigger" title="A.13.&nbsp;TRIGGER">TRIGGER</a> table.  
            Each record is used by SymmetricDS when generating database triggers.  Database triggers are only generated when a trigger 
            is associated with a <a href="#table_router" title="A.14.&nbsp;ROUTER">ROUTER</a> whose <code class="literal">source_node_group_id</code> matches the node group id of the current node.
        </p>
        <p>
        When determining whether a data change has occurred or not, by defalt the triggers will
        record a change even if the data was updated to the same value(s) they were originally.
        For example, a data change will be captured if an update of one column in a row
        updated the value to the same value it already was.
        There is a global property, <code class="literal">trigger.update.capture.changed.data.only.enabled</code> (false by default),
        that allows you to override this behavior. When set to true, SymmetricDS will only capture a change if
        the data has truly changed (i.e., when the new column data is not equal to the old column data).
        </p>
        <div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Important</h3>
        The property <code class="literal">trigger.update.capture.changed.data.only.enabled</code> 
        is currently only supported in the MySQL and Oracle dialects.
        </div>
        
        <p>
            The following SQL statement defines a trigger that will capture data for a table named "item"
            whenever data is inserted, updated, or deleted. The trigger is assigned to a channel also called 'item'.            
            </p><pre class="programlisting">
insert into SYM_TRIGGER 
    (trigger_id,source_table_name,channel_id,last_update_time,create_time)
  values
    ('item', 'item', 'item', current_timestamp, current_timestamp);
</pre><p>
        </p>
        
        <p>
        Two lobs-related settings are also available on  <a href="#table_trigger" title="A.13.&nbsp;TRIGGER">TRIGGER</a>:
        
       </p><div class="variablelist"><dl><dt><span class="term">
                <span><strong class="command">use_stream_lobs</strong></span>
            </span></dt><dd>
                <p>
                    Specifies whether to capture lob data as the trigger is firing or to stream lob columns from the source tables using callbacks during extraction.
                    A value of 1 indicates to stream from the source via callback; a value of 0, lob data is captured by the trigger.
               </p>
            </dd><dt><span class="term">
                <span><strong class="command">use_capture_lobs</strong></span>
            </span></dt><dd>
                <p>
                 Provides a hint as to whether this trigger will capture big lobs data.  If set to 1 every effort will be made during data capture in trigger and during data selection for initial load 
                 to use lob facilities to extract and store data in the database.
                </p>
            </dd></dl></div><p>
        </p>
            
        <div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Important</h3>
        <p>
            Note that many databases allow for multiple triggers of the same type to be defined.  
            Each database defines the order in which the triggers fire differently.  If you have
            additional triggers beyond those SymmetricDS installs on your table, please consult
            your database documentation to determine if there will be issues with
            the ordering of the triggers.
        </p>
    </div>
    </div>
    <div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="configuration-router"></a>4.6.2.&nbsp;Router</h3></div></div></div>
        
      <p>
                Routers provided in the base implementation currently include:
                </p><div class="itemizedlist"><ul type="disc"><li>Default Router - a router that sends all data to all nodes that belong to the target node group defined in the router.</li><li>Column Match Router - a router that compares old or new column values to a constant value or the
                        value of a node's external_id or node_id.</li><li>Lookup Router - a router which can be configured to determine routing based on an existing or ancillary table specifically for the
                    purpose of routing data.        
                    </li><li>Subselect Router - a router that executes a SQL expression against the database to select nodes to
                        route to. This SQL expression can be passed values of old and new column values.</li><li>Scripted Router - a router that executes a Bean Shell script expression in order to select nodes to route to.
                        The script can use the the old and new column values.</li><li>Xml Publishing Router - a router the publishes data changes directly to a messaging solution instead
                        of transmitting changes to registered nodes.  This router must be configured manually in XML as an extension point.</li></ul></div><p>
                The mapping between the set of triggers and set of routers is many-to-many.  This means that one trigger can capture changes and route
                to multiple locations.  It also means that one router can be defined an associated with many different triggers.
            </p>
    
    
    <div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="configuration-default-router"></a>4.6.2.1.&nbsp;Default Router</h4></div></div></div>
        
        <p>
            The simplest router is a router that sends all the data that is captured by its 
            associated triggers to all the nodes that belong to the target node group defined
            in the router.  A router is defined as a row in the <a href="#table_router" title="A.14.&nbsp;ROUTER">ROUTER</a> table.
            It is then linked to triggers in the <a href="#table_trigger_router" title="A.15.&nbsp;TRIGGER_ROUTER">TRIGGER_ROUTER</a> table.  
        </p>
        <p>
            The following SQL statement defines a router that will send data from the 'corp' group to the 'store' group.            
            </p><pre class="programlisting">
insert into SYM_ROUTER 
  (router_id, source_node_group_id, target_node_group_id, 
    create_time, last_update_time)
values
  ('corp-2-store','corp', 'store', current_timestamp, current_timestamp);

</pre><p>
        </p>
        <p>
            The following SQL statement maps the 'corp-2-store' router to the item trigger.            
            </p><pre class="programlisting">
insert into SYM_TRIGGER_ROUTER 
  (trigger_id, router_id, initial_load_order,  create_time, last_update_time)
values
  ('item', 'corp-2-store', 1, current_timestamp, current_timestamp);

</pre><p>
        </p>        
    </div>
   
    <div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="configuration-column-match-router"></a>4.6.2.2.&nbsp;Column Match Router</h4></div></div></div>
        
        <p>
            Sometimes requirements may exist that require data to be routed based on the current value or the old value of a 
            column in the table that is being routed.  Column routers are configured by setting the <code class="literal">router_type</code> column on the 
              <a href="#table_router" title="A.14.&nbsp;ROUTER">ROUTER</a> table
            to <code class="literal">column</code> and setting the <code class="literal">router_expression</code> column to an equality expression that represents
            the expected value of the column.
        </p>
        <p>             
            The first part of the expression is always the column name.  The column name should always be defined in upper case.
            The upper case column name prefixed by OLD_ can be used for a comparison being done with the old column data value.
        </p>
        <p>
            The second part of the expression can be a constant value, a token that represents another column, or a token
            that represents some other SymmetricDS concept.  Token values always begin with a colon (:).
        </p>                  
        <p>
            Consider a table that needs to be routed to all nodes in the target group only when a status column is set to 'OK.'  The following 
            SQL statement will insert a column router to accomplish that.            
            </p><pre class="programlisting">
insert into SYM_ROUTER 
(router_id, source_node_group_id, target_node_group_id, router_type, 
 router_expression, create_time, last_update_time)
values
('corp-2-store-ok','corp', 'store', 'column', 
 'STATUS=OK', current_timestamp, current_timestamp);

</pre><p>
         </p>            
        <p>
            Consider a table that needs to be routed to all nodes in the target group only when a status column changes values.  The following 
            SQL statement will insert a column router to accomplish that.  Note the use of OLD_STATUS, where the OLD_ prefix gives access to the old column value.          
            </p><pre class="programlisting">
insert into SYM_ROUTER 
  (router_id, source_node_group_id, target_node_group_id, router_type, 
    router_expression, create_time, last_update_time)
values
  ('corp-2-store-status','corp', 'store', 'column', 
    'STATUS!=:OLD_STATUS', current_timestamp, current_timestamp);

</pre><p>
         </p>            
        <p>
            Consider a table that needs to be routed to only nodes in the target group whose STORE_ID column matches the external id of a node.  The following 
            SQL statement will insert a column router to accomplish that.            
            </p><pre class="programlisting">
insert into SYM_ROUTER 
  (router_id, source_node_group_id, target_node_group_id, router_type, 
    router_expression, create_time, last_update_time)
values
  ('corp-2-store-id','corp', 'store', 'column', 
    'STORE_ID=:EXTERNAL_ID', current_timestamp, current_timestamp);

</pre><p>
            Attributes on a <a href="#table_node" title="A.1.&nbsp;NODE">NODE</a> that can be referenced with tokens include:
            </p><div class="itemizedlist"><ul type="disc"><li>NODE_ID</li><li>EXTERNAL_ID</li><li>NODE_GROUP_ID</li></ul></div><p>
        </p>   
        <p>
            Consider a table that needs to be routed to a redirect node defined by its external id in the <a href="#table_registration_redirect" title="A.17.&nbsp;REGISTRATION_REDIRECT">REGISTRATION_REDIRECT</a> table.  The following 
            SQL statement will insert a column router to accomplish that.            
            </p><pre class="programlisting">
insert into SYM_ROUTER 
  (router_id, source_node_group_id, target_node_group_id, router_type, 
    router_expression, create_time, last_update_time)
values
  ('corp-2-store-redirect','corp', 'store', 'column', 
    'STORE_ID=:REDIRECT_NODE', current_timestamp, current_timestamp);
</pre><p>                        
         </p>
         <p>
            More than one column may be configured in a router_expression.  When more than one column is configured, all matches are added to the list of nodes to route to.  The following is
            an example where the STORE_ID column may contain the STORE_ID to route to or the constant of ALL which indicates that all nodes should receive the update.       
            </p><pre class="programlisting">
insert into SYM_ROUTER 
  (router_id, source_node_group_id, target_node_group_id, router_type, 
    router_expression, create_time, last_update_time)
values
  ('corp-2-store-multiple-matches','corp', 'store', 'column', 
   'STORE_ID=ALL or STORE_ID=:EXTERNAL_ID', current_timestamp, current_timestamp);
</pre><p>                        
         </p>    
         <p>
         The NULL keyword may be used to check if a column is null.  If the column is null, then data will be routed to all nodes who qualify for the update.  This following is an example 
         where the STORE_ID column is used to route to a set of nodes who have a STORE_ID equal to their EXTERNAL_ID, or to all nodes if the STORE_ID is null.
          </p><pre class="programlisting">
insert into SYM_ROUTER 
  (router_id, source_node_group_id, target_node_group_id, router_type, 
    router_expression, create_time, last_update_time)
values
  ('corp-2-store-multiple-matches','corp', 'store', 'column', 
   'STORE_ID=NULL or STORE_ID=:EXTERNAL_ID', current_timestamp, current_timestamp);
</pre><p>    
         </p>                    
    </div>    
    
    <div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="configuration-lookup-table-router"></a>4.6.2.3.&nbsp;Lookup Table Router</h4></div></div></div>
        
        <p>
            A lookup table may contain the id of the node where data needs to be routed.  This could be an existing table or an ancillary table that is added
            specifically for the purpose of routing data.  Lookup table routers are configured by setting the <code class="literal">router_type</code> column on the 
              <a href="#table_router" title="A.14.&nbsp;ROUTER">ROUTER</a> table
            to <code class="literal">lookuptable</code> and setting a list of configuration parameters in the <code class="literal">router_expression</code> column.
        </p>
        <p>     
            Each of the following configuration parameters are required.          
            </p><div class="variablelist"><dl><dt><span class="term">
                        <span><strong class="command">LOOKUP_TABLE</strong></span>
                    </span></dt><dd>
                        <p>
                        This is the name of the lookup table.
                        </p>
                    </dd><dt><span class="term">
                        <span><strong class="command">KEY_COLUMN</strong></span>
                    </span></dt><dd>
                        <p>
                        This is the name of the column on the table that is being routed.  It will be used as a key into the lookup table.
                        </p>
                    </dd><dt><span class="term">
                        <span><strong class="command">LOOKUP_KEY_COLUMN</strong></span>
                    </span></dt><dd>
                        <p>
                        This is the name of the column that is the key on the lookup table.
                        </p>
                    </dd><dt><span class="term">
                        <span><strong class="command">EXTERNAL_ID_COLUMN</strong></span>
                    </span></dt><dd>
                        <p>
                        This is the name of the column that contains the external_id of the node to route to on the lookup table.
                        </p>
                    </dd></dl></div><p>
        </p>
        <p>
            Note that the lookup table will be read into memory and cached for the duration of a routing pass for a single channel.
        </p>                  
        <p>
            Consider a table that needs to be routed to a specific store, but the data in the changing table only contains brand information.  In this case,
            the STORE table may be used as a lookup table.            
            </p><pre class="programlisting">
insert into SYM_ROUTER 
(router_id, source_node_group_id, target_node_group_id, router_type, 
 router_expression, create_time, last_update_time)
values
('corp-2-store-ok','corp', 'store', 'lookuptable', 
 'LOOKUP_TABLE=STORE
KEY_COLUMN=BRAND_ID
LOOKUP_KEY_COLUMN=BRAND_ID
EXTERNAL_ID_COLUMN=STORE_ID', current_timestamp, current_timestamp);

</pre><p>
         </p>            
     </div>

    <div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="configuration-subselect-router"></a>4.6.2.4.&nbsp;Subselect Router</h4></div></div></div>
        
        <p>
            Sometimes routing decisions need to be made based on data that is not in the current row being synchronized.  Consider an 
            example where an Order table and a OrderLineItem table need to be routed to a specific store.  The Order table has a column 
            named order_id and STORE_ID.  A store node has an external_id that is equal to the STORE_ID on the Order table.  OrderLineItem, 
            however, only has a foreign key to its Order of order_id.  To route OrderLineItems to the same nodes that the Order will be routed
            to, we need to reference the master Order record.
        </p>
        <p>             
            There are two possible ways to route the OrderLineItem in SymmetricDS.  One is to configure a 'subselect' router_type on the <a href="#table_router" title="A.14.&nbsp;ROUTER">ROUTER</a> table
            and the other is to configure an external_select on the <a href="#table_trigger" title="A.13.&nbsp;TRIGGER">TRIGGER</a> table. 
        </p>
        <p>
            A 'subselect' is configured with a router_expression that is a SQL select statement which returns a result set of the node_ids that need routed to.  Column tokens can
            be used in the SQL expression and will be replaced with row column data.  The overhead of using this router type is high because the 'subselect' statement runs for each row 
            that is routed.  It should not be used for tables that have a lot of rows that are updated.  It also has the disadvantage that if the Order master record is deleted, 
            then no results would be returned and routing would not happen.  The router_expression is appended to the following
            SQL statement in order to select the node ids.
            </p><pre class="programlisting">

select c.node_id from sym_node c where 
  c.node_group_id=:NODE_GROUP_ID and c.sync_enabled=1 and 
</pre><p>  
        </p>                  
        <p>
            Consider a table that needs to be routed to all nodes in the target group only when a status column is set to 'OK.'  The following 
            SQL statement will insert a column router to accomplish that.            
            </p><pre class="programlisting">
insert into SYM_ROUTER 
  (router_id, source_node_group_id, target_node_group_id, router_type, 
    router_expression, create_time, last_update_time)
values
  ('corp-2-store','corp', 'store', 'subselect', 
    'c.external_id in (select STORE_ID from order where order_id=:ORDER_ID)', 
    current_timestamp, current_timestamp);
</pre><p>
         </p>            
        <p>
            Alternatively, when using an external_select on the <a href="#table_trigger" title="A.13.&nbsp;TRIGGER">TRIGGER</a> table, data is captured in the EXTERNAL_DATA column of the <a href="#table_data" title="A.20.&nbsp;DATA">DATA</a> table at the time a trigger 
            fires.  The EXTERNAL_DATA can then be used for routing by using a router_type of 'column'.  The advantage of this approach is that it is very unlikely that the master Order table
            will have been deleted at the time any DML accures on the OrderLineItem table.  It also is a bit more effcient than the 'subselect' approach, although the triggers produced do run 
            the extra external_select inline with application database updates.  
        </p>            
        <p>
            In the following example, the STORE_ID is captured from the Order table in the EXTERNAL_DATA column.  EXTERNAL_DATA is always available for routing as a virtual column in a 'column'
            router.  The router is configured to route based on the captured EXTERNAL_DATA to all nodes whose external_id matches.  Note that other supported node attribute tokens can also be 
            used for routing.      
            </p><pre class="programlisting">

insert into SYM_TRIGGER 
  (trigger_id,source_table_name,channel_id,external_select,
    last_update_time,create_time)
values
  ('orderlineitem', 'orderlineitem', 'orderlineitem','select STORE_ID 
    from order where order_id=$(curTriggerValue).$(curColumnPrefix)order_id',
    current_timestamp, current_timestamp);

insert into SYM_ROUTER 
  (router_id, source_node_group_id, target_node_group_id, router_type, 
    router_expression, create_time, last_update_time)
values
  ('corp-2-store-ext','corp', 'store', 'column', 
    'EXTERNAL_DATA=:EXTERNAL_ID', current_timestamp, current_timestamp);
</pre><p>
         </p>   
         <p>
         Note the syntax $(curTriggerValue).$(curColumnPrefix).  This translates into "OLD_" or "NEW_" based on the DML type being run.  In the case of Insert or Update, it's NEW_.  For Delete, it's OLD_ (since there is no
         new data).  In this way, you can access the DML-appropriate value for your select statement.
         </p>         
    </div>  
    
    <div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="configuration-scripted-router"></a>4.6.2.5.&nbsp;Scripted Router</h4></div></div></div>
        
        <p>
            When more flexibility is needed in the logic to choose the nodes to route to, then the a scripted router may be used.  The currently available scripting language is Bean Shell. Bean Shell is a Java-like scripting language.  Documentation 
            for the Bean Shell scripting language can be found at <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.beanshell.org/" target="_top">http://www.beanshell.org</a>. 
        </p>
        <p>
            The router_type for a Bean Shell scripted router is 'bsh'.  The router_expression is a valid Bean Shell script that:
            </p><div class="itemizedlist"><ul type="disc"><li>adds node ids to the 'targetNodes' collection which is bound to the script</li><li>returns a new collection of node ids</li><li>returns a single node id</li><li>returns true to indicate that all nodes should be routed or returns false to indicate that no nodes should be routed</li></ul></div><p>                          
            Also bound to the script evaluation is a list of 'nodes'.  The list of 'nodes' is 
            a list of eligible Node objects.  The current data column values and the old data column values are bound to the script evaluation as Java object representations of the column data. 
            The columns are bound using the uppercase names of the columns.  Old values are bound to uppercase representations that are prefixed with 'OLD_'. 
        </p>        
        <p>
            In the following example, the node_id is a combination of STORE_ID and WORKSTATION_NUMBER, both of which are columns on the table that is being routed.
            </p><pre class="programlisting">

insert into SYM_ROUTER 
  (router_id, source_node_group_id, target_node_group_id, router_type, 
    router_expression, create_time, last_update_time)
values
  ('corp-2-store-bsh','corp', 'store', 'bsh', 
    'targetNodes.add(STORE_ID + "-" + WORKSTATION_NUMBER);', 
    current_timestamp, current_timestamp);
</pre><p>
        </p>
        <p>
            The same could also be accomplished by simply returning the node id.  The last line of a bsh script is always the return value.
            </p><pre class="programlisting">

insert into SYM_ROUTER 
  (router_id, source_node_group_id, target_node_group_id, router_type, 
    router_expression, create_time, last_update_time)
values
  ('corp-2-store-bsh','corp', 'store', 'bsh', 
    'STORE_ID + "-" + WORKSTATION_NUMBER', 
    current_timestamp, current_timestamp);
</pre><p>
         </p>     
         <p>
            The following example will synchronize to all nodes if the FLAG column has changed, otherwise
            no nodes will be synchronized.  Note that here we make use of OLD_, which provides access to the old column value.
            </p><pre class="programlisting">

insert into SYM_ROUTER 
  (router_id, source_node_group_id, target_node_group_id, router_type, 
    router_expression, create_time, last_update_time)
values
  ('corp-2-store-flag-changed','corp', 'store', 'bsh', 
    'FLAG != null &amp;&amp; !FLAG.equals(OLD_FLAG)', 
    current_timestamp, current_timestamp);
</pre><p>
        </p>   
    </div>  
    </div>
     <div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="configuration-trigger-router"></a>4.6.3.&nbsp;Trigger / Router Mappings</h3></div></div></div>
        
        <p>
        Two important controls can be configured for a specific Trigger / Router combination: Initial Load and Ping Back.
         The parameters for these can be found in the Trigger / Router mapping table,
        <a href="#table_trigger_router" title="A.15.&nbsp;TRIGGER_ROUTER">TRIGGER_ROUTER</a>.
        </p>
       
        <div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="configuration-initial-load"></a>4.6.3.1.&nbsp;Initial Load</h4></div></div></div>
        
        <p>
            An initial load is the process of seeding tables at a target node with data from its parent node.
            When a node connects and data is extracted, after it is registered and if an initial load was requested, each table that is configured to synchronize to the target node
              group will be given a reload event in the order defined by the end user.  A SQL statement is run against each table to get the data load that will be streamed to the target node.  
              The selected data is filtered through the configured router for the table being loaded.  If the data set is going to be large, then SQL criteria can optionally be provided to pair 
              down the data that is selected out of the database.
            </p>
            <p>
            An initial load can not occur until after a node is registered.  An initial load is 
            requested by setting the <code class="literal">initial_load_enabled</code> column on <a href="#table_node_security" title="A.2.&nbsp;NODE_SECURITY">NODE_SECURITY</a> to
            <span class="emphasis"><em>1</em></span> on the row for the target node in the parent node's database.  The next time the 
            target node synchronizes, reload batches will be inserted.  At the same time reload batches 
            are inserted, all previously pending batches for the node are marked as successfully sent.    
        </p>
         <div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Important</h3>
            <p>
            Note that if the parent node that a node is registering with is <span class="emphasis"><em>not</em></span> a registration server node 
            (as can happen with a registration redirect or certain non-tree structure node configurations)
            the parent node's <a href="#table_node_security" title="A.2.&nbsp;NODE_SECURITY">NODE_SECURITY</a> entry must exist at the parent node and have a non-null value for
            column <code class="literal">initial_load_time</code>.  Nodes can't be registered to non-registration-server nodes without this value being set one way or another (i.e.,
            manually, or as a result of an initial load occuring at the parent node).
            </p>
        </div>   
        <p>
            SymmetricDS recognizes that an initial load has completed when the <code class="literal">initial_load_time</code> column on the
            target node is set to a non-null value.
        </p>
        <p>
            An initial load is accomplished by inserting reload batches in a defined order according to the <code class="literal">initial_load_order</code> column on
            <a href="#table_trigger_router" title="A.15.&nbsp;TRIGGER_ROUTER">TRIGGER_ROUTER</a>.  Initial load data is always queried from the 
            source database table.  All data is passed through the configured router to filter out data that 
            might not be targeted at a node.  
        </p>
        <p>    
            An efficient way to select a subset of data from a table for an initial load is to provide an
            <code class="literal">initial_load_select</code> clause on <a href="#table_trigger_router" title="A.15.&nbsp;TRIGGER_ROUTER">TRIGGER_ROUTER</a>.            
            This clause, if present, is applied as a <code class="literal">where</code> clause to the SQL used to select the data to be loaded.
            The clause may use "t" as an alias for the table being loaded, if needed.
            If an <code class="literal">initial_load_select</code> clause is provided, data will <span class="emphasis"><em>not</em></span> be passed through the 
            configured router during initial load.  In cases where routing is done using a feature like <a href="#configuration-subselect-router" title="4.6.2.4.&nbsp;Subselect Router">Section&nbsp;4.6.2.4, &#8220;Subselect Router&#8221;</a>,
            an <code class="literal">initial_load_select</code> clause matching the subselect's criteria would be a more efficient approach.   
        </p>
        <p>
        One example of the use of an initial load select would be if you wished to only load data created more recently than the start of year 2011.  Say, for example,
        the column <code class="literal">created_time</code> contains the creation date.  Your <code class="literal">initial_load_select</code> would read
        <code class="literal">created_time &gt; ts {'2011-01-01 00:00:00.0000'}</code> (using whatever timestamp format works for your database).  This
        then gets applied as a <code class="literal">where</code> clause when selecting data from the table.
        </p>
        <div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Important</h3>
            <p>
            When providing an <code class="literal">initial_load_select</code> be sure to test out the criteria against production data in a query browser.  Do an explain plan to make sure you are properly using indexes.
            </p>
        </div>  
            
        </div>      
     <div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="configuration-dead-triggers"></a>4.6.3.2.&nbsp;Dead Triggers</h4></div></div></div>
        
           <p>
            Occasionally the decision of what data to load initially results in additional triggers.  These triggers, known as <span class="emphasis"><em>Dead Triggers</em></span>,
            are configured such that they do not capture any data changes.  
            A "dead" Trigger is one that does not capture data changes.
            In other words, the <code class="literal">sync_on_insert</code>, <code class="literal">sync_on_update</code>, and <code class="literal">sync_on_delete</code> properties
            for the Trigger are all set to false.  However, since the Trigger is specified, it <span class="emphasis"><em>will</em></span> 
            be included in the initial load of data for target Nodes.
        </p>
        <p>
           Why might you need a Dead Trigger?
            A dead Trigger might be used to load a read-only lookup table, for example.  It could also 
            be used
            to load a table that needs populated with example or default data.
            Another use is a recovery load of data for tables that have a single direction
            of synchronization.  For example, a retail store records sales transaction that
            synchronize in one direction by trickling back to the central office.
            If the retail store needs to recover all the sales transactions from the central office,
            they can be sent
            are part of an initial load from the central office by setting up dead Triggers
            that "sync" in that direction.
        </p>
     
        <p>
            The following SQL statement sets up a non-syncing dead Trigger that sends
            the <code class="literal">sale_transaction</code> table to the "store" Node Group from the "corp" Node Group during
            an initial load.
            </p><pre class="programlisting">

insert into sym_trigger (TRIGGER_ID,SOURCE_CATALOG_NAME,
  SOURCE_SCHEMA_NAME,SOURCE_TABLE_NAME,CHANNEL_ID,
  SYNC_ON_UPDATE,SYNC_ON_INSERT,SYNC_ON_DELETE,
  SYNC_ON_INCOMING_BATCH,NAME_FOR_UPDATE_TRIGGER,
  NAME_FOR_INSERT_TRIGGER,NAME_FOR_DELETE_TRIGGER,
  SYNC_ON_UPDATE_CONDITION,SYNC_ON_INSERT_CONDITION,
  SYNC_ON_DELETE_CONDITION,EXTERNAL_SELECT,
  TX_ID_EXPRESSION,EXCLUDED_COLUMN_NAMES,
  CREATE_TIME,LAST_UPDATE_BY,LAST_UPDATE_TIME) 
  values ('SALE_TRANSACTION_DEAD',null,null,
  'SALE_TRANSACTION','transaction',
  0,0,0,0,null,null,null,null,null,null,null,null,null,
  current_timestamp,'demo',current_timestamp);

insert into sym_router (ROUTER_ID,TARGET_CATALOG_NAME,TARGET_SCHEMA_NAME,
  TARGET_TABLE_NAME,SOURCE_NODE_GROUP_ID,TARGET_NODE_GROUP_ID,ROUTER_TYPE,
  ROUTER_EXPRESSION,SYNC_ON_UPDATE,SYNC_ON_INSERT,SYNC_ON_DELETE,
  CREATE_TIME,LAST_UPDATE_BY,LAST_UPDATE_TIME) 
  values ('CORP_2_STORE',null,null,null,
  'corp','store',null,null,1,1,1,
  current_timestamp,'demo',current_timestamp);
   
insert into sym_trigger_router (TRIGGER_ID,ROUTER_ID,INITIAL_LOAD_ORDER,
  INITIAL_LOAD_SELECT,CREATE_TIME,LAST_UPDATE_BY,LAST_UPDATE_TIME) 
  values ('SALE_TRANSACTION_DEAD','CORP_2_REGION',100,null,
   current_timestamp,'demo',current_timestamp);
   </pre><p>
        </p>
    </div>
    
      <div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="configuration-trigger-router-ping-back"></a>4.6.3.3.&nbsp;Enabling "Ping Back"</h4></div></div></div>
           
           
           <p>
           As discussed in <a href="#defining-data-changes-trigger-routers-ping-back" title="3.6.3.2.&nbsp;Circular References and &#34;Ping Back&#34;">Section&nbsp;3.6.3.2, &#8220;Circular References and "Ping Back"&#8221;</a> SymmetricDS, by default, avoids circular
           data changes.   When a trigger fires as a result of SymmetricDS itself (such as the case when sync on incoming batch is set),
           it records the originating source node of the data change in <code class="literal">source_node_id</code>.
           During routing, if routing results in sending the data back to the originating source node, the data is not routed by default.
           If instead you wish to route the data back to the originating node, you can set the <code class="literal">ping_back_enabled</code>
           column for the needed particular trigger / router combination.  This will cause the router to "ping" the data back to the originating
           node when it usually would not. 
           </p>
        </div>
    </div>
     </div>  
       <div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="configuration-registration"></a>4.7.&nbsp;Opening Registration</h2></div></div></div>
        
        <p>
        Node registration is the act of setting up a new <a href="#table_node" title="A.1.&nbsp;NODE">NODE</a> and
         <a href="#table_node_security" title="A.2.&nbsp;NODE_SECURITY">NODE_SECURITY</a> so that when the new node is brought online
         it is allowed to join the system.  Nodes are only allowed to register if rows exist for the
         node and the <code class="literal">registration_enabled</code> flag is set to 1.  If the <code class="literal">auto.registration</code>
         SymmetricDS property is set to true, then when a node attempts to register, if registration
         has not already occurred, the node will automatically be registered.
       </p>
       <p> 
        SymmetricDS allows you to have multiple nodes with the same <code class="literal">external_id</code>.  Out of the box, openRegistration 
        will open a new registration if a registration already exists for a node with the same external_id.  A new 
        registration means a new node with a new <code class="literal">node_id</code> and the same <code class="literal">external_id</code> will be created.  
        If you want to re-register the same node you can use the <code class="literal">reOpenRegistration()</code> JMX
        method which takes a <code class="literal">node_id</code> as an argument.
        </p>
    </div>
  
    <div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="transform-data"></a>4.8.&nbsp;Transforming Data</h2></div></div></div>
        
        <p>
        New to SymmetricDS 2.4, SymmetricDS is now able to transform synchronized data by way of
        configuration (previously, for most cases a custom data loader would need to have been written).  This transformation can take
        place on a source node or on a target node, as the data is being loaded or extracted.
        With this new feature you can, for example:
        </p>
        <div class="itemizedlist"><ul type="disc"><li>
                    <p>Copy a column from a source table to two (or more) target table columns,</p>
                </li><li>
                    <p>Merge columns from two or more source tables into a single row in a target table,</p>
                </li><li>
                    <p>Insert constants in columns in target tables based on source data synchronizations,</p>
                </li><li>
                    <p>Insert multiple rows of data into a single target table based on one change in a source table,</p>
                </li><li>
                    <p>Apply a Bean Shell script to achieve a custom transform when loading into the target database.</p>
                </li></ul></div>
         <p>
         These transformations can take place either on the target or on the source, and as data is either being extracted or loaded.  In either case, the transformation is
         initiated due to existence of a source
         synchronization trigger.  The source trigger creates the synchronization data, while the transformation configuration decides
         what to do with the sychronization data as it is either being extracted from the source or loaded into the target.
         You have the flexibility of defining different transformation behavior depending on whether the source
         change that triggered the synchronization was an Insert, Update, or Delete.  In the case of Delete, you even have options on what exactly to do on the target side, 
         be it a delete of a row, setting columns to specific values, or absolutely nothing at all.
         </p>
         <p>
         A few key concepts are important to keep in mind to understand how SymmetricDS performs transformations.  The first concept is that of the
         "source operation" or "source DML type", which is the type of operation that occurred to generate the synchronization data in the first place (i.e., an insert, a delete, or an update).
         Your transformations can be configured to act differently based on the source DML type, if desired.  When transforming, by
         default the DML action taken on the target matches that of the action taken on the row in the source (although this behavior can be altered through configuration if needed).  If the
         source DML type is an Insert, for example, the resulting transformation DML(s) will be Insert(s).
         </p>
         <p>
         Another important concept is the way in which transforms are applied.  Each source operation may map to one or more transforms and result in one
         or more operations on the target tables.  Each of these target operations are performed as independent operations in sequence and must be "complete" from a SQL perspective.  In other words, you
         must define columns for the transformation that are sufficient to fill in any primary key or other required data in the target table if the source operation
         was an Insert, for example.
         </p>  
         <p>
         Finally, please note that the tranformation engine relies on a source trigger / router existing to supply the source data for the transformation.  The transform configuration will never be
         used if the source table and target node group does not have a defined trigger / router combination for that source table and target node group.
         </p>
        <div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="transform-data-tables"></a>4.8.1.&nbsp;Transform Configuration Tables</h3></div></div></div>
        
        <p>
        SymmetricDS stores its transformation configuration in two configuration tables,  <a href="#table_transform_table" title="A.27.&nbsp;TRANSFORM_TABLE">TRANSFORM_TABLE</a> and  
        <a href="#table_transform_column" title="A.28.&nbsp;TRANSFORM_COLUMN">TRANSFORM_COLUMN</a>.  Defining a transformation involves configuration in both tables, with the first table
        defining which source and destination tables are involved, and the second defining the columns involved in the transformation and the behavior of
        the data for those columns.  We will explain the various options available in both tables and the various pre-defined transformation types.
        </p>
        <p>
        To define a transformation, you will first define the source table and target table that applies to a particular transformation.  The source and target tables, along with
        a unique identifier (the transform_id column) are defined in <a href="#table_transform_table" title="A.27.&nbsp;TRANSFORM_TABLE">TRANSFORM_TABLE</a>.  In addition, you will specify the 
        source_node_group_id and target_node_group_id to which the transform will apply, along with whether the transform should occur on the Extract step or the Load step (transform_point).
        All of these values are required.
        </p>
        
        <p>
        Three additional configuration settings are also defined at the source-target table level:  the order of the transformations, the behavior when deleting, and whether an update should
        always be attempted first.  More specifically, 
        </p><div class="itemizedlist"><ul type="disc"><li>transform_order:  For a single source operation that is mapped to a transformation,
         there could be more than one target operation that takes place.  You may control the order in which the target operations are applied
         through a configuration parameter defined for each source-target table combination.  This might be important, for example, if
         the foreign key relationships on the target tables require you to execute the transformations in a particular order.         
            </li><li>delete_action: When a source operation of Delete takes place, there are three possible ways to handle the transformation at the target.  The options include:
             <div class="itemizedlist"><ul type="circle"><li>
                NONE - The delete results in no target changes.
                </li><li>
                DEL_ROW - The delete results in a delete of the row as specified by the pk columns defined in the transformation configuration.
                </li><li>
                UPDATE_COL - The delete results in an Update operation on the target which updates the specific rows and columns based on the defined transformation.
                </li></ul></div>
            </li><li>update_first: This option overrides the default behavior for an Insert operation.  Instead of attempting the Insert first,
            SymmetricDS will always perform an Update first and then fall back to an Insert if that fails.  Note that, by default, fall back
            logic <span class="emphasis"><em>always</em></span> applies for Insert and Updates.  Here, all you a specifying is whether to always do an Update first, which
            can have performance benefits under certain situations you may run into.            
            </li></ul></div><p>
        </p>
        
         <p>
        For each transformation defined in <a href="#table_transform_table" title="A.27.&nbsp;TRANSFORM_TABLE">TRANSFORM_TABLE</a>, the columns to be transformed (and how they are transformed) are defined
        in <a href="#table_transform_column" title="A.28.&nbsp;TRANSFORM_COLUMN">TRANSFORM_COLUMN</a>.  This column-level table typically has several rows for each transformation id, each of which defines
        the source column name, the target column name, as well as the following details:
          </p><div class="itemizedlist"><ul type="disc"><li>
                include_on:  Defines whether this entry applies to source operations of Insert (I), Update (U), or Delete (D), or any source operation.
                </li><li>
                pk:  Indicates that this mapping is used to define the "primary key" for identifying the target row(s) (which may or may not be the true primary key of the target table).
                This is used to define the "where" clause when an Update or Delete on the target is occurring.  At least one row marked as a pk should be present for each transform_id.
                </li><li>
                transform_type, transform_expression:  Specifies how the data is modified, if at all.  The available transform types are discussed below, and the default is 'copy', which just copies the data
                from source to target.
                </li><li>
                transform_order: In the event there are more than one columns to transform, this defines the relative order in which the transformations are applied.
                </li></ul></div><p>
        </p>
        </div>
        
        <div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="transform-data-types"></a>4.8.2.&nbsp;Transformation Types</h3></div></div></div>
        
            <p> There are several pre-defined transform types available in SymmetricDS.  Additional ones can be defined by creating and configuring an
             extension point which implements the <code class="code">IColumnTransform</code> interface.  The pre-defined transform types include the following (the transform_type
             entry is shown in parentheses):
             </p><div class="itemizedlist"><ul type="disc"><li>
                    Copy Column Transform ('copy'):  This transformation type copies the source column value to the target column.  This is the default behavior.
                </li><li>
                    Constant Transform ('const'):  This transformation type allows you to map a constant value to the given target column.  The constant itself is placed in transform_expression.   
                </li><li>
                    Variable Transform ('variable'):  This transformation type allows you to map a built-in variable to the given target column.  The variable name is placed in transform_expression.
                    The following variables are available: <code class="code">system_date</code> is the current system date, and <code class="code">system_timestamp</code> is the current system date and time.
                </li><li>
                    Additive Transform ('additive'): This transformation type is used for numeric data.  It computes the change between the old and new values on the source
                    and then adds (or subtracts) the value from the existing value in the target column.  For example, if the source column changed from a 2 to a 4, and the target
                    column is currently 10, the effect of the transform will be to change the target column to a value of 12 ( 10+(4-2) =&gt; 12 ).
                </li><li>
                    Substring Transform ('substr'):  This transformation computes a substring of the source column data and uses the substring as the target column value.  The transform_expression can
                    be a single integer (<code class="code">n</code>, the beginning index), or a pair of comma-separated integers (<code class="code">n,m</code> - the beginning and ending index).  
                    The transform behaves as the Java substring function would using the specified values in transform_expression.
                </li><li>
                    Lookup Transform ('lookup'):  This transformation allows for the lookup of a column value from a single row using a SQL statement provided in the transform_expression.
                    The SQL statement can access the current source row using parameters with a name of the source column name in upper case prefixed by a colon.
                    For example, a SQL statement that looks up <code class="code">customer_id</code> from another table using the <code class="code">id</code> column of the current source row
                    is <code class="code">select customer_id from customers where group_id = :ID</code>.
                </li><li>
                    Multiplier Transform ('multiply'):  This transformation allows for the creation of multiple rows in the target table based on the transform_expression.  This transform type
                    can only be used on a primary key column.  The transform_expression is a SQL statement that returns the list to be used to create the multiple targets.
                </li><li>
                    Shell Script Transform ('bsh'):  This transformation allows you to provide a Bean Shell script in transform_expression and executes the script at the time of transformation.
                    Some variables are provided to the script: <code class="code">COLUMN_NAME</code> is a variable for a source column in the row, where the variable name is the column name in uppercase; 
                    <code class="code">currentValue</code> is the value of the current source column;
                    <code class="code">oldValue</code> is the old value of the source column for an updated row;
                    <code class="code">jdbcTemplate</code> is a Spring JdbcTemplate object for querying or updating the database.
                </li><li>
                    Variable Transform ('variable'):  This transformation allows you to place a dynamic variable (such as the current database time) into the target column.  The only transform_expression
                    value currently supported is <code class="code">system_timestamp</code>.
                 </li><li>
                    Identity Transform ('identity'):  This transformation allows you to insert into a identity column by computing a new identity, not copying the actual identity value from the source.
                 </li></ul></div><p>
            </p>
        </div>
        
        
    </div>
</div>
    <div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="advanced-topics"></a>Chapter&nbsp;5.&nbsp;Advanced Topics</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="#advanced-sync">5.1. Advanced Synchronization</a></span></dt><dd><dl><dt><span class="section"><a href="#bi-direction-sync">5.1.1. Bi-Directional Synchronization</a></span></dt><dt><span class="section"><a href="#multi-tier">5.1.2. Multi-Tiered Synchronization</a></span></dt><dd><dl><dt><span class="section"><a href="#registration-redirect">5.1.2.1. Registration Redirect</a></span></dt></dl></dd></dl></dd><dt><span class="section"><a href="#jobs">5.2. Jobs</a></span></dt><dd><dl><dt><span class="section"><a href="#routing-job">5.2.1. Route Job</a></span></dt><dd><dl><dt><span class="section"><a href="#routing-job-overview">5.2.1.1. Overview</a></span></dt><dt><span class="section"><a href="#data-gaps">5.2.1.2. Data Gaps</a></span></dt></dl></dd><dt><span class="section"><a href="#controlling-synchronization">5.2.2. Controlling Synchronization Frequency</a></span></dt><dt><span class="section"><a href="#sync-triggers">5.2.3. Sync Triggers Job</a></span></dt></dl></dd><dt><span class="section"><a href="#jms-publishing">5.3. JMS Publishing</a></span></dt><dt><span class="section"><a href="#deployment-options">5.4. Deployment Options</a></span></dt><dd><dl><dt><span class="section"><a href="#deployment-options-web-archive">5.4.1. Web Archive</a></span></dt><dt><span class="section"><a href="#deployment-options-standalone">5.4.2. Standalone</a></span></dt><dt><span class="section"><a href="#deployment-options-embedded">5.4.3. Embedded</a></span></dt></dl></dd><dt><span class="section"><a href="#running-service">5.5. Running SymmetricDS as a Service</a></span></dt><dd><dl><dt><span class="section"><a href="#running-service-windows">5.5.1. Running as a Windows Service</a></span></dt><dt><span class="section"><a href="#running-service-unix">5.5.2. Running as a *nix Service</a></span></dt></dl></dd><dt><span class="section"><a href="#clustering">5.6. Clustering</a></span></dt><dt><span class="section"><a href="#encrypted-passwords">5.7. Encrypted Passwords</a></span></dt><dt><span class="section"><a href="#secure-transport">5.8. Secure Transport</a></span></dt><dd><dl><dt><span class="section"><a href="#secure-transport-sym">5.8.1. Sym Launcher</a></span></dt><dt><span class="section"><a href="#secure-transport-tomcat">5.8.2. Tomcat</a></span></dt><dt><span class="section"><a href="#secure-transport-keystore">5.8.3. Keystores</a></span></dt><dt><span class="section"><a href="#secure-transport-keys">5.8.4. Generating Keys</a></span></dt></dl></dd><dt><span class="section"><a href="#basic-auth">5.9. Basic Authentication</a></span></dt><dt><span class="section"><a href="#multi-server">5.10. Multi-Server Mode</a></span></dt></dl></div>
    
    <p>
       This chapter focuses on a variety of topics, including deployment options, jobs, clustering, encryptions, synchronization control, 
       and configuration of SymmetricDS.
    </p>

 <div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="advanced-sync"></a>5.1.&nbsp;Advanced Synchronization</h2></div></div></div>
    
 <div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="bi-direction-sync"></a>5.1.1.&nbsp;Bi-Directional Synchronization</h3></div></div></div>
        
        <p>
            SymmetricDS allows tables to be synchronized bi-directionally.  Note that an outgoing 
            synchronization does not process changes during an incoming synchronization on the same node unless the trigger 
            was created with the <code class="literal">sync_on_incoming_batch</code> flag set.  If the <code class="literal">sync_on_incoming_batch</code> flag
            is set, then update loops are prevented by a feature that is available in most database dialects.  
            More specifically, during an incoming synchronization the source <code class="literal">node_id</code> is put into a database session variable that is 
            available to the database trigger.  Data events are not generated if the target <code class="literal">node_id</code> 
            on an outgoing synchronization is equal to the source <code class="literal">node_id</code>.  
        </p>     
        <p>
            By default, only the columns that changed will be updated in the target system.
        </p>  
        <p>
            More complex conflict resolution strategies can be accomplished by using the 
            <code class="literal">IDataLoaderFilter</code> extension point which has access to both 
            old and new data.
        </p>         
    </div>     
      
    <div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="multi-tier"></a>5.1.2.&nbsp;Multi-Tiered Synchronization</h3></div></div></div>
        
        <p>
            As shown in <a href="#organizing-nodes" title="3.2.&nbsp;Organizing Nodes">Section&nbsp;3.2, &#8220;Organizing Nodes&#8221;</a>, there may be
            scenarios where data needs to flow through multiple tiers of nodes that
            are organized in a tree-like network with each tier requiring a different subset of data.  For example,
            you may have a system where the lowest tier may by a computer or device located in a store.  Those devices 
            may connect to a server located physically at that store.  Then the store server may communicate with 
            a corporate server for example.  In this case, the three tiers would be device, store, and corporate.
            Each tier is typically represented by a node group.  Each node in 
            the tier would belong to the node group representing that tier.   
        </p>
        <p>
            A node will always push and pull data to other node groups according to the node group link configuration.
            A node can only pull and push data to other nodes that are represented <code class="literal">node</code> table in its database and 
            having <code class="literal">sync_enabled = 1</code>.
            Because of this, a tree-like 
            hierarchy of nodes can be created by having only a subset of nodes belonging to the same node group represented at the different branches of the tree.  
        </p>
        <p>
            If auto registration is turned <span class="emphasis"><em>off</em></span>, then this setup must occur manually by opening registration 
            for the desired nodes at the desired parent node and by configuring each node's <code class="literal">registration.url</code>
             to be the parent node's URL.  
            The parent node is always tracked by the setting of the parent's <code class="literal">node_id</code> in the <code class="literal">created_at_node_id</code> column of the new node.  
            When a node registers and downloads its configuration it is always provided the configuration for nodes 
            that might register with the node itself based on the Node Group Links defined in the parent node.
        </p>
                
 
    <div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="registration-redirect"></a>5.1.2.1.&nbsp;Registration Redirect</h4></div></div></div>
            
        <p>
            When deploying a multi-tiered system it may be advantageous to have only one registration server, even though the parent node of a registering node
            could be any of a number of nodes in the system.  In SymmetricDS the parent node is always the node that a child registers with.  The 
            <a href="#table_registration_redirect" title="A.17.&nbsp;REGISTRATION_REDIRECT">REGISTRATION_REDIRECT</a> table allows a single node, usually the root server in the network, to
            redirect registering nodes to their true parents.  It does so based on a mapping found in the table of the external id (<code class="literal">registrant_external_id</code>) to the parent's node 
            id (<code class="literal">registration_node_id</code>).
        </p>
        <p>
            For example, if it is desired to have a series of regional servers that workstations at retail stores get assigned to based on their <code class="literal">external_id</code>, the store number, then
            you might insert into <a href="#table_registration_redirect" title="A.17.&nbsp;REGISTRATION_REDIRECT">REGISTRATION_REDIRECT</a> the store number as the <code class="literal">registrant_external_id</code> and the <code class="literal">node_id</code> of
            the assigned region as the <code class="literal">registration_node_id</code>.  When a workstation at the store registers, the root server send an HTTP redirect to the <code class="literal">sync_url</code> of the node 
            that matches the <code class="literal">registration_node_id</code>. 
        </p>
        <div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Important</h3>
            <p>Please see <a href="#configuration-initial-load" title="4.6.3.1.&nbsp;Initial Load">Section&nbsp;4.6.3.1, &#8220;Initial Load&#8221;</a> for important details around initial loads
            and registration when using registration redirect.
            </p>
            </div>
            
    </div>
    </div>
</div>
          
    
    <div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="jobs"></a>5.2.&nbsp;Jobs</h2></div></div></div>
     
    <p>
        The SymmetricDS software allows for outgoing and incoming changes to be synchronized
        to/from other databases.  The node that initiates a synchronization connection is the client, and the
        node receiving a connection is the host.  Because synchronization is configurable to
        push or pull in either direction, the same node can act as either a client or a host
        in different circumstances.
    </p>
    <p>
        The SymmetricDS software consists of a series of background jobs, managers, Servlets, and services wired together
        via dependency injection using the <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://springframework.org" target="_top">Spring Framework</a>.
    </p>    
     
    <p>
        As a client, the node runs the router job, push job and pull job on a timer thread.  
        The router job uses services to create batches that are targeted at certain nodes.  
        The push job uses services to extract and stream data to
        another node (that is, it pushes data).  The response from a push is a list
        of batch acknowlegements to indicate that data was loaded.
        The pull job uses services to load data that is streamed from another node
        (<span class="emphasis"><em>i.e.</em></span>, it pulls data).  After loading data, a second connection is made to send a list
        of batch acknowlegements.
    </p>
    <p>
        As a host, the node waits for incoming connections that pull, push, or acknowledge data changes.
        The push Servlet uses services to load data that is pushed from a client node.
        After loading data, it responds with a list of batch acknowledgements.
        The pull Servlet uses services to extract, and stream data back to the client node.
        The ack Servlet uses services to update the status of data that was loaded at a client node.  The router
        job batches and routes data.
    </p>
    <p>
        By default, data is extracted from the source database into memory until a threshold size is reached.
        If the threshold size is reached, data is streamed to a temporary file in the JVM's default temporary 
        directory.  Next, the data is streamed to the target node across the transport layer.  The receiving
        node will cache the data in memory until the threshold size is reached, writing to a temporary file if
        necessary.  At last, the data is loaded into the target database by the data loader.  This step by step
        approach allows for extract time, transport time, and load time to all be measured independently.  It 
        also allows database resources to be used most optimally.
    </p>    
    <p>
        The transport manager handles the incoming and outgoing streams of data between nodes.
        The default transport is based on a simple implementation over HTTP.  An internal transport
        is also provided.  It is possible to add other implementations, such as a socket-based transport manager.
    </p> 
    <p>
        Node communication over HTTP is represented in the following figure.
    </p> 
    <p>
        </p><div class="figure"><a name="d4e1020"></a><div class="figure-contents">
            
            <div class="mediaobject"><img src="images/seq-node-communication.gif" alt="Node Communication"></div>
        </div><p class="title"><b>Figure&nbsp;5.1.&nbsp;Node Communication</b></p></div><p><br class="figure-break">
    </p>    
    <p>
        The <code class="literal">StandaloneSymmetricEngine</code> is wrapper API that can be used to directly start the client services only.  The 
        <code class="literal">SymmetricWebServer</code> is a wrapper API that can be used to directly start <span class="emphasis"><em>both</em></span> the
        client and host services inside a Jetty web container.  The <code class="literal">SymmetricLauncher</code> provides command line tools to work 
        with and start SymmetricDS.
    </p>   
    
  <div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="routing-job"></a>5.2.1.&nbsp;Route Job</h3></div></div></div>
    
        <div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="routing-job-overview"></a>5.2.1.1.&nbsp;Overview</h4></div></div></div>
        
      <p>
        The SymmetricDS-created database triggers cause data to be capture in the <a href="#table_data" title="A.20.&nbsp;DATA">DATA</a> table.
        The next step in the synchronization process is to process the change data to determine which nodes, if any, the data should
        be routed to.  This step is performed by the <span class="emphasis"><em>Route Job</em></span>.  In addition to determining which nodes data will
        be sent to, the Route Job is also responsible for determing how much data will be batched together for transport. 
        It is a single background task that inserts into <a href="#table_data_event" title="A.23.&nbsp;DATA_EVENT">DATA_EVENT</a> 
        and <a href="#table_outgoing_batch" title="A.24.&nbsp;OUTGOING_BATCH">OUTGOING_BATCH</a>.  
     </p>
     <p>
         At a high level, the Route Job is straightforward.  It collects a list of data ids from <a href="#table_data" title="A.20.&nbsp;DATA">DATA</a> 
         which haven't yet been routed (see <a href="#data-gaps" title="5.2.1.2.&nbsp;Data Gaps">Section&nbsp;5.2.1.2, &#8220;Data Gaps&#8221;</a> for much more detail about this step), 
         one channel at a time, up to a limit specified by the channel configuration
         (<code class="literal">max_data_to_route</code>, on  <a href="#table_channel" title="A.10.&nbsp;CHANNEL">CHANNEL</a>).
         The data is then batched based on the <code class="literal">batch_algorithm</code> defined for the channel and as documented in 
          <a href="#configuration-channel" title="4.5.&nbsp;Channel">Section&nbsp;4.5, &#8220;Channel&#8221;</a>.  Note that, for the default batching algorithm, there may actually be more than <code class="literal">max_data_to_route</code> included depending
         on the transaction boundaries.  The mapping of data to specific nodes, organized into batches, is then 
         recorded in    <a href="#table_outgoing_batch" title="A.24.&nbsp;OUTGOING_BATCH">OUTGOING_BATCH</a> with a status of "RT" in each case (representing the
         fact that the Route Job is still running).
         Once the routing algorithms and batching are completed, the batches are organized with their corresponding data ids 
         and saved in <a href="#table_data_event" title="A.23.&nbsp;DATA_EVENT">DATA_EVENT</a>.  Once <a href="#table_data_event" title="A.23.&nbsp;DATA_EVENT">DATA_EVENT</a> is
         updated, the rows in <a href="#table_outgoing_batch" title="A.24.&nbsp;OUTGOING_BATCH">OUTGOING_BATCH</a> are updated to a status of New "NE".
    </p>
    </div>
    <div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="data-gaps"></a>5.2.1.2.&nbsp;Data Gaps</h4></div></div></div>
        
      <p>
      On the surface, the first Route Job step of collecting unrouted data ids seems simple: assign
     sequential data ids for each data row as it's inserted and keep track of which data id was last routed and start from there.  The difficulty arises, however, due to the fact that 
     there can be multiple transactions inserting into <a href="#table_data" title="A.20.&nbsp;DATA">DATA</a> simultaneously.
     As such, a given section of rows in the  <a href="#table_data" title="A.20.&nbsp;DATA">DATA</a> table may actually contain "gaps" in the data ids when the Route Job is executing.
     Most of these gaps are only temporarily and fill in at some point after routing and need to be picked up with the next run of the Route Job.  Thus, the Route Job needs to
     remember to route the filled-in gaps.  Worse yet, some of these gaps are actually permanent and result from
     a transaction that is rolled back for some reason.  In this case, the Route Job must continue to watch
     for the gap to fill in and, at some point, eventually gives up and assumes the gap is permanent and can be skipped.  All of this
     must be done in some fashion that guarantees that gaps are routed when they fill in while also keeping
     routing as efficient as possible.
     </p>
     <p>
     SymmetricDS handles the issue of data gaps by making use of a table, <a href="#table_data_gap" title="A.22.&nbsp;DATA_GAP">DATA_GAP</a>, to record
     gaps found in the data ids.  In fact, this table completely defines the entire range of data tha can be routed at any point in time.
     For a brand new instance of SymmetricDS, this table is empty
     and SymmetricDS creates a gap starting from data id of zero and ending with a very large number (defined by <code class="literal">routing.largest.gap.size</code>).
     At the start of a Route Job, the list of valid gaps (gaps with status of 'GP') is collected, and each gap is evaluated in turn.
     If a gap is sufficiently old (as defined by <code class="literal">routing.stale.dataid.gap.time.ms</code>, the gap
     is marked as skipped (status of 'SK') and will no longer be evaluated in future Route Jobs (note that the 'last' gap (the one with the highest starting data id) is never
     skipped).  If not skipped, then  <a href="#table_data_event" title="A.23.&nbsp;DATA_EVENT">DATA_EVENT</a> is searched for data ids present in the gap.
     If one or more data ids is found in <a href="#table_data_event" title="A.23.&nbsp;DATA_EVENT">DATA_EVENT</a>, then the current gap is marked with a status
     of OK, and new gap(s) are created to represent the data ids still missing in the gap's range.  This process is done for
     all gaps.  If the very last gap contained data, a new gap starting from the highest data id and ending at (highest data id + <code class="literal">routing.largest.gap.size</code>) is then created.
     This process has resulted in an updated list of gaps which may contain new data to be routed.
     </p>
   
     </div>
     </div>
     <div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="controlling-synchronization"></a>5.2.2.&nbsp;Controlling Synchronization Frequency</h3></div></div></div>
        
        <p>
        The frequency of data synchronization is controlled by the coordination of a series of asynchronous events.   
        </p>    
        <p>
        The Route Job determines which nodes
        data will be sent to, as well as how much data will be batched together for transport.  When the <code class="literal">start.route.job</code> SymmetricDS property is set to 
        <code class="literal">true</code>, the frequency that routing occurs is controlled by the <code class="literal">job.routing.period.time.ms</code>.  Each time data is routed, the 
        <a href="#table_data_ref" title="A.21.&nbsp;DATA_REF">DATA_REF</a> table is updated with the id of the last contiguous data row to have been processed.  This is done so the query to find
        unrouted data is optimal. 
        </p>
        <p>
        After data is routed, it awaits transport to the target nodes.  Transport can occur when a client node is configured to pull data or when the host node is configured to push data.  These
        events are controlled by the <span class="emphasis"><em>Push</em></span> and the <span class="emphasis"><em>Pull Jobs</em></span>.  When the <code class="literal">start.pull.job</code> SymmetricDS property is set to 
        <code class="literal">true</code>, the frequency that data is pulled is controlled by the <code class="literal">job.pull.period.time.ms</code>.  When the <code class="literal">start.push.job</code> SymmetricDS property is set to 
        <code class="literal">true</code>, the frequency that data is pushed is controlled by the <code class="literal">job.push.period.time.ms</code>.  Data is extracted by channel from the source database's 
        <a href="#table_data" title="A.20.&nbsp;DATA">DATA</a> table at an interval controlled by the <code class="literal">extract_period_millis</code> column on the 
        <a href="#table_channel" title="A.10.&nbsp;CHANNEL">CHANNEL</a> table.  The <code class="literal">last_extract_time</code> is 
        always recorded, by channel, on the <a href="#table_node_channel_ctl" title="A.11.&nbsp;NODE_CHANNEL_CTL">NODE_CHANNEL_CTL</a> table for the host node's id.  When the Pull and Push Job run, if the extract period
        has not passed according to the last extract time, then the channel will be skipped for this run.  If the <code class="literal">extract_period_millis</code> is set to zero, data extraction will happen every time the jobs run.
        </p>
        <p>
        SymmetricDS also provides the ability to configure windows of time when synchronization is allowed.  This is done using the
        <a href="#table_node_group_channel_window" title="A.12.&nbsp;NODE_GROUP_CHANNEL_WINDOW">NODE_GROUP_CHANNEL_WINDOW</a> 
        table.  A list of allowed time windows can be specified for a node group and a channel.  If one or more windows exist, then data will only be extracted and transported if the time
        of day falls within the window of time specified.  The configured times are always for the target node's local time.  If the <code class="literal">start_time</code> is greater than the <code class="literal">end_time</code>, then the window crosses
        over to the next day.
        </p>
        <p>
        All data loading may be disabled by setting the <code class="literal">dataloader.enable</code> property to false.  This has the effect of not allowing incoming synchronizations, while allowing outgoing
        synchronizations.  All data extractions may be disabled by setting the <code class="literal">dataextractor.enable</code> property to false.  These properties can be controlled by inserting into the 
        root server's <a href="#table_parameter" title="A.16.&nbsp;PARAMETER">PARAMETER</a> table.  These properties affect every channel with the exception of the 'config' channel.  
        </p>
    </div>         
       
    <div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="sync-triggers"></a>5.2.3.&nbsp;Sync Triggers Job</h3></div></div></div>
        
        <p>
            SymmetricDS examines the current configuration, corresponding database triggers,
            and the underlying tables to determine if database triggers need created or updated.
            The change activity is recorded on the <a href="#table_trigger_hist" title="A.19.&nbsp;TRIGGER_HIST">TRIGGER_HIST</a> table with a reason for the
            change.  The following reasons for a change are possible:

            </p><div class="itemizedlist"><ul type="disc"><li>
                    <p>N - New trigger that has not been created before</p>
                </li><li>
                    <p>S - Schema changes in the table were detected</p>
                </li><li>
                    <p>C - Configuration changes in Trigger</p>
                </li><li>
                    <p>T - Trigger was missing</p>
                </li></ul></div><p>

            A configuration entry in Trigger without any history in Trigger Hist results in a new
            trigger being created (N).  The Trigger Hist stores a hash of the underlying table, so
            any alteration to the table causes the trigger to be rebuilt (S).  When the 
            <code class="literal">last_update_time</code> is changed on the Trigger entry, the configuration change causes
            the trigger to be rebuilt (C).  If an entry in Trigger Hist is missing the
            corresponding database trigger, the trigger is created (T).
        </p>
        <p>
            The process of examining triggers and rebuilding them is automatically run during startup and
            each night by the SyncTriggersJob.  The user can also manually run the process at any time 
            by invoking the <code class="literal">syncTriggers()</code> method over JMX.  The SyncTriggersJob is enabled by default 
            to run at 15 minutes past midnight.  If SymmetricDS is being run from a collection of servers
            (multiple instances of the same Node running against the same database), then locking
            should be enable to prevent database contention.  The following runtime properties
            control the behavior of the process.
            </p><div class="variablelist"><dl><dt><span class="term">
                        <span><strong class="command">start.synctriggers.job</strong></span>
                    </span></dt><dd>
                        <p>
                            Whether the sync triggers job is enabled for this node.
                            [&nbsp;Default:&nbsp;true&nbsp;]
                        </p>
                    </dd><dt><span class="term">
                        <span><strong class="command">job.synctriggers.aftermidnight.minutes</strong></span>
                    </span></dt><dd>
                        <p>
                            If scheduled, the sync triggers job will run nightly. This is how long after midnight
                            that job will run. [&nbsp;Default:&nbsp;15&nbsp;]
                        </p>
                    </dd><dt><span class="term">
                        <span><strong class="command">cluster.lock.during.sync.triggers</strong></span>
                    </span></dt><dd>
                        <p>
                            Indicate if the sync triggers job is clustered and requires a lock before running.
                            [&nbsp;Default:&nbsp;false&nbsp;]
                        </p>
                    </dd></dl></div><p>
        </p>
    </div> 
     </div>
     <div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="jms-publishing"></a>5.3.&nbsp;JMS Publishing</h2></div></div></div>
            
        <p>
            With the proper configuration SymmetricDS can publish XML messages of captured data changes to 
            JMS during routing or transactionally while data loading synchronized data into a target database.
            The following explains how to publish to JMS during synchronization to the target database. 
       </p>
       <p>     
            The XmlPublisherDataLoaderFilter is a
            <a href="#extensions-data-loader-filter" title="6.2.&nbsp;IDataLoaderFilter">IDataLoaderFilter</a> that may be configured to 
            publish specific tables as an XML message to a JMS provider.
            See <a href="#extensions" title="Chapter&nbsp;6.&nbsp;Extending SymmetricDS">Chapter&nbsp;6, <i xmlns:xlink="http://www.w3.org/1999/xlink">Extending SymmetricDS</i></a> for information on how 
            to configure an extension point.  If the publish to JMS fails, the batch will be marked in error, 
            the loaded data for the batch will be rolled back
            and the batch will be retried during the next synchronization run.            
        </p>
        <p>
        The following is an example extension point configuration that will publish four tables in XML with a root 
        tag of <span class="emphasis"><em>'sale'</em></span>.  Each XML message will be grouped by the batch and the column names identified by
        the groupByColumnNames property which have the same values.
                </p><pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:context="http://www.springframework.org/schema/context"
    xsi:schemaLocation="http://www.springframework.org/schema/beans 
           http://www.springframework.org/schema/beans/spring-beans-3.0.xsd
           http://www.springframework.org/schema/context
           http://www.springframework.org/schema/context/spring-context-3.0.xsd"&gt;
 
    &lt;bean id="configuration-publishingFilter" 
      class="org.jumpmind.symmetric.integrate.XmlPublisherDataLoaderFilter"&gt;
        &lt;property name="xmlTagNameToUseForGroup" value="sale"/&gt;
        &lt;property name="tableNamesToPublishAsGroup"&gt;
            &lt;list&gt;
               &lt;value&gt;SALE_TX&lt;/value&gt;
               &lt;value&gt;SALE_LINE_ITEM&lt;/value&gt;
               &lt;value&gt;SALE_TAX&lt;/value&gt;
               &lt;value&gt;SALE_TOTAL&lt;/value&gt;
            &lt;/list&gt;            
        &lt;/property&gt;
        &lt;property name="groupByColumnNames"&gt;
            &lt;list&gt;
               &lt;value&gt;STORE_ID&lt;/value&gt;
               &lt;value&gt;BUSINESS_DAY&lt;/value&gt;
               &lt;value&gt;WORKSTATION_ID&lt;/value&gt;
               &lt;value&gt;TRANSACTION_ID&lt;/value&gt;
            &lt;/list&gt;                      
        &lt;/property&gt;
        &lt;property name="publisher"&gt;
           &lt;bean class="org.jumpmind.symmetric.integrate.SimpleJmsPublisher"&gt;
               &lt;property name="jmsTemplate" ref="definedSpringJmsTemplate"/&gt;
           &lt;/bean&gt;
        &lt;/property&gt;        
    &lt;/bean&gt;     
&lt;/beans&gt;</pre><p>        
        </p>
        <p>
          The publisher property on the XmlPublisherDataLoaderFilter takes an interface of type IPublisher.  The implementation
          demonstrated here is an implementation that publishes to JMS using Spring's 
          <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://static.springsource.org/spring/docs/3.0.x/spring-framework-reference/html/jms.html#jms-jmstemplate" target="_top">JMS template</a>.
          Other implementations of IPublisher could easily publish the XML to other targets like an HTTP server, the file system or secure copy it to another server.
        </p>
        <p>
          The above configuration will publish XML similiar to the following:
            </p><pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;sale xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
  id="0012010-01-220031234" nodeid="00001" time="1264187704155"&gt;
  &lt;row entity="SALE_TX" dml="I"&gt;
    &lt;data key="STORE_ID"&gt;001&lt;/data&gt;
    &lt;data key="BUSINESS_DAY"&gt;2010-01-22&lt;/data&gt;
    &lt;data key="WORKSTATION_ID"&gt;003&lt;/data&gt;
    &lt;data key="TRANSACTION_ID"&gt;1234&lt;/data&gt;
    &lt;data key="CASHIER_ID"&gt;010110&lt;/data&gt;
  &lt;/row&gt;        
  &lt;row entity="SALE_LINE_ITEM" dml="I"&gt;
    &lt;data key="STORE_ID"&gt;001&lt;/data&gt;
    &lt;data key="BUSINESS_DAY"&gt;2010-01-22&lt;/data&gt;
    &lt;data key="WORKSTATION_ID"&gt;003&lt;/data&gt;
    &lt;data key="TRANSACTION_ID"&gt;1234&lt;/data&gt;
    &lt;data key="SKU"&gt;9999999&lt;/data&gt;  
    &lt;data key="PRICE"&gt;10.00&lt;/data&gt;
    &lt;data key="DESC" xsi:nil="true"/&gt;
  &lt;/row&gt;        
  &lt;row entity="SALE_LINE_ITEM" dml="I"&gt;
    &lt;data key="STORE_ID"&gt;001&lt;/data&gt;
    &lt;data key="BUSINESS_DAY"&gt;2010-01-22&lt;/data&gt;
    &lt;data key="WORKSTATION_ID"&gt;003&lt;/data&gt;
    &lt;data key="TRANSACTION_ID"&gt;1234&lt;/data&gt;
    &lt;data key="SKU"&gt;9999999&lt;/data&gt;  
    &lt;data key="PRICE"&gt;10.00&lt;/data&gt;
    &lt;data key="DESC" xsi:nil="true"/&gt;
  &lt;/row&gt;
  &lt;row entity="SALE_TAX" dml="I"&gt;
    &lt;data key="STORE_ID"&gt;001&lt;/data&gt;
    &lt;data key="BUSINESS_DAY"&gt;2010-01-22&lt;/data&gt;
    &lt;data key="WORKSTATION_ID"&gt;003&lt;/data&gt;
    &lt;data key="TRANSACTION_ID"&gt;1234&lt;/data&gt;
    &lt;data key="AMOUNT"&gt;1.33&lt;/data&gt;  
  &lt;/row&gt;
  &lt;row entity="SALE_TOTAL" dml="I"&gt;
    &lt;data key="STORE_ID"&gt;001&lt;/data&gt;
    &lt;data key="BUSINESS_DAY"&gt;2010-01-22&lt;/data&gt;
    &lt;data key="WORKSTATION_ID"&gt;003&lt;/data&gt;
    &lt;data key="TRANSACTION_ID"&gt;1234&lt;/data&gt;
    &lt;data key="AMOUNT"&gt;21.33&lt;/data&gt;  
  &lt;/row&gt;
&lt;/sale&gt;
            </pre><p>     
            To publish JMS messages during routing
            the same pattern is valid, with the exception that the extension point would be the XmlPublisherDataRouter and the router 
            would be configured by setting the <code class="literal">router_type</code> of a <a href="#table_router" title="A.14.&nbsp;ROUTER">ROUTER</a> to the Spring bean
            name of the registered extension point.  Of course, the router would need to be linked through <a href="#table_trigger_router" title="A.15.&nbsp;TRIGGER_ROUTER">TRIGGER_ROUTER</a>s
            to each <a href="#table_trigger" title="A.13.&nbsp;TRIGGER">TRIGGER</a>  table that needs published.                  
        </p>
    </div>     
<div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="deployment-options"></a>5.4.&nbsp;Deployment Options</h2></div></div></div>
        
        <p>An instance of SymmetricDS can be deployed in several ways:</p>
        <div class="itemizedlist"><ul type="disc"><li>
                <p>Web application archive (WAR) deployed to an application server</p>
                <p>
                    This option means packaging a WAR file and deploying to your favorite
                    web server, like Apache Tomcat.  It's a little more work, but you
                    can configure the web server to do whatever you need.  SymmetricDS can also 
                    be embedded in an existing web application, if desired.
                </p>                
            </li><li>
                <p>Standalone service that embeds Jetty web server</p>
                <p>
                    This option means running the <span class="emphasis"><em>sym</em></span> command line, which launches the built-in Jetty web server.  
                    This is a simple option because it is already provided, but you lose the flexibility to configure 
                    the web server any further.
                </p>
            </li><li>
                <p>Embedded as a Java library in an application</p>
                <p>
                    This option means you must write a wrapper Java program that runs
                    SymmetricDS.  You would probably use Jetty web server, which is also embeddable.
                    You could bring up an embedded database like Derby or H2.  You could configure the
                    web server, database, or SymmetricDS to do whatever you needed, but it's also
                    the most work of the three options discussed thus far.
                </p>
            </li><li>
                <p>Grails Application</p>
                <p>                
                    A <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://grails.org/plugin/symmetricds" target="_top">Grails SymmetricDS plugin</a> is 
                    provided at the default Grails plugin site.  This option ends up being a WAR deployment, but allows 
                    for the use of the Grails SDK for configuring and building the deployment.  The plugin also
                    provides Gorm (Hibernate) access to many of the core database tables.   
                </p>
            </li></ul></div>
        <p>
            The deployment model you choose depends on how much flexibility you need versus how easy you
            want it to be.  Both Jetty and Tomcat are excellent, scalable web servers that
            compete with each other and have great performance.  Most people choose either
            the <span class="emphasis"><em>Standalone</em></span> or <span class="emphasis"><em>Web Archive</em></span> with Tomcat 5.5 or 6.  Deploying to Tomcat
            is a good middle-of-the-road decision that requires a little more work for more flexibility.
        </p>
        <p>Next, we will go into a little more detail on the first three deployment options listed above.</p>
        <div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="deployment-options-web-archive"></a>5.4.1.&nbsp;Web Archive</h3></div></div></div>
            
            <p>
                As a web application archive, a WAR is deployed to an application server,
                such as Tomcat, Jetty, or JBoss.  The structure of the archive will have a <code class="literal">web.xml</code>
                file in the <code class="literal">WEB-INF</code> folder, an appropriately configured <code class="filename">symmetric.properties</code> file in the <code class="literal">WEB-INF/classes</code> folder,
                and the required JAR files in the <code class="literal">WEB-INF/lib</code> folder.
            </p>
            <div class="mediaobject"><img src="images/symmetric_war.gif"></div>
            <p>
                A war file can be generated using the standalone installation's sym utility and the 
                --create-war option.  The command requires the name of the war file to generate.  It 
                essentially packages up the web directory, the conf directory and includes an optional
                properties file.  Note that if a properties file is included, it will be copied to 
                WEB-INF/classes/symmetric.properties.  This is the same location conf/symmetric.properties
                would have been copied to.  The generated war distribution uses the same web.xml as the standalone
                deployment. 
            </p>
            <p>
                <span><strong class="command">../bin/sym -p my-symmetric-ds.properties --create-war /some/path/to/symmetric-ds.war</strong></span>
            </p>
            <p>
                The <code class="literal">web.base.servlet.path</code> property in <code class="filename">symmetric.properties</code> can be set if the SymmetricServlet needs to
                coexist with other Servlets.  By default, the value is blank.  If you set it to, say, <code class="literal">web.base.servlet.path=sync</code> for exmaple,
                <code class="literal">registration.url</code> would be <code class="literal">http://server:port/sync</code>.
            </p>            
        </div>
        <div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="deployment-options-standalone"></a>5.4.2.&nbsp;Standalone</h3></div></div></div>
            
            <p>
                A standalone service can use the <code class="literal">sym</code> command line options to start
                a server.  An embedded instance of Jetty is used to service web
                requests for all the servlets.
            </p>
            <pre class="programlisting">/symmetric/bin/sym --properties root.properties --port 8080 --server
</pre>
            <p>
                This example starts the SymmetricDS server on port 8080 with the startup
                properties found in the <code class="filename">root.properties</code> file.
            </p>
        </div>
        <div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="deployment-options-embedded"></a>5.4.3.&nbsp;Embedded</h3></div></div></div>
            
            <p>
                A Java application with the SymmetricDS Java Archive (JAR) libraries in its
                classpath can use the <code class="literal">SymmetricWebServer</code> to start the server.
            </p>
            <pre class="programlisting">
import org.jumpmind.symmetric.SymmetricWebServer;

public class StartSymmetricEngine {

    /**
     * Start an engine that is configured by two properties files. One is
     * packaged with the application and contains overridden properties that are
     * specific to the application. The other is found in the application's
     * working directory. It can be used to setup environment specific
     * properties.
     */
    public static void main(String[] args) throws Exception {
        
        // Specify the properties file and the web directory
        SymmetricWebServer node = new SymmetricWebServer(
                                   "classpath://my-application.properties", "web");
                             
        // indicates that the start() method should return      
        node.setJoin(false);

        // this will create the database, sync triggers, start jobs running
        node.start(8080);
        
        // this will stop the node
        node.stop();
    }   

}</pre>
            <p>
                This example starts the SymmetricDS server on port 8080 with a startup properties
                file that is found on the application's classpath to provide properties that 
                override the default values.  Note if the properties file should be found on the
                file system the property file name would be prepended with file://.
            </p>
            <p>
                The second parameter to the web server is the name of the directory where the web.xml
                for the application can be found.  You may use the web.xml from the standalone 
                deployment.  In this example you would place the web.xml in the web/WEB-INF/ directory.
            </p>
        </div>
    </div> 
    
    <div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="running-service"></a>5.5.&nbsp;Running SymmetricDS as a Service</h2></div></div></div>
    
        <p>
    SymmetricDS can be configured to start and run as a service in both Windows and *nix platforms.
    </p>
    <div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="running-service-windows"></a>5.5.1.&nbsp;Running as a Windows Service</h3></div></div></div>
        
        <p>
            SymmetricDS uses the
            <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://wrapper.tanukisoftware.org/" target="_top">Java Service Wrapper</a>
            product from Tanuki Software to run in the background as a Windows system service.
            The Java Service Wrapper executable is named <code class="filename">sym_service.exe</code>
            so it can be easily identified from a list of running processes.
            To install the service, use the provided script:
            </p><pre class="programlisting">bin\install_service.bat</pre><p>
        </p>
        <p>
            The service configuration is found in <code class="filename">conf/sym_service.conf</code>.
            Edit this file if you want to change the default port number (8080), initial memory size
            (256 MB), log file size (10 MB), or other settings.
            When started, the server will look in the <code class="filename">conf</code> directory
            for the <code class="filename">symmetric.properties</code> file
            and the  <code class="filename">log4j.xml</code> file.
            Logging for standard out, error, and application are written to the
            <code class="filename">logs</code> directory.
        </p>
        <p>
            Most configuration changes do not require the service to be re-installed. 
            To un-install the service, use the provided script:
            </p><pre class="programlisting">bin\uninstall_service.bat</pre><p>
        </p>
        <p>
            Use the <span><strong class="command">net</strong></span> command to start and stop the service: 
            </p><pre class="programlisting">net start symmetric
net stop symmetric</pre><p>
        </p>
    </div>
    <div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="running-service-unix"></a>5.5.2.&nbsp;Running as a *nix Service</h3></div></div></div>
        
        <p>
            SymmetricDS uses the
            <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://wrapper.tanukisoftware.org/" target="_top">Java Service Wrapper</a>
            product from Tanuki Software to run in the background as a Unix system service.
            The Java Service Wrapper executable is named <code class="filename">sym_service</code>
            so it can be easily identified from a list of running processes.
            The service configuration is found in <code class="filename">conf/sym_service.conf</code>.
            Edit this file if you want to change the default port number (8080), initial memory size
            (256 MB), log file size (10 MB), or other settings.
        </p>
        <p>
            An init script is provided to work with standard Unix run configuration levels.
            The <code class="filename">sym_service.initd</code> file follows the
            Linux Standard Base specification, which should work on many systems, including
            Fedora and Debian-based distributions.  
            To install the script, copy it into the system init directory:
        </p>
        <p>
            </p><pre class="programlisting">cp bin/sym_service.initd /etc/init.d/sym_service</pre><p>
        </p>
        <p>
            Edit the init script to set the SYM_HOME variable to the directory
            where SymmetricDS is located.  The init script calls the
            <code class="filename">sym_service</code> executable.
        </p>
        <p>
            To enable the service to run automatically when the system is started:
            </p><pre class="programlisting">/sbin/chkconfig --add sym_service</pre><p>
        </p>
        <p>
            To disable the service from running automatically:
            </p><pre class="programlisting">/sbin/chkconfig --del sym_service</pre><p>
        </p>
        <p>
            On Suse Linux install the service by calling:
            </p><pre class="programlisting">/usr/lib/lsb/install_initd sym_service</pre><p>
            Remove the service by calling:
            </p><pre class="programlisting">/usr/lib/lsb/remove_initd sym_service</pre><p>
        </p>          
        <p>
            Use the <span><strong class="command">service</strong></span> command to start, stop, and query
            the status of the service: 
            </p><pre class="programlisting">/sbin/service sym_service start
/sbin/service sym_service stop
/sbin/service sym_service status</pre><p>
        </p>  
        <p>
            Alternatively, call the init.d script directly:
            </p><pre class="programlisting">/etc/init.d/sym_service start
/etc/init.d/sym_service stop
/etc/init.d/sym_service status
            </pre><p>
        </p>    
    </div>
    </div>
        <div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="clustering"></a>5.6.&nbsp;Clustering</h2></div></div></div>
        
        <p>
        A single SymmetricDS node may be clustered across a series of instances, creating a web farm.  A node might be clustered to provide load balancing and failover, for example.
        </p>
        <p>
        When clustered, a hardware load balancer is typically used
        to round robin client requests to the cluster.  The load balancer should be configured for stateless connections.  
        Also, the <code class="literal">sync.url</code> (discussed in <a href="#configuration-node-properties" title="4.1.&nbsp;Node Properties">Section&nbsp;4.1, &#8220;Node Properties&#8221;</a>)
        SymmetricDS property should be set to the URL of the load balancer.  
        </p>
        <p>
        If the cluster will be running any of the SymmetricDS jobs, then the <code class="literal">cluster.lock.enabled</code> property should be set to <code class="literal">true</code>. 
        By setting this property to true, SymmetricDS will use a row in the <a href="#table_lock" title="A.26.&nbsp;LOCK">LOCK</a> table as a semaphore to make sure that only one instance at a time
        runs a job.  When a lock is acquired, a row is updated in the lock table with the time of the lock and the server id of the locking job.  The lock time is set back to null
        when the job is finished running.  Another instance of SymmetricDS cannot aquire a lock until the locking instance (according to the server id) releases the lock.  If an 
        instance is terminated while the lock is still held, an instance with the same server id is allowed to reaquire the lock.  If the locking instance remains down, the lock can be 
        broken after a period of time, specified by the <code class="literal">cluster.lock.timeout.ms</code> property, has expired.  Note that if the job is still running and the lock
        expires, two jobs could be running at the same time which could cause database deadlocks. 
        </p>
        <p>
        By default, the locking server id is the hostname of the server.  If two clustered instances are running on the same server, then the <code class="literal">cluster.server.id</code> property 
        may be set to indicate the name that the instance should use for its server id.
        </p>
        <p>
        When deploying SymmetricDS to an application server like Tomcat or JBoss, no special session clustering needs to be configured for the application server.  
        </p>
    </div>   
      <div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="encrypted-passwords"></a>5.7.&nbsp;Encrypted Passwords</h2></div></div></div>
        
        <p>
            The <code class="literal">db.user</code> and <code class="literal">db.password</code> properties will accept encrypted text, which protects
            against casual observation.  The text is prefixed with <code class="literal">enc:</code> to indicate
            that it is encrypted.  To encrypt text, use the following command:

            </p><pre class="programlisting">sym -e secret</pre><p>

            The text is encrypted using a secret key named "sym.secret" that is retrieved from a keystore file. 
            By default, the keystore is located in <code class="filename">security/keystore</code>.
            The location and filename of the keystore can be overridden by setting the "sym.keystore.file" system property.
            If the secret key is not found, the system will generate and install a secret key for use with Triple DES cipher.
        </p>
        <p>
            Generate a new secret key for encryption using the <code class="literal">keytool</code>
            command that comes with the JRE.  If there is an existing key in the keystore, first remove it:

            </p><pre class="programlisting">keytool -keystore keystore -storepass changeit -storetype jceks \
   -alias sym.secret -delete</pre><p>

            Then generate a secret key, specifying a cipher algorithm and key size.
            Commonly used algorithms that are supported include aes, blowfish, desede, and rc4.

            </p><pre class="programlisting">keytool -keystore keystore -storepass changeit -storetype jceks \
   -alias sym.secret -genseckey -keyalg aes -keysize 128</pre><p>

            If using an alternative provider, place the provider JAR file in the SymmetricDS <code class="filename">lib</code> folder. 
            The provider class name should be installed in the JRE security properties or specified on the command line.
            To install in the JRE, edit the JRE <code class="filename">lib/security/java.security</code> file
            and set a <code class="literal">security.provider.i</code> property for the provider class name.
            Or, the provider can be specified on the command line instead.
            Both <code class="literal">keytool</code> and <code class="literal">sym</code> accept command line arguments for the provider class name.
            For example, using the Bouncy Castle provider, the command line options would look like:

            </p><pre class="programlisting">keytool -keystore keystore -storepass changeit -storetype jceks \
   -alias sym.secret -genseckey -keyalg idea -keysize 56 \
   -providerClass org.bouncycastle.jce.provider.BouncyCastleProvider \
   -providerPath ..\lib\bcprov-ext.jar</pre><p>
            </p><pre class="programlisting">sym -jcep org.bouncycastle.jce.provider.BouncyCastleProvider -e secret</pre><p>

            To customize the encryption, write a Java class that implements the ISecurityService or extends the default SecurityService, and place
            the class on the classpath in either <code class="filename">lib</code> or
            <code class="filename">web/WEB-INF/lib</code> folders.
            Then, in the <code class="filename">symmetric.properties</code> specify your class name for the security service.

            </p><pre class="programlisting">security.service.class.name=org.jumpmind.symmetric.service.impl.SecurityService</pre><p>

            Remember to specify your properties file when encrypting passwords, so it will use your custom ISecurityService.

            </p><pre class="programlisting">sym -p symmetric.properties -e secret</pre><p>
        </p>
    </div>
    <div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="secure-transport"></a>5.8.&nbsp;Secure Transport</h2></div></div></div>
        
        <p>
            By specifying the "https" protocol for a URL, SymmetricDS will communicate over
            Secure Sockets Layer (SSL) for an encrypted transport.  The following properties
            need to be set with "https" in the URL:
            </p><div class="variablelist"><dl><dt><span class="term">
                        <span><strong class="command">sync.url</strong></span>
                    </span></dt><dd>
                        <p>
                            This is the URL of the current node, so if you want to force other
                            nodes to communicate over SSL with this node, you specify "https" in the URL.
                        </p>
                    </dd><dt><span class="term">
                        <span><strong class="command">registration.url</strong></span>
                    </span></dt><dd>
                        <p>
                            This is the URL where the node will connect for registration when it 
                            first starts up.  To protect the registration with SSL, you specify
                            "https" in the URL.
                        </p>
                    </dd></dl></div><p>
            For incoming HTTPS connections, SymmetricDS depends on the webserver where
            it is deployed, so the webserver must be configured for HTTPS.
            As a standalone deployment, the "sym" launcher command provides options for 
            enabling HTTPS support.
        </p>
        <div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="secure-transport-sym"></a>5.8.1.&nbsp;Sym Launcher</h3></div></div></div>
            
            <p>
                The "sym" launch command uses Jetty as an embedded web server.
                Using command line options, the web server can be told to listen for 
                HTTP, HTTPS, or both.
            </p>
            <p>
                <span><strong class="command">sym --port 8080 --server</strong></span>
            </p>
            <p>
                <span><strong class="command">sym --secure-port 8443 --secure-server</strong></span>
            </p>
            <p>
                <span><strong class="command">sym --port 8080 --secure-port 8443 --mixed-server</strong></span>
            </p>
        </div>
        <div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="secure-transport-tomcat"></a>5.8.2.&nbsp;Tomcat</h3></div></div></div>
            
            <p>
                If you deploy SymmetricDS to Apache Tomcat, it can be secured by editing the
                <code class="filename">TOMCAT_HOME/conf/server.xml</code>
                configuration file.  There is already a line that can be uncommented
                and changed to the following:
                
                </p><pre class="programlisting">
&lt;Connector port="8443" protocol="HTTP/1.1" SSLEnabled="true" 
  maxThreads="150" scheme="https" secure="true" 
  clientAuth="false" sslProtocol="TLS"
  keystoreFile="/symmetric-ds-1.x.x/security/keystore" /&gt;</pre><p>
            </p>
        </div>
        <div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="secure-transport-keystore"></a>5.8.3.&nbsp;Keystores</h3></div></div></div>
            
            <p>
                When SymmetricDS connects to a URL with HTTPS, Java checks the validity of the
                certificate using the built-in trusted keystore located at
                <code class="filename">JRE_HOME/lib/security/cacerts</code>.
                The "sym" launcher command overrides the trusted keystore to use its own
                trusted keystore instead, which is located at
                <code class="filename">security/cacerts</code>.
                This keystore contains the certificate aliased as "sym" for use in testing
                and easing deployments.                
                The trusted keystore can be overridden
                by specifying the <code class="literal">javax.net.ssl.trustStore</code> system property.
            </p>
            <p>
                When SymmetricDS is run as a secure server with the "sym" launcher,
                it accepts incoming requests using the key installed in the keystore
                located at
                <code class="filename">security/keystore</code>.
                The default key is provided for convenience of testing, but should be
                re-generated for security.
            </p>
        </div>
        <div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="secure-transport-keys"></a>5.8.4.&nbsp;Generating Keys</h3></div></div></div>
            
            <p>
                To generate new keys and install a server certificate, use the
                following steps:
            </p>
            <div class="procedure"><ol type="1"><li>
                    <p>
                        Open a command prompt and navigate to the
                        <code class="filename">security</code>
                        subdirectory of your SymmetricDS installation on the server to which
                        communication will be secured (typically the "root" or "central office" server).
                    </p>
                </li><li>
                    <p>Delete the old key pair and certificate.</p>
                    <p>
                        <span><strong class="command">keytool -keystore keystore -delete -alias sym</strong></span>
                    </p>
                    <p>
                        <span><strong class="command">keytool -keystore cacerts -delete -alias sym</strong></span>
                    </p>
                    <pre class="programlisting">Enter keystore password:  changeit</pre>
                </li><li>
                    <p>Generate a new key pair.  Note that the first name/last name (the "CN") must match
                    the fully qualified hostname the client will be using to communcate to the server.</p>
                    <p>
                        <span><strong class="command">keytool -keystore keystore -alias sym -genkey -keyalg RSA -validity 10950</strong></span>
                    </p>
                    <pre class="programlisting">
Enter keystore password:  changeit
What is your first and last name?
  [Unknown]:  localhost
What is the name of your organizational unit?
  [Unknown]:  SymmetricDS
What is the name of your organization?
  [Unknown]:  JumpMind
What is the name of your City or Locality?
  [Unknown]:
What is the name of your State or Province?
  [Unknown]:
What is the two-letter country code for this unit?
  [Unknown]:
Is CN=localhost, OU=SymmetricDS, O=JumpMind, L=Unknown, ST=Unknown, C=Unknown
correct?
  [no]:  yes

Enter key password for &lt;sym&gt;
        (RETURN if same as keystore password):</pre>
                </li><li>
                    <p>Export the certificate from the private keystore.</p>
                    <p>
                        <span><strong class="command">keytool -keystore keystore -export -alias sym -rfc -file sym.cer</strong></span>
                    </p>
                </li><li>
                    <p>Install the certificate in the trusted keystore.</p>
                    <p>
                        <span><strong class="command">keytool -keystore cacerts -import -alias sym -file sym.cer</strong></span>
                    </p>
                </li><li>
                    <p>Copy the cacerts file that is generated by this process to
                    the <code class="filename">security</code> directory of each client's SymmetricDS installation.</p>
                </li></ol></div>
        </div>
    </div>
    <div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="basic-auth"></a>5.9.&nbsp;Basic Authentication</h2></div></div></div>
        
        <p>
            SymmetricDS supports basic authentication for client and server nodes. 
            To configure a client node to use basic authentication when communicating with a server node, 
            specify the following startup parameters:
        </p>
            <div class="variablelist"><dl><dt><span class="term">
                        <span><strong class="command">http.basic.auth.username</strong></span>
                    </span></dt><dd>
                        <p>
                            username for client node basic authentication.
                            [&nbsp;Default:&nbsp;]
                        </p>
                    </dd><dt><span class="term">
                        <span><strong class="command">http.basic.auth.password</strong></span>
                    </span></dt><dd>
                        <p>
                            password for client node basic authentication.
                            [&nbsp;Default:&nbsp;]
                        </p>
                    </dd></dl></div>
        <p>
            The SymmetricDS Standalone and Embedded Server also support basic authentication.
            This feature is enabled by specifying the basic authentication username and
            password using the following startup parameters:
        </p>
            <div class="variablelist"><dl><dt><span class="term">
                        <span><strong class="command">embedded.webserver.basic.auth.username</strong></span>
                    </span></dt><dd>
                        <p>
                            username for basic authentication for an embedded server
                            or standalone server node.
                            [&nbsp;Default:&nbsp;]
                        </p>
                    </dd><dt><span class="term">
                        <span><strong class="command">embedded.webserver.basic.auth.password</strong></span>
                    </span></dt><dd>
                        <p>
                            password for basic authentication for an embedded server
                            or standalone server node.
                            [&nbsp;Default:&nbsp;]
                        </p>
                    </dd></dl></div>
        <p>
            If the server node is deployed to Tomcat or another application server as a WAR or EAR file, then 
            basic authentication is setup with the standard configuration in the WEB.xml file. 
        </p>
    </div>
    <div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="multi-server"></a>5.10.&nbsp;Multi-Server Mode</h2></div></div></div>
        
        <p>
            SymmetricDS supports running multiple SymmetricDS instances that leverage the same web server in the same
            process.  This mode can be turned on in the <code class="code">web/WEB-INF/web.xml</code> file.  By default, <code class="code">multiServerMode</code>
            is turned off. 
        </p>
            <pre class="programlisting">
    &lt;context-param&gt;
        &lt;param-name&gt;multiServerMode&lt;/param-name&gt;
        &lt;param-value&gt;true&lt;/param-value&gt;
    &lt;/context-param&gt;
</pre>
        <p>
            When <code class="code">multiServerMode</code> is turned on, SymmetricDS will initialize itself with an instance of 
            a node for each properties file found in the <code class="code">engines</code> directory.  Each node will inherit 
            common properties from <code class="code">conf/symmetric.properties</code>.   Each properties file must specify the 
            minimum required properties to define a single node.  In addition, the properties file is required to also specify
            a property, <code class="code">engine.name</code>, that provides a unique name for the node's engine.  
        </p>        
    </div>    
</div>
    <div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="extensions"></a>Chapter&nbsp;6.&nbsp;Extending SymmetricDS</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="#extensions-parameter-filter">6.1. IParameterFilter</a></span></dt><dt><span class="section"><a href="#extensions-data-loader-filter">6.2. IDataLoaderFilter</a></span></dt><dt><span class="section"><a href="#extensions-table-column-filter">6.3. ITableColumnFilter</a></span></dt><dt><span class="section"><a href="#extensions-batch-listener">6.4. IBatchListener</a></span></dt><dt><span class="section"><a href="#extensions-acknowledge-event-listener">6.5. IAcknowledgeEventListener</a></span></dt><dt><span class="section"><a href="#extensions-reload-listener">6.6. IReloadListener</a></span></dt><dt><span class="section"><a href="#extensions-extractor-filter">6.7. IExtractorFilter</a></span></dt><dt><span class="section"><a href="#extensions-sync-url-extension">6.8. ISyncUrlExtension</a></span></dt><dt><span class="section"><a href="#extensions-node-id-generator">6.9. INodeIdGenerator</a></span></dt><dt><span class="section"><a href="#extensions-trigger-creation-listener">6.10. ITriggerCreationListener</a></span></dt><dt><span class="section"><a href="#extensions-batch-algorithm">6.11. IBatchAlgorithm</a></span></dt><dt><span class="section"><a href="#extensions-data-router">6.12. IDataRouter</a></span></dt><dt><span class="section"><a href="#extensions-heartbeat-listener">6.13. IHeartbeatListener</a></span></dt><dt><span class="section"><a href="#extensions-offline-client-listener">6.14. IOfflineClientListener</a></span></dt><dt><span class="section"><a href="#extensions-offline-server-listener">6.15. IOfflineServerListener</a></span></dt><dt><span class="section"><a href="#extensions-node-password">6.16. INodePasswordFilter</a></span></dt></dl></div>
    
     
      
        <p>
             SymmetricDS may be extended via a plug-in like architecture where extension point interfaces 
             may be implemented by a custom class and registered with the synchronization engine.  All supported extension 
             points extend the IExtensionPoint interface.  The currently available extension points are documented in the following sections.  
        </p>
        <p>
             When the synchronization engine starts up, a Spring 
             post processor searches the Spring ApplicationContext for any registered classes which implement 
             IExtensionPoint.  An IExtensionPoint designates whether it should be auto registered or not.  If the extension point 
             is to be auto registered then the post processor registers the known interface with the appropriate service.
        </p>
        <p>
             The INodeGroupExtensionPoint interface may be optionally implemented to designate that auto registered 
             extension points should only be auto registered with specific node groups.
             </p><pre class="programlisting">/**
 * Only apply this extension point to the 'root' node group.
 */
 public String[] getNodeGroupIdsToApplyTo() {
     return new String[] { "root" };
 }
</pre><p>             
        </p>
        <p>
             SymmetricDS will look for Spring configured extensions in the application Classpath by importing any Spring 
             XML configuration files found matching the following pattern: <code class="literal">META-INF/services/symmetric-*-ext.xml</code>.  When packaged in
             a jar file the <code class="literal">META-INF</code> directory should be at the root of the jar file.  When packaged in a war file, the <code class="literal">META-INF</code> directory
             should be in the <code class="literal">WEB-INF/classes</code> directory.
        </p>
        <div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="extensions-parameter-filter"></a>6.1.&nbsp;IParameterFilter</h2></div></div></div>
            
            <p>
                Parameter values can be specified in code using a parameter filter.  Note that there can be only one parameter
                filter per engine instance.  The IParameterFilter replaces the deprecated IRuntimeConfig from prior releases.
                </p><pre class="programlisting">public class MyParameterFilter 
    implements IParameterFilter, INodeGroupExtensionPoint {

    /**
     * Only apply this filter to stores
     */
    public String[] getNodeGroupIdsToApplyTo() {
        return new String[] { "store" };
    }

    public String filterParameter(String key, String value) {
        // look up a store number from an already existing properties file.
        if (key.equals(ParameterConstants.EXTERNAL_ID)) {
            return StoreProperties.getStoreProperties().
              getProperty(StoreProperties.STORE_NUMBER);
        } 
        return value;
    }

    public boolean isAutoRegister() {
        return true;
    }

}</pre><p> 
            </p>
        </div>        
        <div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="extensions-data-loader-filter"></a>6.2.&nbsp;IDataLoaderFilter</h2></div></div></div>
                     
            <p>
                Data can be filtered as it is loaded into the target database.  It can also be
                filtered when
                it is extracted from the source database.
            
                As data is loaded into the target database, a filter can change the
                data in a column or save it somewhere else.  It can also specify by the
                return value of the function call that the data loader should continue on 
                and load the data (by returning true) or ignore it (by returning false). One 
                possible use of the filter might be to
                route credit card data to a secure database and blank it out as it loads 
                into a less-restricted reporting database.
            </p>
            <p>
                An IDataLoaderContext is passed to each of the callback methods.  A new 
                context is created for each synchronization.  The context provides methods to 
                lookup column indexes by column name, get table meta data, and access to 
                old data if the <code class="literal">sync_column_level</code> flag is enabled.  The context also provides a means 
                to share data during a synchronization between different rows of data that are 
                committed in a  database transaction and are in the same channel.  It does so by 
                providing a context cache which can be populated by the extension point.
            </p>  
            <p>
                Many times the IDataLoaderFilter will be combined with the IBatchListener.  The 
                XmlPublisherFilter (in the <code class="literal">org.jumpmind.symmetric.ext</code> package) is a good example 
                of using the combination of the two extension points in order to create XML messages 
                to be published to JMS.
            </p>          
            <p>
                A class implementing the IDataLoaderFilter interface is injected onto the
                DataLoaderService in order to receive callbacks when data is inserted,
                updated, or deleted.
                
                </p><pre class="programlisting">public MyFilter implements IDataLoaderFilter {
                
    public boolean isAutoRegister() {
        return true;
    }
 
    public boolean filterInsert(IDataLoaderContext context,
        String[] columnValues) {
        return true;
    }
    
    public boolean filterUpdate(IDataLoaderContext context, 
        String[] columnValues, String[] keyValues) {
        return true;
    }
    
    public void filterDelete(IDataLoaderContext context, 
        String[] keyValues) {
        return true;
    }

}</pre><p>
            </p>
            <p>
                The filter class is specified as a Spring-managed bean.  A custom Spring XML file
                is specified as follows in a jar at <code class="literal">META-INF/services/symmetric-myfilter-ext.xml</code>.
                
                </p><pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:context="http://www.springframework.org/schema/context"
    xsi:schemaLocation="http://www.springframework.org/schema/beans 
           http://www.springframework.org/schema/beans/spring-beans-3.0.xsd
           http://www.springframework.org/schema/context
           http://www.springframework.org/schema/context/spring-context-3.0.xsd"&gt;
 
    &lt;bean id="myFilter" class="com.mydomain.MyFilter"/&gt;
     
&lt;/beans&gt;</pre><p>
            </p>
        </div>
        <div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="extensions-table-column-filter"></a>6.3.&nbsp;ITableColumnFilter</h2></div></div></div>
            
            <p>
            Implement this extension point to filter out specific columns from
            use by the dataloader. Only one column filter may be added per target table.
            </p>
        </div>
        <div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="extensions-batch-listener"></a>6.4.&nbsp;IBatchListener</h2></div></div></div>
            
            <p>
            This extension point is called whenever a batch has completed loading but before
            the transaction has committed.
            </p>
        </div>
        <div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="extensions-acknowledge-event-listener"></a>6.5.&nbsp;IAcknowledgeEventListener</h2></div></div></div>
            
            <p>
            Implement this extension point to receive callback events when a batch is acknowledged.  
            The callback for this listener happens at the point of extraction.
            </p>
        </div>                
        <div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="extensions-reload-listener"></a>6.6.&nbsp;IReloadListener</h2></div></div></div>
            
            <p>
            Implement this extension point to listen in and take
            action before or after a reload is requested for a Node.  The callback for this listener
            happens at the point of extraction.
            </p>
        </div>                
        <div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="extensions-extractor-filter"></a>6.7.&nbsp;IExtractorFilter</h2></div></div></div>
            
            <p>
            This extension point is called after data has been extracted, but before it has been streamed.  It
            has the ability to inspect each row of data to take some action and indicate, if necessary, that the
            row should not be streamed.
            </p>
        </div>
        <div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="extensions-sync-url-extension"></a>6.8.&nbsp;ISyncUrlExtension</h2></div></div></div>
            
            <p>
             This extension point is used to select an appropriate URL based on
             the URI provided in the <code class="literal">sync_url</code> column of <code class="literal">sym_node</code>.
            </p>
            <p>
             To use this extension point configure the sync_url for a node with the
             protocol of ext://beanName. The beanName is the name you give the extension
             point in the extension xml file.
            </p>
        </div>        
        <div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="extensions-node-id-generator"></a>6.9.&nbsp;INodeIdGenerator</h2></div></div></div>
            
            <p>
             This extension point allows SymmetricDS users to implement their own algorithms for how 
             node ids and passwords are generated or selected during the registration process.  There may be 
             only one node generator per SymmetricDS instance.
            </p>
        </div>
        <div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="extensions-trigger-creation-listener"></a>6.10.&nbsp;ITriggerCreationListener</h2></div></div></div>
            
            <p>
            Implement this extension point to get status callbacks during trigger creation.
            </p>
        </div>       
        <div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="extensions-batch-algorithm"></a>6.11.&nbsp;IBatchAlgorithm</h2></div></div></div>
            
            <p>
            Implement this extension point and set the name of the Spring bean on the batch_algorithm column of the Channel table to use.
            This extension point gives fine grained control over how a channel is batched.
            </p>
        </div>                   
        <div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="extensions-data-router"></a>6.12.&nbsp;IDataRouter</h2></div></div></div>
            
            <p>
            Implement this extension point and set the name of the Spring bean on the router_type column
            of the Router table to use.  This extension point gives the ability to programatically decide
            which nodes data should be routed to.
            </p>
        </div>  
        <div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="extensions-heartbeat-listener"></a>6.13.&nbsp;IHeartbeatListener</h2></div></div></div>
            
            <p>
            Implement this extension point to get callbacks during the heartbeat job.
            </p>
        </div>
        <div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="extensions-offline-client-listener"></a>6.14.&nbsp;IOfflineClientListener</h2></div></div></div>
            
            <p>
            Implement this extension point to get callbacks for offline events on client nodes.
            </p>
        </div>
        <div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="extensions-offline-server-listener"></a>6.15.&nbsp;IOfflineServerListener</h2></div></div></div>
            
            <p>
            Implement this extension point to get callbacks for offline events detected on a server node during monitoring of client nodes.
            </p>
        </div>
        <div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="extensions-node-password"></a>6.16.&nbsp;INodePasswordFilter</h2></div></div></div>
            
            <p>
            Implement this extension point to intercept the saving and rendering of the node password.
            </p>
        </div>        
    </div>
    <div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="administration"></a>Chapter&nbsp;7.&nbsp;Administration</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="#solving-synchronization-issues">7.1. Solving Synchronization Issues</a></span></dt><dd><dl><dt><span class="section"><a href="#solving-synchronization-issues-analysis">7.1.1. Analyzing the Issue</a></span></dt><dt><span class="section"><a href="#solving-synchronization-issues-resolution">7.1.2. Resolving the Issue</a></span></dt></dl></dd><dt><span class="section"><a href="#changing-triggers">7.2. Changing Triggers</a></span></dt><dt><span class="section"><a href="#resync-data">7.3. Re-synchronizing Data</a></span></dt><dt><span class="section"><a href="#changing-configuration">7.4. Changing Configuration</a></span></dt><dt><span class="section"><a href="#logging">7.5. Logging Configuration</a></span></dt><dt><span class="section"><a href="#admin-jmx">7.6. Java Management Extensions</a></span></dt><dt><span class="section"><a href="#temporary-files">7.7. Temporary Files</a></span></dt><dt><span class="section"><a href="#purge">7.8. Database Purging</a></span></dt></dl></div>
    
    
    <div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="solving-synchronization-issues"></a>7.1.&nbsp;Solving Synchronization Issues</h2></div></div></div>
        
       
       <p>
       By design, whenever SymmetricDS encounters an issue with a synchronization, the batch containing the error is marked as being in
       an error state, and all subsequent batches <span class="emphasis"><em>for that particular channel to that particular node</em></span> are held and not
       synchronized until the error batch is resolved.  SymmetricDS will retry the batch in error until the situation creating the
       error is resolved (or the data for the batch itself is changed).
       </p>
       
        <div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="solving-synchronization-issues-analysis"></a>7.1.1.&nbsp;Analyzing the Issue</h3></div></div></div>
        
       
       <p>
       The first step in analyzing the cause of a failed batch is to locate information about the data in the batch, starting with  
       either <a href="#table_outgoing_batch" title="A.24.&nbsp;OUTGOING_BATCH">OUTGOING_BATCH</a> or <a href="#table_incoming_batch" title="A.25.&nbsp;INCOMING_BATCH">INCOMING_BATCH</a>.
       We'll use outgoing batches for the examples below.  To locate batches in error, use:
       </p><pre class="programlisting">select * from sym_outgoing_batch where error_flag=1;</pre><p>       
       Several useful pieces of information are available from this query:
       </p><div class="itemizedlist"><ul type="disc"><li>
       The batch number of the failed batch, available in column <code class="literal">BATCH_ID</code>.
       </li><li>
       The node to which the batch is being sent, available in column <code class="literal">NODE_ID</code>.
       </li><li>
       The channel to which the batch belongs, available in column <code class="literal">CHANNEL_ID</code>. 
       All subsequent batches on this channel to this node will be held until the error condition is resolved.
       </li><li>
       The specific data id in the batch which is causing the failure, available in column <code class="literal">FAILED_DATA_ID</code>.
       </li><li>
       Any SQL message, SQL State, and SQL Codes being returned during the synchronization attempt, available in columns <code class="literal">SQL_MESSAGE</code>,
       <code class="literal">SQL_STATE</code>, and <code class="literal">SQL_CODE</code>, respectively.
       </li></ul></div><p>
       </p>
       <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3>
       Using the <code class="literal">error_flag</code> on the batch table, as shown above, is more reliable than using the
       <code class="literal">status</code> column.  The status column can change from 'ER' to a different status temporarily as
       the batch is retried.
       </div>
       <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3>The query above will also show you any recent batches that
       were originally in error and were changed to be manually skipped.  See the end of  <a href="#solving-synchronization-issues-resolution" title="7.1.2.&nbsp;Resolving the Issue">Section&nbsp;7.1.2, &#8220;Resolving the Issue&#8221;</a> for more details.
       </div>
       <p>
       To get a full picture of the batch, you can query for information representing the complete 
       list of all data changes associated with the failed batch by joining
       <a href="#table_data" title="A.20.&nbsp;DATA">DATA</a> and  <a href="#table_data_event" title="A.23.&nbsp;DATA_EVENT">DATA_EVENT</a>, such as:
       </p><pre class="programlisting">select * from sym_data where data_id in 
        (select data_id from sym_data_event where batch_id='XXXXXX');</pre><p> 
       where XXXXXX is the batch id of the failing batch.
       </p>
       <p>
       This query returns a wealth of information about each data change in a batch, including:
       </p><div class="itemizedlist"><ul type="disc"><li>
       The table involved in each data change, available in column <code class="literal">TABLE_NAME</code>,</li><li>
       The event type (Update [U], Insert [I], or Delete [D]), available in column <code class="literal">EVENT_TYPE</code>,
       </li><li>
       A comma separated list of the new data and (optionally) the old data, available in columns <code class="literal">ROW_DATA</code> and 
       <code class="literal">OLD_DATA</code>, respectively.
       </li><li>
       The primary key data, available in column <code class="literal">PK_DATA</code>
       </li><li>
       The channel id, trigger history information, transaction id if available, and other information.
       </li></ul></div><p>
       </p>
       <p>
       More importantly, if you narrow your query to just the failed data id you can determine the exact data change that is causing the failure:       
       </p><pre class="programlisting">select * from sym_data where data_id in 
        (select failed_data_id from sym_outgoing_batch where batch_id='XXXXX');</pre><p>
       where XXXXXX is the batch that is failing.
       </p>
       <p>The queries above usually yield enough information to be able to determine why a
       particular batch is failing. Common reasons a batch might be failing include:
            </p><div class="itemizedlist"><ul type="disc"><li>
            The schema at the destination has a column that is not nullable yet the source
            has the column defined as nullable and a data change was sent with the column as null.</li><li>
            A foreign key constraint at the destination is preventing an insertion or update, which could be caused from
            data being deleted at the destination or the foreign key constraint is not in place at the source.
            </li><li>
            The data size of a column on the destination is smaller than the data size in the source, and data that
            is too large for the destination has been synced.
            </li></ul></div><p>
            </p>
                   
    </div>
            <div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="solving-synchronization-issues-resolution"></a>7.1.2.&nbsp;Resolving the Issue</h3></div></div></div>
            
            
            <p>
            Once you have decided upon the cause of the issue, you'll have to decide the best course of action to fix the issue.  If, for example,
            the problem is due to a database schema mismatch, one possible solution would be to alter the destination database
            in such a way that the SQL error no longer occurs.  Whatever approach you take to remedy the issue, once you have
            made the change, on the next push or pull SymmetricDS will retry the batch
            and the channel's data will start flowing again.            
            </p>
            <p>
            If you have instead decided that the batch itself is wrong, or does not need synchronized, or you wish to remove a 
            particular data change from a batch, you do have the option of changing the data associated with the batch directly.
           
            </p><div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Warning</h3>
            Be cautious when using the following two approaches to resolve synchronization issues.  By far, the
            best approach to solving a synchronization error is to resolve what is truly causing the
            error at the destination database.  Skipping a batch or removing a data id as discussed below should be your
            solution of last resort, since doing so results in differences between the source and destination databases.
            </div><p>
            
            Now that you've read the warning, if you <span class="emphasis"><em>still</em></span> want to change the batch
            data itself, you do have several options, including:
            </p><div class="itemizedlist"><ul type="disc"><li>Causing SymmetricDS to skip the batch completely.  This is accomplished by setting the
                batch's status to 'OK', as in:
                <pre class="programlisting">update sym_outgoing_batch set status='OK' where batch_id='XXXXXX'</pre>
                where XXXXXX is the failing batch. On the next pull or push, SymmetricDS will skip this batch since
                it now thinks the batch has already been synchronized.  Note that you can still distinguish between successful
                batches and ones that you've artificially marked as 'OK', since the <code class="literal">error_flag</code> column on
                the failed batch will still be set to '1' (in error).
                </li><li>
                Removing the failing data id from the batch by deleting the corresponding row in <a href="#table_data_event" title="A.23.&nbsp;DATA_EVENT">DATA_EVENT</a>.
                Eliminating the data id from the list of data ids in the batch will cause future synchronization attempts
                of the batch to no longer include that particular data change as part of the batch.  For example:
                  <pre class="programlisting">delete from sym_data_event where batch_id='XXXXXX' and data_id='YYYYYY'</pre>
                where XXXXXX is the failing batch and YYYYYY is the data id to longer be included in the batch.
                </li></ul></div><p>
            </p>
   </div>
   </div>
    <div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="changing-triggers"></a>7.2.&nbsp;Changing Triggers</h2></div></div></div>
        
        <p>
            A trigger row may be updated using SQL to change a synchronization definition.
            SymmetricDS will look for changes each night or whenever the Sync Triggers Job 
            is run (see below).  For example, a change to place the table <code class="literal">price_changes</code> 
            into the price channel would be accomplished with the following statement:
            </p><pre class="programlisting">
update SYM_TRIGGER
set channel_id = 'price',
    last_update_by = 'jsmith',
    last_update_time = current_timestamp
where source_table_name = 'price_changes';
</pre><p>            
            All configuration should be managed centrally at the registration node.  If enabled, configuration 
            changes will be synchronized out to client nodes.  When trigger changes reach the client
            nodes the Sync Triggers Job will run automatically.
         </p>
         <p>   
            Centrally, the trigger changes will not take effect until the Sync Triggers Job runs.
            Instead of waiting for the Sync Triggers Job to run overnight after making a Trigger
            change, you can invoke the syncTriggers() method over JMX or simply restart the SymmetricDS
            server.  A complete record of trigger changes is kept in the table  <a href="#table_trigger_hist" title="A.19.&nbsp;TRIGGER_HIST">TRIGGER_HIST</a>, 
            which was discussed in <a href="#sync-triggers" title="5.2.3.&nbsp;Sync Triggers Job">Section&nbsp;5.2.3, &#8220;Sync Triggers Job&#8221;</a>.
        </p>
    </div>
     <div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="resync-data"></a>7.3.&nbsp;Re-synchronizing Data</h2></div></div></div>
        
        <p>
        There may be times where you find you need to re-send or re-synchronize data when the change itself was not captured.  This could be needed, for example,
        if the data changes occurred prior to SymmetricDS placing triggers on the data tables themselves, or if the data at the destination was accidentally deleted, or for 
        some other reason.  Two approaches are commonly taken to re-send the data, both of which are discussed below.
        </p>
        
      <div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Important</h3>
            <p>Be careful when re-sending data using either of these two techniques.  Be sure you are only sending the rows you intend to send and,
            more importantly, be sure to re-send the data in a way that won't cause foreign key constraint issues at the destination.  In other words,
            if more than one table is involved, be sure to send any tables which are referred to by other tables by foreign keys first.  Otherwise,
            the channel's synchronization will block because SymmetricDS is unable to insert or update the row because the foreign key relationship refers to
            a non-existent row in the destination!
           </p>
      </div>
            
        <p>One possible approach would be to "touch" the rows in individual tables that need re-sent.  By "touch", we mean to alter the row data in such a way
        that SymmetricDS detects a data change and therefore includes the data change in the batching and synchronizing steps.  Note that you have to
        change the data in some meaningful way (e.g., update a time stamp); setting a column to its current value is not sufficient (by default, if there's not an actual data 
        value change SymmetricDS won't treat the change as something which needs synched.
        </p>
        <p>A second approach would be to take advantage of SymmetricDS built-in functionality by simulating a partial "initial load" of the data.  The approach
        is to manually create "reload" events in <a href="#table_data" title="A.20.&nbsp;DATA">DATA</a> for the necessary tables, thereby resending the desired rows for the given tables.  
        Again, foreign key constraints must be kept in mind when creating these reload events.  These reload events are created in the source database itself, and
        the necessary table, trigger-router combination, and channel are included to indicate the direction of synchronization.</p>
        <p>
        To create a reload event, you create a <a href="#table_data" title="A.20.&nbsp;DATA">DATA</a> row, using:
       </p><div class="itemizedlist"><ul type="disc"><li>data_id:  null</li><li>table_name:  name of table to be sent</li><li>event_type: 'R', for reload</li><li>row_data:  a "where" clause (minus the word 'where') which defines the subset of rows from the table to be sent.  To send all rows, one can use 1=1 for this value.</li><li>pk_data:  null</li><li>old_data: null</li><li>trigger_hist_id:  use the id of the most recent entry (i.e., max(trigger_hist_id) ) in <a href="#table_trigger_hist" title="A.19.&nbsp;TRIGGER_HIST">TRIGGER_HIST</a> 
        for the trigger-router combination for your table and router.</li><li>channel_id:  the channel in which the table is routed</li><li>transaction_id:  pick a value, for example '1'</li><li>source_node_id: null</li><li>external_data: null</li><li>create_time:  current_timestamp</li></ul></div><p>
        </p>
        
        <p>
        By way of example, take our retail hands-on tutorial covered in <a href="#tutorial" title="Chapter&nbsp;2.&nbsp;Hands-on Tutorial">Chapter&nbsp;2, <i xmlns:xlink="http://www.w3.org/1999/xlink">Hands-on Tutorial</i></a>.  Let's say
        we need to re-send a particular sales transaction from the store to corp over again because we lost the data in corp due to
        an overzealous delete.  For the tutorial, all transaction-related tables start with <code class="literal">sale_</code>, 
        use the <code class="literal">sale_transaction</code> channel, and are routed using the <code class="literal">store_corp_identity</code>
        router.  In addition, the trigger-routers have been set up with an initial load order based on the necessary 
        foreign key relationships (i.e., transaction tables which are "parents" have a lower initial load order than those of their
        "children").  An insert statement that would create the necessary "reload" events (three in this case, one for each table) would be as follows
        (where MISSING_ID is changed to the needed transaciton id):
       </p><pre class="programlisting">
       
insert into sym_data (
    select null, t.source_table_name, 'R', 'tran_id=''MISSING-ID''', null, null,
            h.trigger_hist_id, t.channel_id, '1', null, null, current_timestamp
        from sym_trigger t inner join sym_trigger_router tr on
            t.trigger_id=tr.trigger_id inner join sym_trigger_hist h on
            h.trigger_hist_id=(select max(trigger_hist_id) from sym_trigger_hist
                where trigger_id=t.trigger_id) 
    where channel_id='sale_transaction' and
        tr.router_id like 'store_corp_identity' and 
        (t.source_table_name like 'sale_%') 
    order by tr.initial_load_order asc);
    </pre><p>
    
    This insert statement generates three rows, one for each configured sale table.  It uses the most recent
    trigger history id for the corresponding table.  Finally, it takes advantage of the initial load order for each trigger-router to
    create the three rows in the correct order (the order corresponding to the order in which the tables would have been initial loaded).
    
    </p>
    </div>
    <div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="changing-configuration"></a>7.4.&nbsp;Changing Configuration</h2></div></div></div>
        
        <p>
            The configuration of your system as defined in the <code class="literal">sym_*</code> tables may be modified at runtime.  By default, any changes made to 
            the <code class="literal">sym_*</code> tables (with the exception of <code class="literal">sym_node</code>) should be made at the registration server.  The changes will
            be synchronized out to the leaf nodes by SymmetricDS triggers that are automatically created on the tables.
         </p>
         <p>   
            If this behavior is not desired, the feature can be turned off using a parameter.  Custom triggers may be added
            to the <code class="literal">sym_*</code> tables when the auto syncing feature is disabled.
        </p>
    </div> 
    
     <div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="logging"></a>7.5.&nbsp;Logging Configuration</h2></div></div></div>
            
        <p>
        The standalone SymmetricDS installation uses <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://logging.apache.org/log4j/1.2/index.html" target="_top">Log4J</a> for logging.  The configuration file is  <code class="literal">conf/log4j.xml</code>.
        The <code class="literal">log4j.xml</code> file has hints as to what logging can be enabled for useful, finer-grained logging.
        </p>
        <p>
        SymmetricDS proxies all of its logging through <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://commons.apache.org/logging/" target="_top">Commons Logging</a>.  When deploying to an application server, if Log4J is not 
        being leveraged, then the general rules for for Commons Logging apply.
        </p>
    </div> 
    
     <div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="admin-jmx"></a>7.6.&nbsp;Java Management Extensions</h2></div></div></div>
        
        <p>
          Monitoring and administrative operations can be performed using Java Management Extensions (JMX).
          SymmetricDS uses MX4J to expose JMX attributes and operations that can be accessed
          from the built-in web console, Java's jconsole, or an application server.  
          By default, the web management console can be opened from the following address:

          </p><pre class="programlisting">http://localhost:31416/</pre><p>

          Using the Java jconsole command, SymmetricDS is listed as a local process named SymmetricLauncher.
          In jconsole, SymmetricDS appears under the MBeans tab under then name defined by the <code class="literal">engine.name</code>
          property.  The default value is SymmetricDS.
        </p>
        <p>
          The management interfaces under SymmetricDS are organized as follows:

            </p><div class="itemizedlist"><ul type="disc"><li>
                    <p>Node - administrative operations </p>
                </li><li>
                    <p>Incoming - statistics about incoming batches </p>
                </li><li>
                    <p>Outgoing - statistics about outgoing batches </p>
                </li><li>
                    <p>Parameters - access to properties set through the parameter service </p>
                </li><li>
                    <p>Notifications - setting thresholds and receiving notifications </p>
                </li></ul></div><p>
          
        </p>
    </div>
    
    
    
    <div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="temporary-files"></a>7.7.&nbsp;Temporary Files</h2></div></div></div>
        
        <p>
        SymmetricDS creates temporary extraction and data load files with the CSV payload of a synchronization when
        the value of the <code class="literal">stream.to.file.threshold.bytes</code> SymmetricDS property has been reached.  Before reaching the threshold, files 
        are streamed to/from memory.  The default threshold value is 32,767 bytes. This feature may be turned off by setting the <code class="literal">stream.to.file.enabled</code> 
        property to false.
        </p>
        <p>
        SymmetricDS creates these temporary files in the directory specified by the <code class="literal">java.io.tmpdir</code> Java System property.  When  
        SymmmetricDS starts up, stranded temporary files are aways cleaned up.  Files will only be stranded if the SymmetricDS engine is force killed.
        </p>
        <p>
        The location of the temporary directory may be changed by setting the Java System property passed into the Java program at startup.  For example,
        </p><pre class="programlisting">
  -Djava.io.tmpdir=/home/.symmetricds/tmp
        </pre><p>   
        </p>
    </div>   
    
    
    <div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="purge"></a>7.8.&nbsp;Database Purging</h2></div></div></div>
        
        <p>
            Purging is the act of cleaning up captured data that is no longer needed in SymmetricDS's runtime tables.  
            Data is purged through
            delete statements by the <span class="emphasis"><em>Purge Job</em></span>.  Only data that has been successfully synchronized will be purged.  Purged tables include:
            </p><div class="itemizedlist"><ul type="disc"><li>
                   <a href="#table_data" title="A.20.&nbsp;DATA">DATA</a>
                </li><li>
                    <a href="#table_data_event" title="A.23.&nbsp;DATA_EVENT">DATA_EVENT</a>
                </li><li>
                  <a href="#table_outgoing_batch" title="A.24.&nbsp;OUTGOING_BATCH">OUTGOING_BATCH</a>
                </li><li>
                    <a href="#table_incoming_batch" title="A.25.&nbsp;INCOMING_BATCH">INCOMING_BATCH</a>
                </li><li>
                    <a href="#table_data_gap" title="A.22.&nbsp;DATA_GAP">DATA_GAP</a>
                </li><li>
                   <a href="#table_node_host_stats" title="A.8.&nbsp;NODE_HOST_STATS">NODE_HOST_STATS</a>
                </li><li>
                   <a href="#table_node_host_channel_stats" title="A.7.&nbsp;NODE_HOST_CHANNEL_STATS">NODE_HOST_CHANNEL_STATS</a>
                </li><li>
                   <a href="#table_node_host_job_stats" title="A.9.&nbsp;NODE_HOST_JOB_STATS">NODE_HOST_JOB_STATS</a>
                </li></ul></div><p>
            The purge job is enabled by the <code class="literal">start.purge.job</code> SymmetricDS property.  The job runs periodically according to the 
            <code class="literal">job.purge.period.time.ms</code> property.  The default period is to run every ten minutes.  
        </p>      
        <p>
            Two retention period properties
            indicate how much history SymmetricDS will retain before purging.  The <code class="literal">purge.retention.minutes</code> property indicates the period
            of history to keep for synchronization tables.  The default value is 5 days.
            The <code class="literal">statistic.retention.minutes</code> property
            indicates the period of history to keep for statistics.  The default value is also 5 days.            
        </p>
        <p>
            The purge properties should be adjusted according to how much data is flowing through the system and the amount of storage space the database has.
            For an initial deployment it is recommended that the purge properties be kept at the defaults, since it is often helpful to be able to look at 
            the captured data in order to triage problems and profile the synchronization patterns.  When scaling up to more nodes, it is recomended that the 
            purge parameters be scaled back to 24 hours or less.  
        </p>
    </div>
    
    
 
  
    
</div>
    <div class="appendix" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="data-model"></a>Appendix&nbsp;A.&nbsp;Data Model</h2></div></div></div>
    
    <p> 
        What follows is the complete SymmetricDS data model.
        Note that all tables are prepended with a configurable prefix so that multiple instances of SymmetricDS may coexist in the
        same database. The default prefix is
        <span class="emphasis"><em>sym_</em></span>.
    </p>

    <p> 
        SymmetricDS configuration is entered by the user into the data model to control the behavior of what data is synchronized
            to which nodes.
    </p>
    <p>
            </p><div class="figure"><a name="d4e1636"></a><div class="figure-contents">
                
                <div class="mediaobject"><img src="images/data-model-config.gif" alt="Configuration Data Model"></div>
            </div><p class="title"><b>Figure&nbsp;A.1.&nbsp;Configuration Data Model</b></p></div><p><br class="figure-break">
    </p>
        
    <p> At runtime, the configuration is used to capture data changes and route them to nodes. The data changes are placed
            together in a single unit called a batch that can be loaded by another node. Outgoing batches are delivered to nodes
            and acknowledged. Incoming batches are received and loaded. History is recorded for batch status changes and
            statistics.</p>
    <p>
            </p><div class="figure"><a name="d4e1643"></a><div class="figure-contents">
                
                <div class="mediaobject"><img src="images/data-model-runtime.gif" alt="Runtime Data Model"></div>
            </div><p class="title"><b>Figure&nbsp;A.2.&nbsp;Runtime Data Model</b></p></div><p><br class="figure-break">
    </p>
		 
	  	    
<div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="table_node"></a>A.1.&nbsp;NODE</h2></div></div></div>
    
    <p>Representation of an instance of SymmetricDS that synchronizes data with one or more additional nodes. Each node has a unique identifier (nodeId) that is used when communicating, as well as a domain-specific identifier (externalId) that provides context within the local system.</p>
	<div class="table"><a name="table-def-node"></a><div class="table-contents">
    	
    	<table summary="NODE" border="1"><colgroup><col width="115"><col width="50"><col width="30"><col width="18"><col width="18"><col width="150"></colgroup><thead><tr><th>Name</th><th>Type / Size</th><th>Default</th><th>PK FK</th><th>not null</th><th>Description</th></tr></thead><tbody><tr><td>
                 	NODE_ID                </td><td>VARCHAR  (50)</td><td>&nbsp;</td><td>PK				</td><td>X</td><td> A unique identifier for a node.</td></tr><tr><td>
                 	NODE_GROUP_ID                </td><td>VARCHAR  (50)</td><td>&nbsp;</td><td>				</td><td>X</td><td> The node group that this node belongs to, such as 'store'.</td></tr><tr><td>
                 	EXTERNAL_ID                </td><td>VARCHAR  (50)</td><td>&nbsp;</td><td>				</td><td>X</td><td> A domain-specific identifier for context within the local system. For example, the retail store number. </td></tr><tr><td>
                 	SYNC_ENABLED                </td><td>INTEGER  (1)</td><td> 0</td><td>				</td><td>&nbsp;</td><td> Indicates whether this node should be sent synchronization. Disabled nodes are ignored by the triggers, so no entries are made in data_event for the node.</td></tr><tr><td>
                 	SYNC_URL                </td><td>VARCHAR  (255)</td><td>&nbsp;</td><td>				</td><td>&nbsp;</td><td> The URL to contact the node for synchronization.</td></tr><tr><td>
                 	SCHEMA_VERSION                </td><td>VARCHAR  (50)</td><td>&nbsp;</td><td>				</td><td>&nbsp;</td><td> The version of the database schema this node manages. Useful for specifying synchronization by version. </td></tr><tr><td>
                 	SYMMETRIC_VERSION                </td><td>VARCHAR  (50)</td><td>&nbsp;</td><td>				</td><td>&nbsp;</td><td> The version of SymmetricDS running at this node.</td></tr><tr><td>
                 	DATABASE_TYPE                </td><td>VARCHAR  (50)</td><td>&nbsp;</td><td>				</td><td>&nbsp;</td><td> The database product name at this node as reported by JDBC.</td></tr><tr><td>
                 	DATABASE_VERSION                </td><td>VARCHAR  (50)</td><td>&nbsp;</td><td>				</td><td>&nbsp;</td><td> The database product version at this node as reported by JDBC.</td></tr><tr><td>
                 	HEARTBEAT_TIME                </td><td>TIMESTAMP </td><td>&nbsp;</td><td>				</td><td>&nbsp;</td><td> The last timestamp when the node sent a heartbeat, which is attempted every ten minutes by default.</td></tr><tr><td>
                 	TIMEZONE_OFFSET                </td><td>VARCHAR  (6)</td><td>&nbsp;</td><td>				</td><td>&nbsp;</td><td> The timezone offset in RFC822 format at the time of the last heartbeat. </td></tr><tr><td>
                 	BATCH_TO_SEND_COUNT                </td><td>INTEGER </td><td> 0</td><td>				</td><td>&nbsp;</td><td> The number of outgoing batches that have not yet been sent.  This field is updated as part of the heartbeat job.</td></tr><tr><td>
                 	BATCH_IN_ERROR_COUNT                </td><td>INTEGER </td><td> 0</td><td>				</td><td>&nbsp;</td><td> The number of outgoing batches that are in error at this node.  This field is updated as part of the heartbeat job.</td></tr><tr><td>
                 	CREATED_AT_NODE_ID                </td><td>VARCHAR  (50)</td><td>&nbsp;</td><td>				</td><td>&nbsp;</td><td> The node_id of the node where this node was created. This is typically filled automatically with the node_id found in node_identity where registration was opened for the node. </td></tr><tr><td>
                 	DEPLOYMENT_TYPE                </td><td>VARCHAR  (50)</td><td>&nbsp;</td><td>				</td><td>&nbsp;</td><td> An indicator as to the type of SymmetricDS software that is running.  Possible values are, but not limited to: engine, standalone, war, professional, mobile</td></tr></tbody></table>
	</div><p class="title"><b>Table&nbsp;A.1.&nbsp;NODE</b></p></div><br class="table-break">
</div>

	  	    
<div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="table_node_security"></a>A.2.&nbsp;NODE_SECURITY</h2></div></div></div>
    
    <p>Security features like node passwords and open registration flag are stored in the node_security table. </p>
	<div class="table"><a name="table-def-node_security"></a><div class="table-contents">
    	
    	<table summary="NODE_SECURITY" border="1"><colgroup><col width="115"><col width="50"><col width="30"><col width="18"><col width="18"><col width="150"></colgroup><thead><tr><th>Name</th><th>Type / Size</th><th>Default</th><th>PK FK</th><th>not null</th><th>Description</th></tr></thead><tbody><tr><td>
                 	NODE_ID                </td><td>VARCHAR  (50)</td><td>&nbsp;</td><td>PK				</td><td>X</td><td> Unique identifier for a node.</td></tr><tr><td>
                 	NODE_PASSWORD                </td><td>VARCHAR  (50)</td><td>&nbsp;</td><td>				</td><td>X</td><td> The password used by the node to prove its identity during synchronization.</td></tr><tr><td>
                 	REGISTRATION_ENABLED                </td><td>INTEGER  (1)</td><td> 0</td><td>				</td><td>&nbsp;</td><td> Indicates whether registration is open for this node.  Re-registration may be forced for a node if this is set back to '1' in a parent database for the node_id that should be re-registred.</td></tr><tr><td>
                 	REGISTRATION_TIME                </td><td>TIMESTAMP </td><td>&nbsp;</td><td>				</td><td>&nbsp;</td><td> The timestamp when this node was last registered.</td></tr><tr><td>
                 	INITIAL_LOAD_ENABLED                </td><td>INTEGER  (1)</td><td> 0</td><td>				</td><td>&nbsp;</td><td> Indicates whether an initial load will be sent to this node.</td></tr><tr><td>
                 	INITIAL_LOAD_TIME                </td><td>TIMESTAMP </td><td>&nbsp;</td><td>				</td><td>&nbsp;</td><td> The timestamp when this node started the initial load.</td></tr><tr><td>
                 	CREATED_AT_NODE_ID                </td><td>VARCHAR  (50)</td><td>&nbsp;</td><td>				</td><td>X</td><td> The node_id of the node where this node was created. This is typically filled automatically with the node_id found in node_identity where registration was opened for the node. </td></tr></tbody></table>
	</div><p class="title"><b>Table&nbsp;A.2.&nbsp;NODE_SECURITY</b></p></div><br class="table-break">
</div>

	  	    
<div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="table_node_identity"></a>A.3.&nbsp;NODE_IDENTITY</h2></div></div></div>
    
    <p>After registration, this table will have one row representing the identity of the node. For a root node, the row is entered by the user.</p>
	<div class="table"><a name="table-def-node_identity"></a><div class="table-contents">
    	
    	<table summary="NODE_IDENTITY" border="1"><colgroup><col width="115"><col width="50"><col width="30"><col width="18"><col width="18"><col width="150"></colgroup><thead><tr><th>Name</th><th>Type / Size</th><th>Default</th><th>PK FK</th><th>not null</th><th>Description</th></tr></thead><tbody><tr><td>
                 	NODE_ID                </td><td>VARCHAR  (50)</td><td>&nbsp;</td><td>PK				</td><td>X</td><td> Unique identifier for a node.</td></tr></tbody></table>
	</div><p class="title"><b>Table&nbsp;A.3.&nbsp;NODE_IDENTITY</b></p></div><br class="table-break">
</div>

	  	    
<div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="table_node_group"></a>A.4.&nbsp;NODE_GROUP</h2></div></div></div>
    
    <p>A category of Nodes that synchronizes data with one or more NodeGroups. A common use of NodeGroup is to describe a level in a hierarchy of data synchronization.</p>
	<div class="table"><a name="table-def-node_group"></a><div class="table-contents">
    	
    	<table summary="NODE_GROUP" border="1"><colgroup><col width="115"><col width="50"><col width="30"><col width="18"><col width="18"><col width="150"></colgroup><thead><tr><th>Name</th><th>Type / Size</th><th>Default</th><th>PK FK</th><th>not null</th><th>Description</th></tr></thead><tbody><tr><td>
                 	NODE_GROUP_ID                </td><td>VARCHAR  (50)</td><td>&nbsp;</td><td>PK				</td><td>X</td><td> Unique identifier for a node group, usually named something meaningful, like 'store' or 'warehouse'.</td></tr><tr><td>
                 	DESCRIPTION                </td><td>VARCHAR  (255)</td><td>&nbsp;</td><td>				</td><td>&nbsp;</td><td> A description of this node group.</td></tr></tbody></table>
	</div><p class="title"><b>Table&nbsp;A.4.&nbsp;NODE_GROUP</b></p></div><br class="table-break">
</div>

	  	    
<div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="table_node_group_link"></a>A.5.&nbsp;NODE_GROUP_LINK</h2></div></div></div>
    
    <p>A source node_group sends its data updates to a target NodeGroup using a pull, push, or custom technique.</p>
	<div class="table"><a name="table-def-node_group_link"></a><div class="table-contents">
    	
    	<table summary="NODE_GROUP_LINK" border="1"><colgroup><col width="115"><col width="50"><col width="30"><col width="18"><col width="18"><col width="150"></colgroup><thead><tr><th>Name</th><th>Type / Size</th><th>Default</th><th>PK FK</th><th>not null</th><th>Description</th></tr></thead><tbody><tr><td>
                 	SOURCE_NODE_GROUP_ID                </td><td>VARCHAR  (50)</td><td>&nbsp;</td><td>PK				</td><td>X</td><td> The node group where data changes should be captured.</td></tr><tr><td>
                 	TARGET_NODE_GROUP_ID                </td><td>VARCHAR  (50)</td><td>&nbsp;</td><td>PK				</td><td>X</td><td> The node group where data changes will be sent.</td></tr><tr><td>
                 	DATA_EVENT_ACTION                </td><td>CHAR  (1)</td><td> W</td><td>				</td><td>X</td><td> The notification scheme used to send data changes to the target node group. (P = Push, W = Wait for Pull) </td></tr></tbody></table>
	</div><p class="title"><b>Table&nbsp;A.5.&nbsp;NODE_GROUP_LINK</b></p></div><br class="table-break">
</div>

	  	    
<div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="table_node_host"></a>A.6.&nbsp;NODE_HOST</h2></div></div></div>
    
    <p>Representation of an physical workstation or server that is hosting the SymmetricDS software. In a clustered environment there may be more than one entry per node in this table.</p>
	<div class="table"><a name="table-def-node_host"></a><div class="table-contents">
    	
    	<table summary="NODE_HOST" border="1"><colgroup><col width="115"><col width="50"><col width="30"><col width="18"><col width="18"><col width="150"></colgroup><thead><tr><th>Name</th><th>Type / Size</th><th>Default</th><th>PK FK</th><th>not null</th><th>Description</th></tr></thead><tbody><tr><td>
                 	NODE_ID                </td><td>VARCHAR  (50)</td><td>&nbsp;</td><td>PK				</td><td>X</td><td> A unique identifier for a node.</td></tr><tr><td>
                 	HOST_NAME                </td><td>VARCHAR  (60)</td><td>&nbsp;</td><td>PK				</td><td>X</td><td> The host name of a workstation or server. If more than one instance of SymmetricDS runs on the same server, then this value can be a 'server id' specified by -Druntime.symmetric.cluster.server.id</td></tr><tr><td>
                 	IP_ADDRESS                </td><td>VARCHAR  (50)</td><td>&nbsp;</td><td>				</td><td>&nbsp;</td><td> The ip address for the host.</td></tr><tr><td>
                 	OS_USER                </td><td>VARCHAR  (50)</td><td>&nbsp;</td><td>				</td><td>&nbsp;</td><td> The user SymmetricDS is running under</td></tr><tr><td>
                 	OS_NAME                </td><td>VARCHAR  (50)</td><td>&nbsp;</td><td>				</td><td>&nbsp;</td><td> The name of the OS</td></tr><tr><td>
                 	OS_ARCH                </td><td>VARCHAR  (50)</td><td>&nbsp;</td><td>				</td><td>&nbsp;</td><td> The hardware architecture of the OS</td></tr><tr><td>
                 	OS_VERSION                </td><td>VARCHAR  (50)</td><td>&nbsp;</td><td>				</td><td>&nbsp;</td><td> The version of the OS</td></tr><tr><td>
                 	AVAILABLE_PROCESSORS                </td><td>INTEGER </td><td> 0</td><td>				</td><td>&nbsp;</td><td> The number of processors available to use.</td></tr><tr><td>
                 	FREE_MEMORY_BYTES                </td><td>BIGINT </td><td> 0</td><td>				</td><td>&nbsp;</td><td> The amount of free memory available to the JVM.</td></tr><tr><td>
                 	TOTAL_MEMORY_BYTES                </td><td>BIGINT </td><td> 0</td><td>				</td><td>&nbsp;</td><td> The amount of total memory available to the JVM.</td></tr><tr><td>
                 	MAX_MEMORY_BYTES                </td><td>BIGINT </td><td> 0</td><td>				</td><td>&nbsp;</td><td> The max amount of memory available to the JVM.</td></tr><tr><td>
                 	JAVA_VERSION                </td><td>VARCHAR  (50)</td><td>&nbsp;</td><td>				</td><td>&nbsp;</td><td> The version of java that SymmetricDS is running as.</td></tr><tr><td>
                 	JAVA_VENDOR                </td><td>VARCHAR  (255)</td><td>&nbsp;</td><td>				</td><td>&nbsp;</td><td> The vendor of java that SymmetricDS is running as.</td></tr><tr><td>
                 	SYMMETRIC_VERSION                </td><td>VARCHAR  (50)</td><td>&nbsp;</td><td>				</td><td>&nbsp;</td><td> The version of SymmetricDS running at this node.</td></tr><tr><td>
                 	TIMEZONE_OFFSET                </td><td>VARCHAR  (6)</td><td>&nbsp;</td><td>				</td><td>&nbsp;</td><td> The timezone offset in RFC822 format at the time of the last heartbeat. </td></tr><tr><td>
                 	HEARTBEAT_TIME                </td><td>TIMESTAMP </td><td>&nbsp;</td><td>				</td><td>&nbsp;</td><td> The last timestamp when the node sent a heartbeat, which is attempted every ten minutes by default.</td></tr><tr><td>
                 	LAST_RESTART_TIME                </td><td>TIMESTAMP </td><td>&nbsp;</td><td>				</td><td>X</td><td> Timestamp when this instance was last restarted.</td></tr><tr><td>
                 	CREATE_TIME                </td><td>TIMESTAMP </td><td>&nbsp;</td><td>				</td><td>X</td><td> Timestamp when this entry was created.</td></tr></tbody></table>
	</div><p class="title"><b>Table&nbsp;A.6.&nbsp;NODE_HOST</b></p></div><br class="table-break">
</div>

	  	    
<div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="table_node_host_channel_stats"></a>A.7.&nbsp;NODE_HOST_CHANNEL_STATS</h2></div></div></div>
    
    <p></p>
	<div class="table"><a name="table-def-node_host_channel_stats"></a><div class="table-contents">
    	
    	<table summary="NODE_HOST_CHANNEL_STATS" border="1"><colgroup><col width="115"><col width="50"><col width="30"><col width="18"><col width="18"><col width="150"></colgroup><thead><tr><th>Name</th><th>Type / Size</th><th>Default</th><th>PK FK</th><th>not null</th><th>Description</th></tr></thead><tbody><tr><td>
                 	NODE_ID                </td><td>VARCHAR  (50)</td><td>&nbsp;</td><td>PK				</td><td>X</td><td> A unique identifier for a node.</td></tr><tr><td>
                 	HOST_NAME                </td><td>VARCHAR  (60)</td><td>&nbsp;</td><td>PK				</td><td>X</td><td> The host name of a workstation or server. If more than one instance of SymmetricDS runs on the same server, then this value can be a 'server id' specified by -Druntime.symmetric.cluster.server.id</td></tr><tr><td>
                 	CHANNEL_ID                </td><td>VARCHAR  (20)</td><td>&nbsp;</td><td>PK				</td><td>X</td><td> The channel_id of the channel that data changes will flow through.</td></tr><tr><td>
                 	START_TIME                </td><td>TIMESTAMP </td><td>&nbsp;</td><td>PK				</td><td>X</td><td> </td></tr><tr><td>
                 	END_TIME                </td><td>TIMESTAMP </td><td>&nbsp;</td><td>PK				</td><td>X</td><td> </td></tr><tr><td>
                 	DATA_ROUTED                </td><td>BIGINT </td><td> 0</td><td>				</td><td>&nbsp;</td><td> Indicate the number of data rows that have been routed during this period.</td></tr><tr><td>
                 	DATA_UNROUTED                </td><td>BIGINT </td><td> 0</td><td>				</td><td>&nbsp;</td><td> </td></tr><tr><td>
                 	DATA_EVENT_INSERTED                </td><td>BIGINT </td><td> 0</td><td>				</td><td>&nbsp;</td><td> Indicate the number of data rows that have been routed during this period.</td></tr><tr><td>
                 	DATA_EXTRACTED                </td><td>BIGINT </td><td> 0</td><td>				</td><td>&nbsp;</td><td> </td></tr><tr><td>
                 	DATA_BYTES_EXTRACTED                </td><td>BIGINT </td><td> 0</td><td>				</td><td>&nbsp;</td><td> </td></tr><tr><td>
                 	DATA_EXTRACTED_ERRORS                </td><td>BIGINT </td><td> 0</td><td>				</td><td>&nbsp;</td><td> </td></tr><tr><td>
                 	DATA_BYTES_SENT                </td><td>BIGINT </td><td> 0</td><td>				</td><td>&nbsp;</td><td> </td></tr><tr><td>
                 	DATA_SENT                </td><td>BIGINT </td><td> 0</td><td>				</td><td>&nbsp;</td><td> </td></tr><tr><td>
                 	DATA_SENT_ERRORS                </td><td>BIGINT </td><td> 0</td><td>				</td><td>&nbsp;</td><td> </td></tr><tr><td>
                 	DATA_LOADED                </td><td>BIGINT </td><td> 0</td><td>				</td><td>&nbsp;</td><td> </td></tr><tr><td>
                 	DATA_BYTES_LOADED                </td><td>BIGINT </td><td> 0</td><td>				</td><td>&nbsp;</td><td> </td></tr><tr><td>
                 	DATA_LOADED_ERRORS                </td><td>BIGINT </td><td> 0</td><td>				</td><td>&nbsp;</td><td> </td></tr></tbody></table>
	</div><p class="title"><b>Table&nbsp;A.7.&nbsp;NODE_HOST_CHANNEL_STATS</b></p></div><br class="table-break">
</div>

	  	    
<div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="table_node_host_stats"></a>A.8.&nbsp;NODE_HOST_STATS</h2></div></div></div>
    
    <p></p>
	<div class="table"><a name="table-def-node_host_stats"></a><div class="table-contents">
    	
    	<table summary="NODE_HOST_STATS" border="1"><colgroup><col width="115"><col width="50"><col width="30"><col width="18"><col width="18"><col width="150"></colgroup><thead><tr><th>Name</th><th>Type / Size</th><th>Default</th><th>PK FK</th><th>not null</th><th>Description</th></tr></thead><tbody><tr><td>
                 	NODE_ID                </td><td>VARCHAR  (50)</td><td>&nbsp;</td><td>PK				</td><td>X</td><td> A unique identifier for a node.</td></tr><tr><td>
                 	HOST_NAME                </td><td>VARCHAR  (60)</td><td>&nbsp;</td><td>PK				</td><td>X</td><td> The host name of a workstation or server. If more than one instance of SymmetricDS runs on the same server, then this value can be a 'server id' specified by -Druntime.symmetric.cluster.server.id</td></tr><tr><td>
                 	START_TIME                </td><td>TIMESTAMP </td><td>&nbsp;</td><td>PK				</td><td>X</td><td> </td></tr><tr><td>
                 	END_TIME                </td><td>TIMESTAMP </td><td>&nbsp;</td><td>PK				</td><td>X</td><td> </td></tr><tr><td>
                 	RESTARTED                </td><td>BIGINT </td><td> 0</td><td>				</td><td>X</td><td> Indicate that a restart occurred during this period.</td></tr><tr><td>
                 	NODES_PULLED                </td><td>BIGINT </td><td> 0</td><td>				</td><td>&nbsp;</td><td> </td></tr><tr><td>
                 	TOTAL_NODES_PULL_TIME                </td><td>BIGINT </td><td> 0</td><td>				</td><td>&nbsp;</td><td> </td></tr><tr><td>
                 	NODES_PUSHED                </td><td>BIGINT </td><td> 0</td><td>				</td><td>&nbsp;</td><td> </td></tr><tr><td>
                 	TOTAL_NODES_PUSH_TIME                </td><td>BIGINT </td><td> 0</td><td>				</td><td>&nbsp;</td><td> </td></tr><tr><td>
                 	NODES_REJECTED                </td><td>BIGINT </td><td> 0</td><td>				</td><td>&nbsp;</td><td> </td></tr><tr><td>
                 	NODES_REGISTERED                </td><td>BIGINT </td><td> 0</td><td>				</td><td>&nbsp;</td><td> </td></tr><tr><td>
                 	NODES_LOADED                </td><td>BIGINT </td><td> 0</td><td>				</td><td>&nbsp;</td><td> </td></tr><tr><td>
                 	NODES_DISABLED                </td><td>BIGINT </td><td> 0</td><td>				</td><td>&nbsp;</td><td> </td></tr><tr><td>
                 	PURGED_DATA_ROWS                </td><td>BIGINT </td><td> 0</td><td>				</td><td>&nbsp;</td><td> </td></tr><tr><td>
                 	PURGED_DATA_EVENT_ROWS                </td><td>BIGINT </td><td> 0</td><td>				</td><td>&nbsp;</td><td> </td></tr><tr><td>
                 	PURGED_BATCH_OUTGOING_ROWS                </td><td>BIGINT </td><td> 0</td><td>				</td><td>&nbsp;</td><td> </td></tr><tr><td>
                 	PURGED_BATCH_INCOMING_ROWS                </td><td>BIGINT </td><td> 0</td><td>				</td><td>&nbsp;</td><td> </td></tr><tr><td>
                 	TRIGGERS_CREATED_COUNT                </td><td>BIGINT </td><td>&nbsp;</td><td>				</td><td>&nbsp;</td><td> </td></tr><tr><td>
                 	TRIGGERS_REBUILT_COUNT                </td><td>BIGINT </td><td>&nbsp;</td><td>				</td><td>&nbsp;</td><td> </td></tr><tr><td>
                 	TRIGGERS_REMOVED_COUNT                </td><td>BIGINT </td><td>&nbsp;</td><td>				</td><td>&nbsp;</td><td> </td></tr></tbody></table>
	</div><p class="title"><b>Table&nbsp;A.8.&nbsp;NODE_HOST_STATS</b></p></div><br class="table-break">
</div>

	  	    
<div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="table_node_host_job_stats"></a>A.9.&nbsp;NODE_HOST_JOB_STATS</h2></div></div></div>
    
    <p></p>
	<div class="table"><a name="table-def-node_host_job_stats"></a><div class="table-contents">
    	
    	<table summary="NODE_HOST_JOB_STATS" border="1"><colgroup><col width="115"><col width="50"><col width="30"><col width="18"><col width="18"><col width="150"></colgroup><thead><tr><th>Name</th><th>Type / Size</th><th>Default</th><th>PK FK</th><th>not null</th><th>Description</th></tr></thead><tbody><tr><td>
                 	NODE_ID                </td><td>VARCHAR  (50)</td><td>&nbsp;</td><td>PK				</td><td>X</td><td> A unique identifier for a node.</td></tr><tr><td>
                 	HOST_NAME                </td><td>VARCHAR  (60)</td><td>&nbsp;</td><td>PK				</td><td>X</td><td> The host name of a workstation or server. If more than one instance of SymmetricDS runs on the same server, then this value can be a 'server id' specified by -Druntime.symmetric.cluster.server.id</td></tr><tr><td>
                 	JOB_NAME                </td><td>VARCHAR  (50)</td><td>&nbsp;</td><td>PK				</td><td>X</td><td> </td></tr><tr><td>
                 	START_TIME                </td><td>TIMESTAMP </td><td>&nbsp;</td><td>PK				</td><td>X</td><td> </td></tr><tr><td>
                 	END_TIME                </td><td>TIMESTAMP </td><td>&nbsp;</td><td>PK				</td><td>X</td><td> </td></tr><tr><td>
                 	PROCESSED_COUNT                </td><td>BIGINT </td><td> 0</td><td>				</td><td>&nbsp;</td><td> </td></tr></tbody></table>
	</div><p class="title"><b>Table&nbsp;A.9.&nbsp;NODE_HOST_JOB_STATS</b></p></div><br class="table-break">
</div>

	  	    
<div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="table_channel"></a>A.10.&nbsp;CHANNEL</h2></div></div></div>
    
    <p>This table represents a category of data that can be synchronized independently of other channels. Channels allow control over the type of data flowing and prevents one type of synchronization from contending with another.</p>
	<div class="table"><a name="table-def-channel"></a><div class="table-contents">
    	
    	<table summary="CHANNEL" border="1"><colgroup><col width="115"><col width="50"><col width="30"><col width="18"><col width="18"><col width="150"></colgroup><thead><tr><th>Name</th><th>Type / Size</th><th>Default</th><th>PK FK</th><th>not null</th><th>Description</th></tr></thead><tbody><tr><td>
                 	CHANNEL_ID                </td><td>VARCHAR  (20)</td><td>&nbsp;</td><td>PK				</td><td>X</td><td> A unique identifer, usually named something meaningful, like 'sales' or 'inventory'.</td></tr><tr><td>
                 	PROCESSING_ORDER                </td><td>INTEGER </td><td> 1</td><td>				</td><td>X</td><td> Order of sequence to process channel data.</td></tr><tr><td>
                 	MAX_BATCH_SIZE                </td><td>INTEGER </td><td> 1000</td><td>				</td><td>X</td><td> The maximum number of Data Events to process within a batch for this channel.</td></tr><tr><td>
                 	MAX_BATCH_TO_SEND                </td><td>INTEGER </td><td> 60</td><td>				</td><td>X</td><td> The maximum number of batches to send during a 'synchronization' between two nodes. A 'synchronization' is equivalent to a push or a pull. If there are 12 batches ready to be sent for a channel and max_batch_to_send is equal to 10, then only the first 10 batches will be sent.</td></tr><tr><td>
                 	MAX_DATA_TO_ROUTE                </td><td>INTEGER </td><td> 100000</td><td>				</td><td>X</td><td> The maximum number of data rows to route for a channel at a time.</td></tr><tr><td>
                 	EXTRACT_PERIOD_MILLIS                </td><td>INTEGER </td><td> 0</td><td>				</td><td>X</td><td> The minimum number of milliseconds allowed between attempts to extract data for targeted at a node_id.</td></tr><tr><td>
                 	ENABLED                </td><td>INTEGER  (1)</td><td> 1</td><td>				</td><td>X</td><td> Indicates whether channel is enabled or not.</td></tr><tr><td>
                 	USE_OLD_DATA_TO_ROUTE                </td><td>INTEGER  (1)</td><td> 1</td><td>				</td><td>X</td><td> Indicates whether to read the old data during routing.</td></tr><tr><td>
                 	USE_ROW_DATA_TO_ROUTE                </td><td>INTEGER  (1)</td><td> 1</td><td>				</td><td>X</td><td> Indicates whether to read the row data during routing.</td></tr><tr><td>
                 	USE_PK_DATA_TO_ROUTE                </td><td>INTEGER  (1)</td><td> 1</td><td>				</td><td>X</td><td> Indicates whether to read the pk data during routing.</td></tr><tr><td>
                 	CONTAINS_BIG_LOB                </td><td>INTEGER  (1)</td><td> 0</td><td>				</td><td>X</td><td> Provides SymmetricDS a hint as to whether this channel will contain big lobs data.  Some databases have shortcuts that SymmetricDS can take advantage of if it knows that the lob columns in sym_data aren't going to contain large lobs.  The definition of how big a 'large' lob is will differ from database to database.</td></tr><tr><td>
                 	BATCH_ALGORITHM                </td><td>VARCHAR  (50)</td><td> default</td><td>				</td><td>X</td><td> The algorithm to use when batching data on this channel.  Possible values are: 'default', 'transactional', and 'nontransactional'</td></tr><tr><td>
                 	DESCRIPTION                </td><td>VARCHAR  (255)</td><td>&nbsp;</td><td>				</td><td>&nbsp;</td><td> Description on the type of data carried in this channel.</td></tr></tbody></table>
	</div><p class="title"><b>Table&nbsp;A.10.&nbsp;CHANNEL</b></p></div><br class="table-break">
</div>

	  	    
<div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="table_node_channel_ctl"></a>A.11.&nbsp;NODE_CHANNEL_CTL</h2></div></div></div>
    
    <p>Used to ignore or suspend a channel. A channel that is ignored will have its data_events batched and they will immediately be marked as 'OK' without sending them. A channel that is suspended is skipped when batching data_events.</p>
	<div class="table"><a name="table-def-node_channel_ctl"></a><div class="table-contents">
    	
    	<table summary="NODE_CHANNEL_CTL" border="1"><colgroup><col width="115"><col width="50"><col width="30"><col width="18"><col width="18"><col width="150"></colgroup><thead><tr><th>Name</th><th>Type / Size</th><th>Default</th><th>PK FK</th><th>not null</th><th>Description</th></tr></thead><tbody><tr><td>
                 	NODE_ID                </td><td>VARCHAR  (50)</td><td>&nbsp;</td><td>PK				</td><td>X</td><td> Unique identifier for a node.</td></tr><tr><td>
                 	CHANNEL_ID                </td><td>VARCHAR  (20)</td><td>&nbsp;</td><td>PK				</td><td>X</td><td> The name of the channel_id that is being controlled.</td></tr><tr><td>
                 	SUSPEND_ENABLED                </td><td>INTEGER  (1)</td><td> 0</td><td>				</td><td>&nbsp;</td><td> Indicates if this channel is suspended, which prevents its Data Events from being batched.</td></tr><tr><td>
                 	IGNORE_ENABLED                </td><td>INTEGER  (1)</td><td> 0</td><td>				</td><td>&nbsp;</td><td> Indicates if this channel is ignored, which marks its Data Events as if they were actually processed.</td></tr><tr><td>
                 	LAST_EXTRACT_TIME                </td><td>TIMESTAMP </td><td>&nbsp;</td><td>				</td><td>&nbsp;</td><td> Record the last time data was extract for a node and a channel.</td></tr></tbody></table>
	</div><p class="title"><b>Table&nbsp;A.11.&nbsp;NODE_CHANNEL_CTL</b></p></div><br class="table-break">
</div>

	  	    
<div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="table_node_group_channel_window"></a>A.12.&nbsp;NODE_GROUP_CHANNEL_WINDOW</h2></div></div></div>
    
    <p>An optional window of time for which a node group and channel will be active. </p>
	<div class="table"><a name="table-def-node_group_channel_window"></a><div class="table-contents">
    	
    	<table summary="NODE_GROUP_CHANNEL_WINDOW" border="1"><colgroup><col width="115"><col width="50"><col width="30"><col width="18"><col width="18"><col width="150"></colgroup><thead><tr><th>Name</th><th>Type / Size</th><th>Default</th><th>PK FK</th><th>not null</th><th>Description</th></tr></thead><tbody><tr><td>
                 	NODE_GROUP_ID                </td><td>VARCHAR  (50)</td><td>&nbsp;</td><td>PK				</td><td>X</td><td> The node_group_id that this window applies to.</td></tr><tr><td>
                 	CHANNEL_ID                </td><td>VARCHAR  (20)</td><td>&nbsp;</td><td>PK				</td><td>X</td><td> The channel_id that this window applies to.</td></tr><tr><td>
                 	START_TIME                </td><td>TIME </td><td>&nbsp;</td><td>PK				</td><td>X</td><td> The start time for the active window.</td></tr><tr><td>
                 	END_TIME                </td><td>TIME </td><td>&nbsp;</td><td>PK				</td><td>X</td><td> The end time for the active window.  Note that if the end_time is less than the start_time then the window crosses a day boundary.</td></tr><tr><td>
                 	ENABLED                </td><td>INTEGER  (1)</td><td> 0</td><td>				</td><td>X</td><td> Enable this window.  If this is set to '0' then this window is ignored.</td></tr></tbody></table>
	</div><p class="title"><b>Table&nbsp;A.12.&nbsp;NODE_GROUP_CHANNEL_WINDOW</b></p></div><br class="table-break">
</div>

	  	    
<div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="table_trigger"></a>A.13.&nbsp;TRIGGER</h2></div></div></div>
    
    <p>Configures database triggers that capture changes in the database. Configuration of which triggers are generated for which tables is stored here.  Triggers are created in a node's database if the source_node_group_id of a router is mapped to a row in this table.</p>
	<div class="table"><a name="table-def-trigger"></a><div class="table-contents">
    	
    	<table summary="TRIGGER" border="1"><colgroup><col width="115"><col width="50"><col width="30"><col width="18"><col width="18"><col width="150"></colgroup><thead><tr><th>Name</th><th>Type / Size</th><th>Default</th><th>PK FK</th><th>not null</th><th>Description</th></tr></thead><tbody><tr><td>
                 	TRIGGER_ID                </td><td>VARCHAR  (50)</td><td>&nbsp;</td><td>PK				</td><td>X</td><td> Unique identifier for a trigger.</td></tr><tr><td>
                 	SOURCE_CATALOG_NAME                </td><td>VARCHAR  (50)</td><td>&nbsp;</td><td>				</td><td>&nbsp;</td><td> Optional name for the catalog the configured table is in.</td></tr><tr><td>
                 	SOURCE_SCHEMA_NAME                </td><td>VARCHAR  (50)</td><td>&nbsp;</td><td>				</td><td>&nbsp;</td><td> Optional name for the schema a configured table is in.</td></tr><tr><td>
                 	SOURCE_TABLE_NAME                </td><td>VARCHAR  (50)</td><td>&nbsp;</td><td>				</td><td>X</td><td> The name of the source table that will have a trigger installed to watch for data changes.</td></tr><tr><td>
                 	CHANNEL_ID                </td><td>VARCHAR  (20)</td><td>&nbsp;</td><td>				</td><td>X</td><td> The channel_id of the channel that data changes will flow through.</td></tr><tr><td>
                 	SYNC_ON_UPDATE                </td><td>INTEGER  (1)</td><td> 1</td><td>				</td><td>X</td><td> Whether or not to install an update trigger.</td></tr><tr><td>
                 	SYNC_ON_INSERT                </td><td>INTEGER  (1)</td><td> 1</td><td>				</td><td>X</td><td> Whether or not to install an insert trigger.</td></tr><tr><td>
                 	SYNC_ON_DELETE                </td><td>INTEGER  (1)</td><td> 1</td><td>				</td><td>X</td><td> Whether or not to install an delete trigger.</td></tr><tr><td>
                 	SYNC_ON_INCOMING_BATCH                </td><td>INTEGER  (1)</td><td> 0</td><td>				</td><td>X</td><td> Whether or not an incoming batch that loads data into this table should cause the triggers to capture data_events. Be careful turning this on, because an update loop is possible.</td></tr><tr><td>
                 	NAME_FOR_UPDATE_TRIGGER                </td><td>VARCHAR  (50)</td><td>&nbsp;</td><td>				</td><td>&nbsp;</td><td> Override the default generated name for the update trigger.</td></tr><tr><td>
                 	NAME_FOR_INSERT_TRIGGER                </td><td>VARCHAR  (50)</td><td>&nbsp;</td><td>				</td><td>&nbsp;</td><td> Override the default generated name for the insert trigger.</td></tr><tr><td>
                 	NAME_FOR_DELETE_TRIGGER                </td><td>VARCHAR  (50)</td><td>&nbsp;</td><td>				</td><td>&nbsp;</td><td> Override the default generated name for the delete trigger.</td></tr><tr><td>
                 	SYNC_ON_UPDATE_CONDITION                </td><td>LONGVARCHAR </td><td>&nbsp;</td><td>				</td><td>&nbsp;</td><td> Specify a condition for the update trigger firing using an expression specific to the database.</td></tr><tr><td>
                 	SYNC_ON_INSERT_CONDITION                </td><td>LONGVARCHAR </td><td>&nbsp;</td><td>				</td><td>&nbsp;</td><td> Specify a condition for the insert trigger firing using an expression specific to the database.</td></tr><tr><td>
                 	SYNC_ON_DELETE_CONDITION                </td><td>LONGVARCHAR </td><td>&nbsp;</td><td>				</td><td>&nbsp;</td><td> Specify a condition for the delete trigger firing using an expression specific to the database.</td></tr><tr><td>
                 	EXTERNAL_SELECT                </td><td>LONGVARCHAR </td><td>&nbsp;</td><td>				</td><td>&nbsp;</td><td> Specify a SQL select statement that returns a single result.  It will be used in the generated database trigger to populate the EXTERNAL_DATA field on the data table.</td></tr><tr><td>
                 	TX_ID_EXPRESSION                </td><td>LONGVARCHAR </td><td>&nbsp;</td><td>				</td><td>&nbsp;</td><td> Override the default expression for the transaction identifier that groups the data changes that were committed together.</td></tr><tr><td>
                 	EXCLUDED_COLUMN_NAMES                </td><td>LONGVARCHAR </td><td>&nbsp;</td><td>				</td><td>&nbsp;</td><td> Specify a comma-delimited list of columns that should not be synchronized from this table.  Note that if a primary key is found in this list, it will be ignored.</td></tr><tr><td>
                 	USE_STREAM_LOBS                </td><td>INTEGER  (1)</td><td> 0</td><td>				</td><td>X</td><td> Specifies whether to capture lob data as the trigger is firing or to stream lob columns from the source tables using callbacks during extraction. A value of 1 indicates to stream from the source via callback; a value of 0, lob data is captured by the trigger.</td></tr><tr><td>
                 	USE_CAPTURE_LOBS                </td><td>INTEGER  (1)</td><td> 0</td><td>				</td><td>X</td><td> Provides a hint as to whether this trigger will capture big lobs data.  If set to 1 every effort will be made during data capture in trigger and during data selection for initial load to use lob facilities to extract and store data in the database.</td></tr><tr><td>
                 	CREATE_TIME                </td><td>TIMESTAMP </td><td>&nbsp;</td><td>				</td><td>X</td><td> Timestamp when this entry was created.</td></tr><tr><td>
                 	LAST_UPDATE_BY                </td><td>VARCHAR  (50)</td><td>&nbsp;</td><td>				</td><td>&nbsp;</td><td> The user who last updated this entry.</td></tr><tr><td>
                 	LAST_UPDATE_TIME                </td><td>TIMESTAMP </td><td>&nbsp;</td><td>				</td><td>X</td><td> Timestamp when a user last updated this entry.</td></tr></tbody></table>
	</div><p class="title"><b>Table&nbsp;A.13.&nbsp;TRIGGER</b></p></div><br class="table-break">
</div>

	  	    
<div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="table_router"></a>A.14.&nbsp;ROUTER</h2></div></div></div>
    
    <p>Configure a type of router from one node group to another.  Note that routers are mapped to triggers through trigger_routers.</p>
	<div class="table"><a name="table-def-router"></a><div class="table-contents">
    	
    	<table summary="ROUTER" border="1"><colgroup><col width="115"><col width="50"><col width="30"><col width="18"><col width="18"><col width="150"></colgroup><thead><tr><th>Name</th><th>Type / Size</th><th>Default</th><th>PK FK</th><th>not null</th><th>Description</th></tr></thead><tbody><tr><td>
                 	ROUTER_ID                </td><td>VARCHAR  (50)</td><td>&nbsp;</td><td>PK				</td><td>X</td><td> Unique description of a specific router</td></tr><tr><td>
                 	TARGET_CATALOG_NAME                </td><td>VARCHAR  (50)</td><td>&nbsp;</td><td>				</td><td>&nbsp;</td><td> Optional name for the catalog a target table is in. Only use this if the target table is not in the default catalog.</td></tr><tr><td>
                 	TARGET_SCHEMA_NAME                </td><td>VARCHAR  (50)</td><td>&nbsp;</td><td>				</td><td>&nbsp;</td><td> Optional name of the schema a target table is in. On use this if the target table is not in the default schema.</td></tr><tr><td>
                 	TARGET_TABLE_NAME                </td><td>VARCHAR  (50)</td><td>&nbsp;</td><td>				</td><td>&nbsp;</td><td> Optional name for a target table.  Only use this if the target table name is different than the source.</td></tr><tr><td>
                 	SOURCE_NODE_GROUP_ID                </td><td>VARCHAR  (50)</td><td>&nbsp;</td><td>				</td><td>X</td><td> Routers with this node_group_id will install triggers that are mapped to this router.</td></tr><tr><td>
                 	TARGET_NODE_GROUP_ID                </td><td>VARCHAR  (50)</td><td>&nbsp;</td><td>				</td><td>X</td><td> The node_group_id for nodes to route data to.  Note that routing can be further narrowed down by the configured router_type and router_expression.</td></tr><tr><td>
                 	ROUTER_TYPE                </td><td>VARCHAR  (50)</td><td>&nbsp;</td><td>				</td><td>&nbsp;</td><td> The name of a specific type of router.  Out of the box routers are 'default','column','bsh', and 'subselect.'  Custom routers can be configured as extension points.</td></tr><tr><td>
                 	ROUTER_EXPRESSION                </td><td>LONGVARCHAR </td><td>&nbsp;</td><td>				</td><td>&nbsp;</td><td> An expression that is specific to the type of router that is configured in router_type.  See the documentation for each router for more details.</td></tr><tr><td>
                 	SYNC_ON_UPDATE                </td><td>INTEGER  (1)</td><td> 1</td><td>				</td><td>X</td><td> Flag that indicates that this router should route updates.</td></tr><tr><td>
                 	SYNC_ON_INSERT                </td><td>INTEGER  (1)</td><td> 1</td><td>				</td><td>X</td><td> Flag that indicates that this router should route inserts.</td></tr><tr><td>
                 	SYNC_ON_DELETE                </td><td>INTEGER  (1)</td><td> 1</td><td>				</td><td>X</td><td> Flag that indicates that this router should route deletes.</td></tr><tr><td>
                 	CREATE_TIME                </td><td>TIMESTAMP </td><td>&nbsp;</td><td>				</td><td>X</td><td> Timestamp when this entry was created.</td></tr><tr><td>
                 	LAST_UPDATE_BY                </td><td>VARCHAR  (50)</td><td>&nbsp;</td><td>				</td><td>&nbsp;</td><td> The user who last updated this entry.</td></tr><tr><td>
                 	LAST_UPDATE_TIME                </td><td>TIMESTAMP </td><td>&nbsp;</td><td>				</td><td>X</td><td> Timestamp when a user last updated this entry.</td></tr></tbody></table>
	</div><p class="title"><b>Table&nbsp;A.14.&nbsp;ROUTER</b></p></div><br class="table-break">
</div>

	  	    
<div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="table_trigger_router"></a>A.15.&nbsp;TRIGGER_ROUTER</h2></div></div></div>
    
    <p>Map a trigger to a router.</p>
	<div class="table"><a name="table-def-trigger_router"></a><div class="table-contents">
    	
    	<table summary="TRIGGER_ROUTER" border="1"><colgroup><col width="115"><col width="50"><col width="30"><col width="18"><col width="18"><col width="150"></colgroup><thead><tr><th>Name</th><th>Type / Size</th><th>Default</th><th>PK FK</th><th>not null</th><th>Description</th></tr></thead><tbody><tr><td>
                 	TRIGGER_ID                </td><td>VARCHAR  (50)</td><td>&nbsp;</td><td>PK				</td><td>X</td><td> The id of a trigger.</td></tr><tr><td>
                 	ROUTER_ID                </td><td>VARCHAR  (50)</td><td>&nbsp;</td><td>PK				</td><td>X</td><td> The id of a router.</td></tr><tr><td>
                 	INITIAL_LOAD_ORDER                </td><td>INTEGER </td><td> 1</td><td>				</td><td>X</td><td> Order sequence of this table when an initial load is sent to a node. </td></tr><tr><td>
                 	INITIAL_LOAD_SELECT                </td><td>LONGVARCHAR </td><td>&nbsp;</td><td>				</td><td>&nbsp;</td><td> Optional expression that can be used to pair down the data selected from a table during the initial load process.</td></tr><tr><td>
                 	PING_BACK_ENABLED                </td><td>INTEGER  (1)</td><td> 0</td><td>				</td><td>X</td><td> When enabled, the node will route data that originated from a node back to that node.  This attribute is only effective if sync_on_incoming_batch is set to 1.</td></tr><tr><td>
                 	CREATE_TIME                </td><td>TIMESTAMP </td><td>&nbsp;</td><td>				</td><td>X</td><td> Timestamp when this entry was created.</td></tr><tr><td>
                 	LAST_UPDATE_BY                </td><td>VARCHAR  (50)</td><td>&nbsp;</td><td>				</td><td>&nbsp;</td><td> The user who last updated this entry.</td></tr><tr><td>
                 	LAST_UPDATE_TIME                </td><td>TIMESTAMP </td><td>&nbsp;</td><td>				</td><td>X</td><td> Timestamp when a user last updated this entry.</td></tr></tbody></table>
	</div><p class="title"><b>Table&nbsp;A.15.&nbsp;TRIGGER_ROUTER</b></p></div><br class="table-break">
</div>

	  	    
<div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="table_parameter"></a>A.16.&nbsp;PARAMETER</h2></div></div></div>
    
    <p>Provides a way to manage most SymmetricDS settings in the database.</p>
	<div class="table"><a name="table-def-parameter"></a><div class="table-contents">
    	
    	<table summary="PARAMETER" border="1"><colgroup><col width="115"><col width="50"><col width="30"><col width="18"><col width="18"><col width="150"></colgroup><thead><tr><th>Name</th><th>Type / Size</th><th>Default</th><th>PK FK</th><th>not null</th><th>Description</th></tr></thead><tbody><tr><td>
                 	EXTERNAL_ID                </td><td>VARCHAR  (50)</td><td>&nbsp;</td><td>PK				</td><td>X</td><td> Target the parameter at a specific external id. To target all nodes, use the value of 'ALL.'</td></tr><tr><td>
                 	NODE_GROUP_ID                </td><td>VARCHAR  (50)</td><td>&nbsp;</td><td>PK				</td><td>X</td><td> Target the parameter at a specific node group id. To target all groups, use the value of 'ALL.'</td></tr><tr><td>
                 	PARAM_KEY                </td><td>VARCHAR  (80)</td><td>&nbsp;</td><td>PK				</td><td>X</td><td> The name of the parameter.</td></tr><tr><td>
                 	PARAM_VALUE                </td><td>LONGVARCHAR </td><td>&nbsp;</td><td>				</td><td>&nbsp;</td><td> The value of the parameter.</td></tr></tbody></table>
	</div><p class="title"><b>Table&nbsp;A.16.&nbsp;PARAMETER</b></p></div><br class="table-break">
</div>

	  	    
<div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="table_registration_redirect"></a>A.17.&nbsp;REGISTRATION_REDIRECT</h2></div></div></div>
    
    <p>Provides a way for a centralized registration server to redirect registering nodes to their prospective parent node in a multi-tiered deployment.</p>
	<div class="table"><a name="table-def-registration_redirect"></a><div class="table-contents">
    	
    	<table summary="REGISTRATION_REDIRECT" border="1"><colgroup><col width="115"><col width="50"><col width="30"><col width="18"><col width="18"><col width="150"></colgroup><thead><tr><th>Name</th><th>Type / Size</th><th>Default</th><th>PK FK</th><th>not null</th><th>Description</th></tr></thead><tbody><tr><td>
                 	REGISTRANT_EXTERNAL_ID                </td><td>VARCHAR  (50)</td><td>&nbsp;</td><td>PK				</td><td>X</td><td> Maps the external id of a registration request to a different parent node.</td></tr><tr><td>
                 	REGISTRATION_NODE_ID                </td><td>VARCHAR  (50)</td><td>&nbsp;</td><td>				</td><td>X</td><td> The node_id of the node that a registration request should be redirected to.</td></tr></tbody></table>
	</div><p class="title"><b>Table&nbsp;A.17.&nbsp;REGISTRATION_REDIRECT</b></p></div><br class="table-break">
</div>

	  	    
<div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="table_registration_request"></a>A.18.&nbsp;REGISTRATION_REQUEST</h2></div></div></div>
    
    <p>Audits when a node registers or attempts to register.</p>
	<div class="table"><a name="table-def-registration_request"></a><div class="table-contents">
    	
    	<table summary="REGISTRATION_REQUEST" border="1"><colgroup><col width="115"><col width="50"><col width="30"><col width="18"><col width="18"><col width="150"></colgroup><thead><tr><th>Name</th><th>Type / Size</th><th>Default</th><th>PK FK</th><th>not null</th><th>Description</th></tr></thead><tbody><tr><td>
                 	NODE_GROUP_ID                </td><td>VARCHAR  (50)</td><td>&nbsp;</td><td>				</td><td>&nbsp;</td><td> The node group that this node belongs to, such as 'store'.</td></tr><tr><td>
                 	EXTERNAL_ID                </td><td>VARCHAR  (50)</td><td>&nbsp;</td><td>				</td><td>&nbsp;</td><td> A domain-specific identifier for context within the local system. For example, the retail store number. </td></tr><tr><td>
                 	STATUS                </td><td>CHAR  (2)</td><td>&nbsp;</td><td>				</td><td>X</td><td> The current status of the registration attempt.  Valid statuses are NR (not registered), IG (ignored), OK (sucessful)</td></tr><tr><td>
                 	HOST_NAME                </td><td>VARCHAR  (60)</td><td>&nbsp;</td><td>				</td><td>X</td><td> The host name of a workstation or server. If more than one instance of SymmetricDS runs on the same server, then this value can be a 'server id' specified by -Druntime.symmetric.cluster.server.id</td></tr><tr><td>
                 	IP_ADDRESS                </td><td>VARCHAR  (21)</td><td>&nbsp;</td><td>				</td><td>X</td><td> The ip address for the host.</td></tr><tr><td>
                 	ATTEMPT_COUNT                </td><td>INTEGER </td><td> 0</td><td>				</td><td>&nbsp;</td><td> The number of registration attempts.</td></tr><tr><td>
                 	REGISTERED_NODE_ID                </td><td>VARCHAR  (50)</td><td>&nbsp;</td><td>				</td><td>&nbsp;</td><td> A unique identifier for a node.</td></tr><tr><td>
                 	CREATE_TIME                </td><td>TIMESTAMP </td><td>&nbsp;</td><td>				</td><td>X</td><td> Timestamp when this entry was created.</td></tr><tr><td>
                 	LAST_UPDATE_BY                </td><td>VARCHAR  (50)</td><td>&nbsp;</td><td>				</td><td>&nbsp;</td><td> The user who last updated this entry.</td></tr><tr><td>
                 	LAST_UPDATE_TIME                </td><td>TIMESTAMP </td><td>&nbsp;</td><td>				</td><td>X</td><td> Timestamp when a user last updated this entry.</td></tr></tbody></table>
	</div><p class="title"><b>Table&nbsp;A.18.&nbsp;REGISTRATION_REQUEST</b></p></div><br class="table-break">
</div>

	  	    
<div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="table_trigger_hist"></a>A.19.&nbsp;TRIGGER_HIST</h2></div></div></div>
    
    <p>A history of a table's definition and the trigger used to capture data from the table. When a database trigger captures a data change, it references a trigger_hist entry so it is possible to know which columns the data represents. trigger_hist entries are made during the sync trigger process, which runs at each startup, each night in the syncTriggersJob, or any time the syncTriggers() JMX method is manually invoked. A new entry is made when a table definition or a trigger definition is changed, which causes a database trigger to be created or rebuilt.</p>
	<div class="table"><a name="table-def-trigger_hist"></a><div class="table-contents">
    	
    	<table summary="TRIGGER_HIST" border="1"><colgroup><col width="115"><col width="50"><col width="30"><col width="18"><col width="18"><col width="150"></colgroup><thead><tr><th>Name</th><th>Type / Size</th><th>Default</th><th>PK FK</th><th>not null</th><th>Description</th></tr></thead><tbody><tr><td>
                 	TRIGGER_HIST_ID                </td><td>INTEGER </td><td>&nbsp;</td><td>PK				</td><td>X</td><td> Unique identifier for a trigger_hist entry</td></tr><tr><td>
                 	TRIGGER_ID                </td><td>VARCHAR  (50)</td><td>&nbsp;</td><td>				</td><td>X</td><td> Unique identifier for a trigger</td></tr><tr><td>
                 	SOURCE_TABLE_NAME                </td><td>VARCHAR  (50)</td><td> </td><td>				</td><td>X</td><td> The name of the source table that will have a trigger installed to watch for data changes.</td></tr><tr><td>
                 	SOURCE_CATALOG_NAME                </td><td>VARCHAR  (50)</td><td>&nbsp;</td><td>				</td><td>&nbsp;</td><td> The catalog name where the source table resides.</td></tr><tr><td>
                 	SOURCE_SCHEMA_NAME                </td><td>VARCHAR  (50)</td><td>&nbsp;</td><td>				</td><td>&nbsp;</td><td> The schema name where the source table resides.</td></tr><tr><td>
                 	NAME_FOR_UPDATE_TRIGGER                </td><td>VARCHAR  (50)</td><td>&nbsp;</td><td>				</td><td>X</td><td> The name used when the insert trigger was created.</td></tr><tr><td>
                 	NAME_FOR_INSERT_TRIGGER                </td><td>VARCHAR  (50)</td><td>&nbsp;</td><td>				</td><td>X</td><td> The name used when the update trigger was created.</td></tr><tr><td>
                 	NAME_FOR_DELETE_TRIGGER                </td><td>VARCHAR  (50)</td><td>&nbsp;</td><td>				</td><td>X</td><td> The name used when the delete trigger was created.</td></tr><tr><td>
                 	TABLE_HASH                </td><td>BIGINT </td><td>&nbsp;</td><td>				</td><td>X</td><td>  A hash of the table definition, used to detect changes in the definition.</td></tr><tr><td>
                 	TRIGGER_ROW_HASH                </td><td>BIGINT </td><td>&nbsp;</td><td>				</td><td>X</td><td> A hash of the trigger definition.  If changes are detected to the values that affect a trigger definition, then the trigger will be regenerated.</td></tr><tr><td>
                 	COLUMN_NAMES                </td><td>LONGVARCHAR </td><td>&nbsp;</td><td>				</td><td>X</td><td> The column names defined on the table. The column names are stored in comma-separated values (CSV) format.</td></tr><tr><td>
                 	PK_COLUMN_NAMES                </td><td>LONGVARCHAR </td><td>&nbsp;</td><td>				</td><td>X</td><td> The primary key column names defined on the table. The column names are stored in comma-separated values (CSV) format.</td></tr><tr><td>
                 	LAST_TRIGGER_BUILD_REASON                </td><td>CHAR  (1)</td><td>&nbsp;</td><td>				</td><td>X</td><td> The following reasons for a change are possible: New trigger that has not been created before (N); Schema changes in the table were detected (S); Configuration changes in Trigger (C); Trigger was missing (T).</td></tr><tr><td>
                 	ERROR_MESSAGE                </td><td>LONGVARCHAR </td><td>&nbsp;</td><td>				</td><td>&nbsp;</td><td> Record any errors or warnings that occurred when attempting to build the trigger.</td></tr><tr><td>
                 	CREATE_TIME                </td><td>TIMESTAMP </td><td>&nbsp;</td><td>				</td><td>X</td><td> Timestamp when this entry was created.</td></tr><tr><td>
                 	INACTIVE_TIME                </td><td>TIMESTAMP </td><td>&nbsp;</td><td>				</td><td>&nbsp;</td><td>     The date and time when a trigger was inactivated.</td></tr></tbody></table>
	</div><p class="title"><b>Table&nbsp;A.19.&nbsp;TRIGGER_HIST</b></p></div><br class="table-break">
</div>

	  	    
<div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="table_data"></a>A.20.&nbsp;DATA</h2></div></div></div>
    
    <p>The captured data change that occurred to a row in the database. Entries in data are created by database triggers.</p>
	<div class="table"><a name="table-def-data"></a><div class="table-contents">
    	
    	<table summary="DATA" border="1"><colgroup><col width="115"><col width="50"><col width="30"><col width="18"><col width="18"><col width="150"></colgroup><thead><tr><th>Name</th><th>Type / Size</th><th>Default</th><th>PK FK</th><th>not null</th><th>Description</th></tr></thead><tbody><tr><td>
                 	DATA_ID                </td><td>INTEGER </td><td>&nbsp;</td><td>PK				</td><td>X</td><td> Unique identifier for a data.</td></tr><tr><td>
                 	TABLE_NAME                </td><td>VARCHAR  (50)</td><td>&nbsp;</td><td>				</td><td>X</td><td> The name of the table in which a change occurred that this entry records.</td></tr><tr><td>
                 	EVENT_TYPE                </td><td>CHAR  (1)</td><td>&nbsp;</td><td>				</td><td>X</td><td> The type of event captured by this entry. For triggers, this is the change that occurred, which is 'I' for insert, 'U' for update, or 'D' for delete. Other events include: 'R' for reloading the entire table (or subset of the table) to the node; 'S' for running dynamic SQL at the node, which is used for adhoc administration.</td></tr><tr><td>
                 	ROW_DATA                </td><td>LONGVARCHAR </td><td>&nbsp;</td><td>				</td><td>&nbsp;</td><td> The captured data change from the synchronized table. The column values are stored in comma-separated values (CSV) format.</td></tr><tr><td>
                 	PK_DATA                </td><td>LONGVARCHAR </td><td>&nbsp;</td><td>				</td><td>&nbsp;</td><td> The primary key values of the captured data change from the synchronized table. This data is captured for updates and deletes. The primary key values are stored in comma-separated values (CSV) format.</td></tr><tr><td>
                 	OLD_DATA                </td><td>LONGVARCHAR </td><td>&nbsp;</td><td>				</td><td>&nbsp;</td><td> The captured data values prior to the update.  The column values are stored in CSV format.</td></tr><tr><td>
                 	TRIGGER_HIST_ID                </td><td>INTEGER </td><td>&nbsp;</td><td>				</td><td>X</td><td> The foreign key to the trigger_hist entry that contains the primary key and column names for the table being synchronized.</td></tr><tr><td>
                 	CHANNEL_ID                </td><td>VARCHAR  (20)</td><td>&nbsp;</td><td>				</td><td>&nbsp;</td><td> The channel that this data belongs to, such as 'prices'</td></tr><tr><td>
                 	TRANSACTION_ID                </td><td>VARCHAR  (255)</td><td>&nbsp;</td><td>				</td><td>&nbsp;</td><td> An optional transaction identifier that links multiple data changes together as the same transaction.</td></tr><tr><td>
                 	SOURCE_NODE_ID                </td><td>VARCHAR  (50)</td><td>&nbsp;</td><td>				</td><td>&nbsp;</td><td> If the data was inserted by a SymmetricDS data loader, then the id of the source node is record so that data is not re-routed back to it.</td></tr><tr><td>
                 	EXTERNAL_DATA                </td><td>VARCHAR  (50)</td><td>&nbsp;</td><td>				</td><td>&nbsp;</td><td> A field that can be populated by a trigger that uses the EXTERNAL_SELECT</td></tr><tr><td>
                 	CREATE_TIME                </td><td>TIMESTAMP </td><td>&nbsp;</td><td>				</td><td>&nbsp;</td><td> Timestamp when this entry was created.</td></tr></tbody></table>
	</div><p class="title"><b>Table&nbsp;A.20.&nbsp;DATA</b></p></div><br class="table-break">
</div>

	  	    
<div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="table_data_ref"></a>A.21.&nbsp;DATA_REF</h2></div></div></div>
    
    <p>Used only when routing.data.reader.type is set to 'ref.'  Table that tracks the last known data_id that has been processed.  This table is used so that joins to find unprocessed data can be better optimized.</p>
	<div class="table"><a name="table-def-data_ref"></a><div class="table-contents">
    	
    	<table summary="DATA_REF" border="1"><colgroup><col width="115"><col width="50"><col width="30"><col width="18"><col width="18"><col width="150"></colgroup><thead><tr><th>Name</th><th>Type / Size</th><th>Default</th><th>PK FK</th><th>not null</th><th>Description</th></tr></thead><tbody><tr><td>
                 	REF_DATA_ID                </td><td>INTEGER </td><td>&nbsp;</td><td>PK				</td><td>X</td><td> The data_id that can be used to limit the search of the data table to rows that are greater than this data_id value.</td></tr><tr><td>
                 	REF_TIME                </td><td>TIMESTAMP </td><td>&nbsp;</td><td>				</td><td>&nbsp;</td><td> The time when the ref_data_id was recorded. It is used as the base time to calculate timeouts for gaps in the data_ids.</td></tr></tbody></table>
	</div><p class="title"><b>Table&nbsp;A.21.&nbsp;DATA_REF</b></p></div><br class="table-break">
</div>

	  	    
<div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="table_data_gap"></a>A.22.&nbsp;DATA_GAP</h2></div></div></div>
    
    <p>Used only when routing.data.reader.type is set to 'gap.'  Table that tracks gaps in the data table so that they may be processed efficiently, if data shows up.  Gaps can show up in the data table if a database transaction is rolled back.</p>
	<div class="table"><a name="table-def-data_gap"></a><div class="table-contents">
    	
    	<table summary="DATA_GAP" border="1"><colgroup><col width="115"><col width="50"><col width="30"><col width="18"><col width="18"><col width="150"></colgroup><thead><tr><th>Name</th><th>Type / Size</th><th>Default</th><th>PK FK</th><th>not null</th><th>Description</th></tr></thead><tbody><tr><td>
                 	START_ID                </td><td>INTEGER </td><td>&nbsp;</td><td>PK				</td><td>X</td><td> The first missing data_id from the data table where a gap is detected.  This could be the last data_id inserted plus one.</td></tr><tr><td>
                 	END_ID                </td><td>INTEGER </td><td>&nbsp;</td><td>PK				</td><td>X</td><td> The last missing data_id from the data table where a gap is detected.  If the start_id is the last data_id inserted plus one, then this field is filled in with a -1.</td></tr><tr><td>
                 	STATUS                </td><td>CHAR  (2)</td><td>&nbsp;</td><td>				</td><td>&nbsp;</td><td> GP, SK, or FL.  GP means there is a detected gap.  FL means that the gap has been filled.  SK means that the gap has been skipped either because the gap expired or because no database transaction was detected which means that no data will be committed to fill in the gap.</td></tr><tr><td>
                 	CREATE_TIME                </td><td>TIMESTAMP </td><td>&nbsp;</td><td>				</td><td>X</td><td> Timestamp when this entry was created.</td></tr><tr><td>
                 	LAST_UPDATE_HOSTNAME                </td><td>VARCHAR  (255)</td><td>&nbsp;</td><td>				</td><td>&nbsp;</td><td> The host who last updated this entry.</td></tr><tr><td>
                 	LAST_UPDATE_TIME                </td><td>TIMESTAMP </td><td>&nbsp;</td><td>				</td><td>X</td><td> Timestamp when a user last updated this entry.</td></tr></tbody></table>
	</div><p class="title"><b>Table&nbsp;A.22.&nbsp;DATA_GAP</b></p></div><br class="table-break">
</div>

	  	    
<div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="table_data_event"></a>A.23.&nbsp;DATA_EVENT</h2></div></div></div>
    
    <p>Represents routing of a data row to one or more nodes. Entries in data_event are created by database triggers. </p>
	<div class="table"><a name="table-def-data_event"></a><div class="table-contents">
    	
    	<table summary="DATA_EVENT" border="1"><colgroup><col width="115"><col width="50"><col width="30"><col width="18"><col width="18"><col width="150"></colgroup><thead><tr><th>Name</th><th>Type / Size</th><th>Default</th><th>PK FK</th><th>not null</th><th>Description</th></tr></thead><tbody><tr><td>
                 	DATA_ID                </td><td>INTEGER </td><td>&nbsp;</td><td>PK				</td><td>X</td><td> Id of the data to be routed.</td></tr><tr><td>
                 	BATCH_ID                </td><td>INTEGER </td><td> -1</td><td>PK				</td><td>X</td><td> The node_id of the node that is to receive the data.</td></tr><tr><td>
                 	ROUTER_ID                </td><td>VARCHAR  (50)</td><td>&nbsp;</td><td>PK				</td><td>X</td><td> The router_id of the router that routed this data_event.</td></tr><tr><td>
                 	CREATE_TIME                </td><td>TIMESTAMP </td><td>&nbsp;</td><td>				</td><td>&nbsp;</td><td> Timestamp when this entry was created.</td></tr></tbody></table>
	</div><p class="title"><b>Table&nbsp;A.23.&nbsp;DATA_EVENT</b></p></div><br class="table-break">
</div>

	  	    
<div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="table_outgoing_batch"></a>A.24.&nbsp;OUTGOING_BATCH</h2></div></div></div>
    
    <p>Used for tracking the sending a collection of data to a node in the system. A new outgoing_batch is created and given a status of 'NE'. After sending the outgoing_batch to its target node, the status becomes 'SE'. The node responds with either a success status of 'OK' or an error status of 'ER'. An error while sending to the node also results in an error status of 'ER' regardless of whether the node sends that acknowledgement. </p>
	<div class="table"><a name="table-def-outgoing_batch"></a><div class="table-contents">
    	
    	<table summary="OUTGOING_BATCH" border="1"><colgroup><col width="115"><col width="50"><col width="30"><col width="18"><col width="18"><col width="150"></colgroup><thead><tr><th>Name</th><th>Type / Size</th><th>Default</th><th>PK FK</th><th>not null</th><th>Description</th></tr></thead><tbody><tr><td>
                 	BATCH_ID                </td><td>INTEGER </td><td>&nbsp;</td><td>PK				</td><td>X</td><td> A unique id for the batch.</td></tr><tr><td>
                 	NODE_ID                </td><td>VARCHAR  (50)</td><td>&nbsp;</td><td>				</td><td>&nbsp;</td><td> The node that this batch is targeted at.</td></tr><tr><td>
                 	CHANNEL_ID                </td><td>VARCHAR  (20)</td><td>&nbsp;</td><td>				</td><td>&nbsp;</td><td> The channel that this batch is part of.</td></tr><tr><td>
                 	STATUS                </td><td>CHAR  (2)</td><td>&nbsp;</td><td>				</td><td>&nbsp;</td><td> The current status of the Batch can be currently routing (RE), newly created and ready for replication (NE), being queried from the database (QE), sent to a Node (SE), ready to be loaded (LD) and acknowledged as successful (OK) or error (ER).</td></tr><tr><td>
                 	LOAD_FLAG                </td><td>INTEGER  (1)</td><td> 0</td><td>				</td><td>&nbsp;</td><td> A flag that indicates that this batch is part of an initial load.</td></tr><tr><td>
                 	ERROR_FLAG                </td><td>INTEGER  (1)</td><td> 0</td><td>				</td><td>&nbsp;</td><td> A flag that indicates that this batch was in error during the last synchornization attempt.</td></tr><tr><td>
                 	BYTE_COUNT                </td><td>BIGINT </td><td> 0</td><td>				</td><td>X</td><td> The number of bytes that were sent as part of this batch.</td></tr><tr><td>
                 	EXTRACT_COUNT                </td><td>BIGINT </td><td> 0</td><td>				</td><td>X</td><td> The number of times this an attempt to extract this batch occurred.</td></tr><tr><td>
                 	SENT_COUNT                </td><td>BIGINT </td><td> 0</td><td>				</td><td>X</td><td> The number of times this batch was sent.  A batch can be sent multiple times if an ACK is not received.</td></tr><tr><td>
                 	LOAD_COUNT                </td><td>BIGINT </td><td> 0</td><td>				</td><td>X</td><td> The number of times an attempt to load this batch occurred.</td></tr><tr><td>
                 	DATA_EVENT_COUNT                </td><td>BIGINT </td><td> 0</td><td>				</td><td>X</td><td> The number of data_events that are part of this batch.</td></tr><tr><td>
                 	RELOAD_EVENT_COUNT                </td><td>BIGINT </td><td> 0</td><td>				</td><td>X</td><td> The number of reload events that are part of this batch.</td></tr><tr><td>
                 	INSERT_EVENT_COUNT                </td><td>BIGINT </td><td> 0</td><td>				</td><td>X</td><td> The number of insert events that are part of this batch.</td></tr><tr><td>
                 	UPDATE_EVENT_COUNT                </td><td>BIGINT </td><td> 0</td><td>				</td><td>X</td><td> The number of update events that are part of this batch.</td></tr><tr><td>
                 	DELETE_EVENT_COUNT                </td><td>BIGINT </td><td> 0</td><td>				</td><td>X</td><td> The number of delete events that are part of this batch.</td></tr><tr><td>
                 	OTHER_EVENT_COUNT                </td><td>BIGINT </td><td> 0</td><td>				</td><td>X</td><td> The number of other event types that are part of this batch.  This includes any events types that are not a reload, insert, update or delete event type.</td></tr><tr><td>
                 	ROUTER_MILLIS                </td><td>BIGINT </td><td> 0</td><td>				</td><td>X</td><td> The number of milliseconds spent creating this batch.</td></tr><tr><td>
                 	NETWORK_MILLIS                </td><td>BIGINT </td><td> 0</td><td>				</td><td>X</td><td> The number of milliseconds spent transfering this batch across the network.</td></tr><tr><td>
                 	FILTER_MILLIS                </td><td>BIGINT </td><td> 0</td><td>				</td><td>X</td><td> The number of milliseconds spent in filters processing data.</td></tr><tr><td>
                 	LOAD_MILLIS                </td><td>BIGINT </td><td> 0</td><td>				</td><td>X</td><td> The number of milliseconds spent loading the data into the target database.</td></tr><tr><td>
                 	EXTRACT_MILLIS                </td><td>BIGINT </td><td> 0</td><td>				</td><td>X</td><td> The number of milliseconds spent extracting the data out of the source database.</td></tr><tr><td>
                 	SQL_STATE                </td><td>VARCHAR  (10)</td><td>&nbsp;</td><td>				</td><td>&nbsp;</td><td> For a status of error (ER), this is the XOPEN or SQL 99 SQL State.</td></tr><tr><td>
                 	SQL_CODE                </td><td>INTEGER </td><td> 0</td><td>				</td><td>X</td><td> For a status of error (ER), this is the error code from the database that is specific to the vendor. </td></tr><tr><td>
                 	SQL_MESSAGE                </td><td>LONGVARCHAR </td><td>&nbsp;</td><td>				</td><td>&nbsp;</td><td> For a status of error (ER), this is the error message that describes the error.</td></tr><tr><td>
                 	FAILED_DATA_ID                </td><td>BIGINT </td><td> 0</td><td>				</td><td>X</td><td> For a status of error (ER), this is the data_id that was being processed when the batch failed.</td></tr><tr><td>
                 	LAST_UPDATE_HOSTNAME                </td><td>VARCHAR  (255)</td><td>&nbsp;</td><td>				</td><td>&nbsp;</td><td> The host name of the process that last did work on this batch.</td></tr><tr><td>
                 	LAST_UPDATE_TIME                </td><td>TIMESTAMP </td><td>&nbsp;</td><td>				</td><td>&nbsp;</td><td> Timestamp when a process last updated this entry.</td></tr><tr><td>
                 	CREATE_TIME                </td><td>TIMESTAMP </td><td>&nbsp;</td><td>				</td><td>&nbsp;</td><td> Timestamp when this entry was created.</td></tr></tbody></table>
	</div><p class="title"><b>Table&nbsp;A.24.&nbsp;OUTGOING_BATCH</b></p></div><br class="table-break">
</div>

	  	    
<div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="table_incoming_batch"></a>A.25.&nbsp;INCOMING_BATCH</h2></div></div></div>
    
    <p>The incoming_batch is used for tracking the status of loading an outgoing_batch from another node. Data is loaded and commited at the batch level. The status of the incoming_batch is either successful (OK) or error (ER). </p>
	<div class="table"><a name="table-def-incoming_batch"></a><div class="table-contents">
    	
    	<table summary="INCOMING_BATCH" border="1"><colgroup><col width="115"><col width="50"><col width="30"><col width="18"><col width="18"><col width="150"></colgroup><thead><tr><th>Name</th><th>Type / Size</th><th>Default</th><th>PK FK</th><th>not null</th><th>Description</th></tr></thead><tbody><tr><td>
                 	BATCH_ID                </td><td>INTEGER  (50)</td><td>&nbsp;</td><td>PK				</td><td>X</td><td> The id of the outgoing_batch that is being loaded.</td></tr><tr><td>
                 	NODE_ID                </td><td>VARCHAR  (50)</td><td>&nbsp;</td><td>PK				</td><td>X</td><td> The node_id of the source of the batch being loaded.</td></tr><tr><td>
                 	CHANNEL_ID                </td><td>VARCHAR  (20)</td><td>&nbsp;</td><td>				</td><td>&nbsp;</td><td> The channel_id of the batch being loaded.</td></tr><tr><td>
                 	STATUS                </td><td>CHAR  (2)</td><td>&nbsp;</td><td>				</td><td>&nbsp;</td><td> The current status of the batch can be loading (LD), successfully loaded (OK), in error (ER) or skipped (SK)</td></tr><tr><td>
                 	ERROR_FLAG                </td><td>INTEGER  (1)</td><td> 0</td><td>				</td><td>&nbsp;</td><td> A flag that indicates that this batch was in error during the last synchornization attempt.</td></tr><tr><td>
                 	NETWORK_MILLIS                </td><td>BIGINT </td><td> 0</td><td>				</td><td>X</td><td> The number of milliseconds spent transfering this batch across the network.</td></tr><tr><td>
                 	FILTER_MILLIS                </td><td>BIGINT </td><td> 0</td><td>				</td><td>X</td><td> The number of milliseconds spent in filters processing data.</td></tr><tr><td>
                 	DATABASE_MILLIS                </td><td>BIGINT </td><td> 0</td><td>				</td><td>X</td><td> The number of milliseconds spent loading the data into the target database.</td></tr><tr><td>
                 	FAILED_ROW_NUMBER                </td><td>BIGINT </td><td> 0</td><td>				</td><td>X</td><td> For a status of error (ER), this is the data_id that was being processed when the batch failed.</td></tr><tr><td>
                 	BYTE_COUNT                </td><td>BIGINT </td><td> 0</td><td>				</td><td>X</td><td> The number of bytes that were sent as part of this batch.</td></tr><tr><td>
                 	STATEMENT_COUNT                </td><td>BIGINT </td><td> 0</td><td>				</td><td>X</td><td> The number of statements run to load this batch.</td></tr><tr><td>
                 	FALLBACK_INSERT_COUNT                </td><td>BIGINT </td><td> 0</td><td>				</td><td>X</td><td> The number of times an update was turned into an insert because the data was not already in the target database.</td></tr><tr><td>
                 	FALLBACK_UPDATE_COUNT                </td><td>BIGINT </td><td> 0</td><td>				</td><td>X</td><td> The number of times an insert was turned into an update because a data row already existed in the target database.</td></tr><tr><td>
                 	MISSING_DELETE_COUNT                </td><td>BIGINT </td><td> 0</td><td>				</td><td>X</td><td> THe number of times a delete did not effect the database because the row was already deleted.</td></tr><tr><td>
                 	SKIP_COUNT                </td><td>BIGINT </td><td> 0</td><td>				</td><td>X</td><td> The number of times a batch was sent and skipped because it had already been loaded according to incoming_batch</td></tr><tr><td>
                 	SQL_STATE                </td><td>VARCHAR  (10)</td><td>&nbsp;</td><td>				</td><td>&nbsp;</td><td> For a status of error (ER), this is the XOPEN or SQL 99 SQL State.</td></tr><tr><td>
                 	SQL_CODE                </td><td>INTEGER </td><td> 0</td><td>				</td><td>X</td><td> For a status of error (ER), this is the error code from the database that is specific to the vendor. </td></tr><tr><td>
                 	SQL_MESSAGE                </td><td>LONGVARCHAR </td><td>&nbsp;</td><td>				</td><td>&nbsp;</td><td> For a status of error (ER), this is the error message that describes the error.</td></tr><tr><td>
                 	LAST_UPDATE_HOSTNAME                </td><td>VARCHAR  (255)</td><td>&nbsp;</td><td>				</td><td>&nbsp;</td><td> The host name of the process that last did work on this batch.</td></tr><tr><td>
                 	LAST_UPDATE_TIME                </td><td>TIMESTAMP </td><td>&nbsp;</td><td>				</td><td>&nbsp;</td><td> Timestamp when a process last updated this entry.</td></tr><tr><td>
                 	CREATE_TIME                </td><td>TIMESTAMP </td><td>&nbsp;</td><td>				</td><td>&nbsp;</td><td> Timestamp when this entry was created.</td></tr></tbody></table>
	</div><p class="title"><b>Table&nbsp;A.25.&nbsp;INCOMING_BATCH</b></p></div><br class="table-break">
</div>

	  	    
<div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="table_lock"></a>A.26.&nbsp;LOCK</h2></div></div></div>
    
    <p>Contains semaphores that are set when processes run, so that only one server can run a process at a time.  Enable this feature by using the cluster.lock.during.xxxx parameters.</p>
	<div class="table"><a name="table-def-lock"></a><div class="table-contents">
    	
    	<table summary="LOCK" border="1"><colgroup><col width="115"><col width="50"><col width="30"><col width="18"><col width="18"><col width="150"></colgroup><thead><tr><th>Name</th><th>Type / Size</th><th>Default</th><th>PK FK</th><th>not null</th><th>Description</th></tr></thead><tbody><tr><td>
                 	LOCK_ACTION                </td><td>VARCHAR  (50)</td><td>&nbsp;</td><td>PK				</td><td>X</td><td> The process that needs a lock.</td></tr><tr><td>
                 	LOCKING_SERVER_ID                </td><td>VARCHAR  (255)</td><td>&nbsp;</td><td>				</td><td>&nbsp;</td><td> The name of the server that currently has a lock.  This is typically a host name, but it can be overridden using the -Druntime.symmetric.cluster.server.id=name System property.</td></tr><tr><td>
                 	LOCK_TIME                </td><td>TIMESTAMP </td><td>&nbsp;</td><td>				</td><td>&nbsp;</td><td> The time a lock is aquired.  Use the cluster.lock.timeout.ms to specify a lock timeout period.</td></tr><tr><td>
                 	LAST_LOCK_TIME                </td><td>TIMESTAMP </td><td>&nbsp;</td><td>				</td><td>&nbsp;</td><td> Timestamp when a process last updated this entry.</td></tr><tr><td>
                 	LAST_LOCKING_SERVER_ID                </td><td>VARCHAR  (255)</td><td>&nbsp;</td><td>				</td><td>&nbsp;</td><td> The server id of the process that last did work on this batch.</td></tr></tbody></table>
	</div><p class="title"><b>Table&nbsp;A.26.&nbsp;LOCK</b></p></div><br class="table-break">
</div>

	  	    
<div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="table_transform_table"></a>A.27.&nbsp;TRANSFORM_TABLE</h2></div></div></div>
    
    <p>Defines a data loader transformation which can be used to map arbitrary tables and columns to other tables and columns.</p>
	<div class="table"><a name="table-def-transform_table"></a><div class="table-contents">
    	
    	<table summary="TRANSFORM_TABLE" border="1"><colgroup><col width="115"><col width="50"><col width="30"><col width="18"><col width="18"><col width="150"></colgroup><thead><tr><th>Name</th><th>Type / Size</th><th>Default</th><th>PK FK</th><th>not null</th><th>Description</th></tr></thead><tbody><tr><td>
                 	TRANSFORM_ID                </td><td>VARCHAR  (50)</td><td>&nbsp;</td><td>PK				</td><td>X</td><td> Unique identifier of a specific transform.</td></tr><tr><td>
                 	SOURCE_NODE_GROUP_ID                </td><td>VARCHAR  (50)</td><td>&nbsp;</td><td>PK				</td><td>X</td><td> The node group where data changes should be captured.</td></tr><tr><td>
                 	TARGET_NODE_GROUP_ID                </td><td>VARCHAR  (50)</td><td>&nbsp;</td><td>PK				</td><td>X</td><td> The node group where data changes will be sent.</td></tr><tr><td>
                 	TRANSFORM_POINT                </td><td>VARCHAR  (10)</td><td>&nbsp;</td><td>				</td><td>X</td><td> The point during the transport of captured data that a transform happens.  Support values are EXTRACT or LOAD.</td></tr><tr><td>
                 	SOURCE_CATALOG_NAME                </td><td>VARCHAR  (128)</td><td>&nbsp;</td><td>				</td><td>&nbsp;</td><td> Optional name for the catalog the configured table is in.</td></tr><tr><td>
                 	SOURCE_SCHEMA_NAME                </td><td>VARCHAR  (128)</td><td>&nbsp;</td><td>				</td><td>&nbsp;</td><td> Optional name for the schema a configured table is in.</td></tr><tr><td>
                 	SOURCE_TABLE_NAME                </td><td>VARCHAR  (128)</td><td>&nbsp;</td><td>				</td><td>X</td><td> The name of the source table that will be transformed.</td></tr><tr><td>
                 	TARGET_CATALOG_NAME                </td><td>VARCHAR  (128)</td><td>&nbsp;</td><td>				</td><td>&nbsp;</td><td> Optional name for the catalog a target table is in. Only use this if the target table is not in the default catalog.</td></tr><tr><td>
                 	TARGET_SCHEMA_NAME                </td><td>VARCHAR  (128)</td><td>&nbsp;</td><td>				</td><td>&nbsp;</td><td> Optional name of the schema a target table is in. Only use this if the target table is not in the default schema.</td></tr><tr><td>
                 	TARGET_TABLE_NAME                </td><td>VARCHAR  (128)</td><td>&nbsp;</td><td>				</td><td>&nbsp;</td><td> Optional name for a target table.  Use this if the target table name is different than the source.</td></tr><tr><td>
                 	UPDATE_FIRST                </td><td>INTEGER  (1)</td><td> 0</td><td>				</td><td>&nbsp;</td><td> If true, the target actions are attempted as updates first, regardless of whether the source operation was an insert or an update.</td></tr><tr><td>
                 	DELETE_ACTION                </td><td>VARCHAR  (10)</td><td>&nbsp;</td><td>				</td><td>X</td><td> An action to take upon delete of a row.</td></tr><tr><td>
                 	TRANSFORM_ORDER                </td><td>INTEGER </td><td> 1</td><td>				</td><td>X</td><td> Specifies the order in which to apply transforms if more than one target operation occurs.</td></tr></tbody></table>
	</div><p class="title"><b>Table&nbsp;A.27.&nbsp;TRANSFORM_TABLE</b></p></div><br class="table-break">
</div>

	  	    
<div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="table_transform_column"></a>A.28.&nbsp;TRANSFORM_COLUMN</h2></div></div></div>
    
    <p>Defines the column mappings and optional data transformation for a data loader transformation </p>
	<div class="table"><a name="table-def-transform_column"></a><div class="table-contents">
    	
    	<table summary="TRANSFORM_COLUMN" border="1"><colgroup><col width="115"><col width="50"><col width="30"><col width="18"><col width="18"><col width="150"></colgroup><thead><tr><th>Name</th><th>Type / Size</th><th>Default</th><th>PK FK</th><th>not null</th><th>Description</th></tr></thead><tbody><tr><td>
                 	TRANSFORM_ID                </td><td>VARCHAR  (50)</td><td>&nbsp;</td><td>PK				</td><td>X</td><td> Unique identifier of a specific transform.</td></tr><tr><td>
                 	INCLUDE_ON                </td><td>CHAR  (1)</td><td> *</td><td>PK				</td><td>X</td><td> Indicates whether this mapping is included during an insert (I), update (U), delete (D) operation at the target based on the dml type at the source.  A value of * represents the fact that you want to map the column for all operations.</td></tr><tr><td>
                 	TARGET_COLUMN_NAME                </td><td>VARCHAR  (128)</td><td>&nbsp;</td><td>PK				</td><td>X</td><td> Name of the target column.</td></tr><tr><td>
                 	SOURCE_COLUMN_NAME                </td><td>VARCHAR  (128)</td><td>&nbsp;</td><td>				</td><td>&nbsp;</td><td> Name of the source column.</td></tr><tr><td>
                 	PK                </td><td>INTEGER  (1)</td><td> 0</td><td>				</td><td>&nbsp;</td><td> Indicates whether this mapping defines a primary key to be used to identify the target row.  At least one row must be defined as a pk for each transform_id.</td></tr><tr><td>
                 	TRANSFORM_TYPE                </td><td>VARCHAR  (50)</td><td> copy</td><td>				</td><td>&nbsp;</td><td> The name of a specific type of transform.  Custom transformers can be configured as extension points.</td></tr><tr><td>
                 	TRANSFORM_EXPRESSION                </td><td>LONGVARCHAR </td><td>&nbsp;</td><td>				</td><td>&nbsp;</td><td> An expression that is specific to the type of transform that is configured in transform_type.  See the documentation for each transformer for more details.</td></tr><tr><td>
                 	TRANSFORM_ORDER                </td><td>INTEGER </td><td> 1</td><td>				</td><td>X</td><td> Specifies the order in which to apply transforms if more than one target operation occurs.</td></tr></tbody></table>
	</div><p class="title"><b>Table&nbsp;A.28.&nbsp;TRANSFORM_COLUMN</b></p></div><br class="table-break">
</div>

	  
</div>
    <div class="appendix" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="parameters"></a>Appendix&nbsp;B.&nbsp;Parameters</h2></div></div></div>
    
    <p>
        There are two kinds of parameters that can be used to configure the behavior of SymmetricDS:
        <span class="emphasis"><em>Startup Parameters</em></span> and <span class="emphasis"><em>Runtime Parameters</em></span>.
        Startup Parameters are required to be in a system property or a property file, while 
        Runtime Parameters can also be found in the Parameter table from the database.
        Parameters are re-queried from their source at a configured interval and can 
        also be refreshed on demand by using the JMX API.  
        The following table shows the source of parameters and the hierarchy of precedence.
        </p><div class="table"><a name="d4e4257"></a><div class="table-contents">
            
            <table summary="Parameter Locations" border="1"><colgroup><col width="115"><col width="50"><col width="220"></colgroup><thead><tr><th>Location</th><th>Required</th><th>Description</th></tr></thead><tbody><tr><td>
                            <span class="emphasis"><em>symmetric-default.properties</em></span>
                        </td><td>Y</td><td>
                            Packaged inside symmetric-ds.jar file. This file has all the default
                            settings along with descriptions.
                        </td></tr><tr><td>
                            <span class="emphasis"><em>symmetric.properties</em></span>
                        </td><td>N</td><td>
                            Provided by the end user on the classpath. The first
                            symmetric.properties found on the classpath will be used.
                        </td></tr><tr><td>
                            <span class="emphasis"><em>symmetric.properties</em></span>
                        </td><td>N</td><td>
                            Provided by the end user in the current system user's user.home
                            directory.
                        </td></tr><tr><td>
                            <span class="emphasis"><em>named properties file 1</em></span>
                        </td><td>N</td><td>
                            Provided by the end user as a Java system property (i.e.
                            -Dsymmetric.override.properties.file.1=file://my.properties) or in
                            the constructor of a
                            <code class="literal">SymmetricEngine</code>
                            .
                        </td></tr><tr><td>
                            <span class="emphasis"><em>named properties file 2</em></span>
                        </td><td>N</td><td>
                            Provided by the end user as a Java system property (i.e.
                            -Dsymmetric.override.properties.file.2=classpath://my.properties) or
                            in the constructor of a
                            <code class="literal">SymmetricEngine</code>
                            .
                        </td></tr><tr><td>
                            <span class="emphasis"><em>Java System Properties</em></span>
                        </td><td>N</td><td>
                            Any SymmetricDS property can be passed in as a -D property to the
                            runtime. It will take precedence over any properties file property.
                        </td></tr><tr><td>
                            <span class="emphasis"><em>Parameter table</em></span>
                        </td><td>N</td><td>
                            A table which contains SymmetricDS parameters. Parameters can be targeted at a specific node group and
                            even at a specific external id.  These settings will take precedence over all of the above.
                        </td></tr><tr><td>
                            <span class="emphasis"><em>IParameterFilter</em></span>
                        </td><td>N</td><td>
                            An extension point which allows parameters to be sourced from another location or customized.  
                            These settings will take precedence over all of the above.
                        </td></tr></tbody></table>
        </div><p class="title"><b>Table&nbsp;B.1.&nbsp;Parameter Locations</b></p></div><p><br class="table-break">
    </p>

    <div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="ap01-startup"></a>B.1.&nbsp;Startup Parameters</h2></div></div></div>
        
        <p>
            Startup parameters are read once from properties files and apply only during start up.
            The following properties are used:
    
            </p><div class="variablelist"><dl><dt><span class="term">
                        <span><strong class="command">db.jndi.name</strong></span>
                    </span></dt><dd>
                        <p>
                            The name of the database connection pool to use, which is registered in the JNDI
                            directory tree of the application server. It is recommended that this DataSource is
                            NOT transactional, because SymmetricDS will handle its own transactions. If NOT using
                            a JNDI connection pool, you must provide information about the database connection
                            using the
                            <code class="literal">db.driver</code>
                            ,
                            <code class="literal">db.url</code>
                            ,
                            <code class="literal">db.user</code>
                            , and
                            <code class="literal">db.password</code>
                            properties instead, which will create a pool of connections using the
                            <code class="literal">db.pool</code>
                            properties. [&nbsp;Default:&nbsp;]
                        </p>
                    </dd><dt><span class="term">
                        <span><strong class="command">db.driver</strong></span>
                    </span></dt><dd>
                        <p>
                            The class name of the JDBC driver. If
                            <code class="literal">db.jndi.name</code>
                            is set, this property is ignored. [&nbsp;Default:&nbsp;com.mysql.jdbc.Driver&nbsp;]
                        </p>
                    </dd><dt><span class="term">
                        <span><strong class="command">db.url</strong></span>
                    </span></dt><dd>
                        <p>
                            The JDBC URL used to connect to the database. If
                            <code class="literal">db.jndi.name</code>
                            is set, this property is ignored.
                            [&nbsp;Default:&nbsp;jdbc:mysql://localhost/symmetric&nbsp;]
                        </p>
                    </dd><dt><span class="term">
                        <span><strong class="command">db.user</strong></span>
                    </span></dt><dd>
                        <p>
                            The database username, which is used to login, create, and update SymmetricDS tables.
                            To use an encrypted username, see <a href="#encrypted-passwords" title="5.7.&nbsp;Encrypted Passwords">Section&nbsp;5.7, &#8220;Encrypted Passwords&#8221;</a>.
                            If
                            <code class="literal">db.jndi.name</code>
                            is set, this property is ignored. [&nbsp;Default:&nbsp;symmetric&nbsp;]
                        </p>
                    </dd><dt><span class="term">
                        <span><strong class="command">db.password</strong></span>
                    </span></dt><dd>
                        <p>
                            The password for the database user. 
                            To use an encrypted password, see <a href="#encrypted-passwords" title="5.7.&nbsp;Encrypted Passwords">Section&nbsp;5.7, &#8220;Encrypted Passwords&#8221;</a>.
                            If
                            <code class="literal">db.jndi.name</code>
                            is set, this property is ignored. [&nbsp;Default:&nbsp;]
                        </p>
                    </dd><dt><span class="term">
                        <span><strong class="command">db.pool.initial.size</strong></span>
                    </span></dt><dd>
                        <p>
                            The initial size of the connection pool. If
                            <code class="literal">db.jndi.name</code>
                            is set, this property is ignored. [&nbsp;Default:&nbsp;5&nbsp;]
                        </p>
                    </dd><dt><span class="term">
                        <span><strong class="command">db.pool.max.active</strong></span>
                    </span></dt><dd>
                        <p>
                            The maximum number of connections that will be allocated in the pool. If
                            <code class="literal">db.jndi.name</code>
                            is set, this property is ignored. [&nbsp;Default:&nbsp;10&nbsp;]
                        </p>
                    </dd><dt><span class="term">
                        <span><strong class="command">db.pool.max.wait.millis</strong></span>
                    </span></dt><dd>
                        <p>
                            This is how long a request for a connection from the datasource will wait before
                            giving up. If
                            <code class="literal">db.jndi.name</code>
                            is set, this property is ignored. [&nbsp;Default:&nbsp;30000&nbsp;]
                        </p>
                    </dd><dt><span class="term">
                        <span><strong class="command">db.pool.min.evictable.idle.millis</strong></span>
                    </span></dt><dd>
                        <p>
                            This is how long a connection can be idle before it will be evicted. If
                            <code class="literal">db.jndi.name</code>
                            is set, this property is ignored. [&nbsp;Default:&nbsp;120000&nbsp;]
                        </p>
                    </dd><dt><span class="term">
                        <span><strong class="command">db.spring.bean.name</strong></span>
                    </span></dt><dd>
                        <p>
                            The name of a Spring bean to use as the DataSource.  If you want to use a different
                            DataSource other than the provided DBCP version that SymmetricDS uses out of the box,
                            you may set this to be the Spring bean name of your DataSource.
                        </p>
                    </dd><dt><span class="term">
                        <span><strong class="command">db.sql.query.timeout.seconds</strong></span>
                    </span></dt><dd>
                        <p>
                            The timeout in seconds for queries running on the database.
                            [&nbsp;Default:&nbsp;300&nbsp;]
                        </p>
                    </dd><dt><span class="term">
                        <span><strong class="command">db.tx.timeout.seconds</strong></span>
                    </span></dt><dd>
                        <p>
                            This is how long the default transaction time is. This needs to be fairly big to
                            account for large data loads. [&nbsp;Default:&nbsp;7200&nbsp;]
                        </p>
                    </dd><dt><span class="term">
                        <span><strong class="command">db.jdbc.streaming.results.fetch.size</strong></span>
                    </span></dt><dd>
                        <p>
                            This is the default fetch size for streaming result sets into memory from the
                            database. [&nbsp;Default:&nbsp;1000&nbsp;]
                        </p>
                    </dd><dt><span class="term">
                        <span><strong class="command">db.default.schema</strong></span>
                    </span></dt><dd>
                        <p>
                            This is the schema that will be used for metadata lookup. Some dialect automatically 
                            figure this out using database specific SQL to get the current schema. [&nbsp;Default:&nbsp;&nbsp;]
                        </p>
                    </dd><dt><span class="term">
                        <span><strong class="command">db.metadata.ignore.case</strong></span>
                    </span></dt><dd>
                        <p>
                             Indicates that case should be ignored when looking up references to 
                             tables using the metadata api. [&nbsp;Default:&nbsp;true&nbsp;]
                        </p>
                    </dd><dt><span class="term">
                        <span><strong class="command">auto.config.database</strong></span>
                    </span></dt><dd>
                        <p>
                            If this is true, the configuration and runtime tables used by SymmetricDS are
                            automatically created during startup. [&nbsp;Default:&nbsp;true&nbsp;]
                        </p>
                    </dd><dt><span class="term">
                        <span><strong class="command">auto.upgrade</strong></span>
                    </span></dt><dd>
                        <p>
                            If this is true, when symmetric starts up it will try to upgrade tables to latest version.
                            [&nbsp;Default:&nbsp;true&nbsp;]
                        </p>
                    </dd><dt><span class="term">
                        <span><strong class="command">auto.sync.configuration</strong></span>
                    </span></dt><dd>
                        <p>
                            If this is true, create triggers for the SymmetricDS configuration table that 
                            will synchronize changes to node groups that pull from the node where this 
                            property is set.
                            [&nbsp;Default:&nbsp;true&nbsp;]
                        </p>
                    </dd><dt><span class="term">
                        <span><strong class="command">https.allow.self.signed.certs</strong></span>
                    </span></dt><dd>
                        <p>
                            If this is true, a Symmetric client node to accept self signed
                            certificates.
                            [&nbsp;Default:&nbsp;true&nbsp;]
                        </p>
                    </dd><dt><span class="term">
                        <span><strong class="command">http.basic.auth.username</strong></span>
                    </span></dt><dd>
                        <p>
                            If specified, a Symmetric client node will use basic authentication
                            when communicating with its server node using the given user name.
                            [&nbsp;Default:&nbsp;]
                        </p>
                    </dd><dt><span class="term">
                        <span><strong class="command">http.basic.auth.password</strong></span>
                    </span></dt><dd>
                        <p>
                            If specified, the password used for basic authentication.
                            [&nbsp;Default:&nbsp;]
                        </p>
                    </dd><dt><span class="term">
                        <span><strong class="command">embedded.webserver.basic.auth.username</strong></span>
                    </span></dt><dd>
                        <p>
                            If specified, the username for basic authentication for an embedded server
                            or standalone server node.  Specifying the username and password is all
                            that's needed to enable basic authentication for an embedded server or
                            standalone server node.
                            [&nbsp;Default:&nbsp;]
                        </p>
                    </dd><dt><span class="term">
                        <span><strong class="command">embedded.webserver.basic.auth.password</strong></span>
                    </span></dt><dd>
                        <p>
                            If specified, the password for basic authentication for an embedded server
                            or standalone server node.
                            [&nbsp;Default:&nbsp;]
                        </p>
                    </dd><dt><span class="term">
                        <span><strong class="command">https.verified.server.names</strong></span>
                    </span></dt><dd>
                        <p>
                            A list of comma separated server names that will always verify when using https.
                            This is useful if the URL's hostname and the server's identification hostname 
                            don't match exactly using the default rules for the JRE.  A special value
                            of "all" may be specified to allow all hostnames to verify.
                            [&nbsp;Default:&nbsp;]
                        </p>
                    </dd><dt><span class="term">
                        <span><strong class="command">sync.table.prefix</strong></span>
                    </span></dt><dd>
                        <p>
                            When symmetric tables are created and accessed, this is the prefix to use for the
                            table name. [&nbsp;Default:&nbsp;sym&nbsp;]
                        </p>
                    </dd><dt><span class="term">
                        <span><strong class="command">engine.name</strong></span>
                    </span></dt><dd>
                        <p>
                            This is the engine name. This should be set if you have more than one engine running
                            in the same JVM. It is used to name the JMX management bean.
                            [&nbsp;Default:&nbsp;Default&nbsp;]
                        </p>
                    </dd><dt><span class="term">
                        <span><strong class="command">start.push.job</strong></span>
                    </span></dt><dd>
                        <p>Whether the push job is enabled for this node. [&nbsp;Default:&nbsp;true]</p>
                    </dd><dt><span class="term">
                        <span><strong class="command">start.pull.job</strong></span>
                    </span></dt><dd>
                        <p>
                            Whether the pull job is enabled for this node. [&nbsp;Default:&nbsp;true&nbsp;]
                        </p>
                    </dd><dt><span class="term">
                        <span><strong class="command">start.purge.job</strong></span>
                    </span></dt><dd>
                        <p>
                            Whether the purge job is enabled for this node. [&nbsp;Default:&nbsp;true&nbsp;]
                        </p>
                    </dd><dt><span class="term">
                        <span><strong class="command">start.synctriggers.job</strong></span>
                    </span></dt><dd>
                        <p>
                            Whether the sync triggers job is enabled for this node.
                            [&nbsp;Default:&nbsp;true&nbsp;]
                        </p>
                    </dd><dt><span class="term">
                        <span><strong class="command">start.heartbeat.job</strong></span>
                    </span></dt><dd>
                        <p>
                            Whether the heartbeat job is enabled for this node. The heartbeat job simply inserts
                            an event to update the heartbeat_time column on the node table for the current node.
                            [&nbsp;Default:&nbsp;true&nbsp;]
                        </p>
                    </dd><dt><span class="term">
                        <span><strong class="command">start.watchdog.job</strong></span>
                    </span></dt><dd>
                        <p>
                            Whether the watchdog job is enabled for this node. The watchdog job monitors child
                            nodes to detect if they are offline.  Refer to 
                            <a href="#extensions-offline-server-listener" title="6.15.&nbsp;IOfflineServerListener">Section&nbsp;6.15, &#8220;IOfflineServerListener&#8221;</a> for
                            more information.
                            [&nbsp;Default:&nbsp;true&nbsp;]
                        </p>
                    </dd><dt><span class="term">
                        <span><strong class="command">job.purge.period.time.ms</strong></span>
                    </span></dt><dd>
                        <p>
                            This is how often the purge job will be run. [&nbsp;Default:&nbsp;600000&nbsp;]
                        </p>
                    </dd><dt><span class="term">
                        <span><strong class="command">job.statflush.period.time.ms</strong></span>
                    </span></dt><dd>
                        <p>
                            This is how often accumulated statistics will be flushed out to the database from memory.
                            [&nbsp;Default:&nbsp;600000&nbsp;]
                        </p>
                    </dd><dt><span class="term">
                        <span><strong class="command">web.base.servlet.path</strong></span>
                    </span></dt><dd>
                        <p>
                            The base servlet path for when embedding SymmetricDS with in another web application.
                            [&nbsp;Default:&nbsp;&nbsp;]
                        </p>
                    </dd></dl></div><p>
        </p>            
    </div>

    <div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="ap01-runtime"></a>B.2.&nbsp;Runtime Parameters</h2></div></div></div>
        
        <p>
            Runtime parameters are read periodically from properties files or the database.
            The following properties are used:
    
            </p><div class="variablelist"><dl><dt><span class="term">
                        <span><strong class="command">auto.registration</strong></span>
                    </span></dt><dd>
                        <p>
                            If this is true, registration is opened automatically for nodes requesting it.
                            [&nbsp;Default:&nbsp;false&nbsp;]
                        </p>
                    </dd><dt><span class="term">
                        <span><strong class="command">auto.reload</strong></span>
                    </span></dt><dd>
                        <p>
                            If this is true, a reload is automatically sent to nodes when they register.
                            [&nbsp;Default:&nbsp;false&nbsp;]
                        </p>
                    </dd><dt><span class="term">
                        <span><strong class="command">auto.update.node.values.from.properties</strong></span>
                    </span></dt><dd>
                        <p>
                            Update the node row in the database from the local properties during a heartbeat operation.
                            [&nbsp;Default:&nbsp;true&nbsp;]
                        </p>
                    </dd><dt><span class="term">
                        <span><strong class="command">http.concurrent.workers.max</strong></span>
                    </span></dt><dd>
                        <p>
                            This is the number of HTTP concurrent push/pull requests symmetric will accept. This
                            is controlled by the NodeConcurrencyFilter.  The maximum number of database connections 
                            in the database pool should be set to twice this number.[&nbsp;Default:&nbsp;20&nbsp;]
                        </p>
                    </dd><dt><span class="term">
                        <span><strong class="command">offline.node.detection.period.minutes</strong></span>
                    </span></dt><dd>
                        <p>
                            This is the minimum number of minutes that a child node has been offline before taking action.  Refer to 
                            <a href="#extensions-offline-server-listener" title="6.15.&nbsp;IOfflineServerListener">Section&nbsp;6.15, &#8220;IOfflineServerListener&#8221;</a> for
                            more information.  
                            [&nbsp;Default:&nbsp;120&nbsp;]
                        </p>
                    </dd><dt><span class="term">
                        <span><strong class="command">outgoing.batches.peek.ahead.window.after.max.size</strong></span>
                    </span></dt><dd>
                        <p>
                            This is the maximum number of events that will be peeked at to look for additional transaction rows after
                            the max batch size is reached.  The more concurrency in your db and the longer the transaction takes the 
                            bigger this value might have to be. 
                            [&nbsp;Default:&nbsp;100&nbsp;]
                        </p>
                    </dd><dt><span class="term">
                        <span><strong class="command">incoming.batches.skip.duplicates</strong></span>
                    </span></dt><dd>
                        <p>
                            Whether or not to skip duplicate batches that are received. A duplicate batch is
                            identified by the batch ID already existing in the incoming batch table. If this
                            happens, it means an acknowledgement was lost due to failure or there is a bug.
                            Accepting a duplicate batch in this case can mean overwriting data with old data.
                            Another cause of duplicates is when the batch sequence number is reset, which might
                            happen in a lab environement. Skipping a duplicate batch in this case would prevent
                            data changes from loading. Generally, in a production envionment, this setting should
                            be true. [&nbsp;Default:&nbsp;true&nbsp;]
                        </p>
                    </dd><dt><span class="term">
                        <span><strong class="command">num.of.ack.retries</strong></span>
                    </span></dt><dd>
                        <p>
                            This is the number of times we will attempt to send an ACK back to the remote node
                            when pulling and loading data.
                            [&nbsp;Default:&nbsp;5&nbsp;]
                        </p>
                    </dd><dt><span class="term">
                        <span><strong class="command">time.between.ack.retries.ms</strong></span>
                    </span></dt><dd>
                        <p>
                            This is the amount of time to wait between trying to send an ACK back to the remote node
                            when pulling and loading data.
                            [&nbsp;Default:&nbsp;5000&nbsp;]
                        </p>
                    </dd><dt><span class="term">
                        <span><strong class="command">dataextractor.enabled</strong></span>
                    </span></dt><dd>
                        <p>
                            Enable or disable all data extraction at a node for all channels other than the config channel.
                            [&nbsp;Default:&nbsp;true&nbsp;]
                        </p>
                    </dd><dt><span class="term">
                        <span><strong class="command">dataloader.enabled</strong></span>
                    </span></dt><dd>
                        <p>
                            Enable or disable all data loading at a node for all channels other than the config channel.
                            [&nbsp;Default:&nbsp;true&nbsp;]
                        </p>
                    </dd><dt><span class="term">
                        <span><strong class="command">dataloader.enable.fallback.update</strong></span>
                    </span></dt><dd>
                        <p>
                            If an insert is received, but the row already exists, then
                            try an update instead.
                            [&nbsp;Default:&nbsp;true&nbsp;]
                        </p>
                    </dd><dt><span class="term">
                        <span><strong class="command">dataloader.enable.fallback.insert</strong></span>
                    </span></dt><dd>
                        <p>
                            If an update is received, but it affects no rows, then try to insert
                            instead.
                            [&nbsp;Default:&nbsp;true&nbsp;]
                        </p>
                    </dd><dt><span class="term">
                        <span><strong class="command">dataloader.allow.missing.delete</strong></span>
                    </span></dt><dd>
                        <p>
                            If a delete is received, but it affects no rows, then continue.
                            [&nbsp;Default:&nbsp;true&nbsp;]
                        </p>
                    </dd><dt><span class="term">
                        <span><strong class="command">cluster.server.id</strong></span>
                    </span></dt><dd>
                        <p>
                            Set this if you want to give your server a unique name to be used to identify which server did what action.  Typically useful when running in 
                            a clustered environment.  This is currently used by the ClusterService when locking for a node.
                            [&nbsp;Default:&nbsp;&nbsp;]
                        </p>
                    </dd><dt><span class="term">
                        <span><strong class="command">cluster.lock.timeout.ms</strong></span>
                    </span></dt><dd>
                        <p>
                            Time limit of lock before it is considered abandoned and can be broken.
                            [&nbsp;Default:&nbsp;1800000&nbsp;]
                        </p>
                    </dd><dt><span class="term">
                        <span><strong class="command">cluster.lock.enabled</strong></span>
                    </span></dt><dd>
                        <p>
                            [&nbsp;Default:&nbsp;false&nbsp;]
                        </p>
                    </dd><dt><span class="term">
                        <span><strong class="command">initial.load.delete.first</strong></span>
                    </span></dt><dd>
                        <p>
                            Set this if tables should be purged prior to an initial load.
                            [&nbsp;Default:&nbsp;false&nbsp;]
                        </p>
                    </dd><dt><span class="term">
                        <span><strong class="command">initial.load.create.first</strong></span>
                    </span></dt><dd>
                        <p>
                            Set this if tables (and their indexes) should be created prior to an initial load.
                            [&nbsp;Default:&nbsp;false&nbsp;]
                        </p>
                    </dd><dt><span class="term">
                        <span><strong class="command">http.timeout.ms</strong></span>
                    </span></dt><dd>
                        <p>
                            Sets both the connection and read timeout on the internal HttpUrlConnection.
                            [&nbsp;Default:&nbsp;600000s&nbsp;]
                        </p>
                    </dd><dt><span class="term">
                        <span><strong class="command">http.compression</strong></span>
                    </span></dt><dd>
                        <p>
                            Whether or not to use compression over HTTP connections.
                            Currently, this setting only affects the push connection of the source node.
                            Compression on a pull is enabled using a filter in the web.xml for the PullServlet.
                            [&nbsp;Default:&nbsp;true&nbsp;]
                        </p>
                    </dd><dt><span class="term">
                        <span><strong class="command">web.compression.disabled</strong></span>
                    </span></dt><dd>
                        <p>
                            Disable compression from occurring on Servlet communication.  This property only
                            affects the outbound HTTP traffic streamed by the PullServlet and PushServlet.
                            [&nbsp;Default:&nbsp;false&nbsp;]
                        </p>
                    </dd><dt><span class="term">
                        <span><strong class="command">compression.level</strong></span>
                    </span></dt><dd>
                        <p>
                            Set the compression level this node will use when compressing synchronization payloads.
                            Valid values include: NO_COMPRESSION = 0,  BEST_SPEED = 1, BEST_COMPRESSION = 9, DEFAULT_COMPRESSION = -1
                            [&nbsp;Default:&nbsp;-1&nbsp;]
                        </p>
                    </dd><dt><span class="term">
                        <span><strong class="command">compression.strategy</strong></span>
                    </span></dt><dd>
                        <p>
                            Set the compression strategy this node will use when compressing synchronization payloads.
                            Valid values include: FILTERED = 1, HUFFMAN_ONLY = 2, DEFAULT_STRATEGY = 0
                            [&nbsp;Default:&nbsp;0&nbsp;]
                        </p>
                    </dd><dt><span class="term">
                        <span><strong class="command">stream.to.file.enabled</strong></span>
                    </span></dt><dd>
                        <p>
                            Save data to the file system before transporting it to the client or loading
                            it to the database if the number of bytes is past a certain threshold.  This allows
                            for better compression and better use of database and network resources.  Statistics
                            in the batch tables will be more accurate if this is set to true because each timed
                            operation is independent of the others.
                            [&nbsp;Default:&nbsp;true&nbsp;]
                        </p>
                    </dd><dt><span class="term">
                        <span><strong class="command">stream.to.file.threshold.bytes</strong></span>
                    </span></dt><dd>
                        <p>
                            If stream.to.file.enabled is true, then the threshold number of bytes at which a file 
                            will be written is controlled by this property.  Note that for a synchronization the
                            entire payload of the synchronization will be buffered in memory up to this number (at
                            which point it will be written and continue to stream to disk)
                            [&nbsp;Default:&nbsp;32767&nbsp;]
                        </p>
                    </dd><dt><span class="term">
                        <span><strong class="command">job.random.max.start.time.ms</strong></span>
                    </span></dt><dd>
                        <p>
                            When starting jobs, symmetric attempts to randomize the start time to spread out load.
                            This is the maximum wait period before starting a job.
                            [&nbsp;Default:&nbsp;10000&nbsp;]
                        </p>
                    </dd><dt><span class="term">
                        <span><strong class="command">purge.retention.minutes</strong></span>
                    </span></dt><dd>
                        <p>
                            This is the retention for how long synchronization data will be kept in the
                            SymmetricDS synchronization tables. Note that data will be purged only if the purge
                            job is enabled. [&nbsp;Default:&nbsp;7200&nbsp;]
                        </p>
                    </dd><dt><span class="term">
                        <span><strong class="command">statistic.retention.minutes</strong></span>
                    </span></dt><dd>
                        <p>
                            This is the retention for how long statistic data will be kept in the
                            SymmetricDS staistic table. Note that data will be purged only if the purge
                            job is enabled. [&nbsp;Default:&nbsp;7200&nbsp;]
                        </p>
                    </dd><dt><span class="term">
                        <span><strong class="command">job.route.period.time.ms</strong></span>
                    </span></dt><dd>
                        <p>This is how often the route job will be run. [&nbsp;Default:&nbsp;10000&nbsp;]</p>
                    </dd><dt><span class="term">
                        <span><strong class="command">job.push.period.time.ms</strong></span>
                    </span></dt><dd>
                        <p>This is how often the push job will be run. [&nbsp;Default:&nbsp;60000&nbsp;]</p>
                    </dd><dt><span class="term">
                        <span><strong class="command">job.pull.period.time.ms</strong></span>
                    </span></dt><dd>
                        <p>This is how often the pull job will be run. [&nbsp;Default:&nbsp;60000&nbsp;]</p>
                    </dd><dt><span class="term">
                        <span><strong class="command">job.synctriggers.aftermidnight.minutes</strong></span>
                    </span></dt><dd>
                        <p>
                            If scheduled, the sync triggers job will run nightly. This is how long after midnight
                            that job will run. [&nbsp;Default:&nbsp;15&nbsp;]
                        </p>
                    </dd><dt><span class="term">
                        <span><strong class="command">schema.version</strong></span>
                    </span></dt><dd>
                        <p>
                            This is hook to give the user a mechanism to indicate the schema version that is being
                            synchronized. This property is only valid if you use the default IRuntimeConfiguration
                            implementation. [&nbsp;Default:&nbsp;?&nbsp;]
                        </p>
                    </dd><dt><span class="term">
                        <span><strong class="command">registration.url</strong></span>
                    </span></dt><dd>
                        <p>
                            The URL where this node can connect for registration to receive its configuration.
                            This property is only valid if you use the default IRuntimeConfiguration
                            implementation. [&nbsp;Default:&nbsp;]
                        </p>
                    </dd><dt><span class="term">
                        <span><strong class="command">sync.url</strong></span>
                    </span></dt><dd>
                        <p>
                            The URL where this node can be contacting for synchronization. 
                            [&nbsp;Default:&nbsp;http://localhost:8080/sync&nbsp;]
                        </p>
                    </dd><dt><span class="term">
                        <span><strong class="command">group.id</strong></span>
                    </span></dt><dd>
                        <p>
                            The node group id for this node. [&nbsp;Default:&nbsp;default&nbsp;]
                        </p>
                    </dd><dt><span class="term">
                        <span><strong class="command">external.id</strong></span>
                    </span></dt><dd>
                        <p>
                            The secondary identifier for this node that has meaning to the system where it is
                            deployed. While the node id is a generated sequence number, the external ID could have
                            meaning in the user's domain, such as a retail store number. 
                            [&nbsp;Default:&nbsp;]
                        </p>
                    </dd><dt><span class="term">
                        <span><strong class="command">transport.type</strong></span>
                    </span></dt><dd>
                        <p>
                            Specify the transport type. Supported values currently include: http, internal.
                            [&nbsp;Default:&nbsp;http&nbsp;]
                        </p>
                    </dd><dt><span class="term">
                        <span><strong class="command">hsqldb.initialize.db</strong></span>
                    </span></dt><dd>
                        <p>
                            If using the HsqlDbDialect, this property indicates whether Symmetric should setup the embedded database properties or if an
                            external application will be doing so.
                            [&nbsp;Default:&nbsp;true&nbsp;]
                        </p>
                    </dd></dl></div><p>
        </p>
    </div>
</div>
    <div class="appendix" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="databases"></a>Appendix&nbsp;C.&nbsp;Database Notes</h2></div></div></div>
    
    <p>
        Each database management system has its own characteristics that results in
        feature coverage in SymmetricDS.  The following table shows which features are available
        by database.
    </p>
    <p>
        </p><div class="table"><a name="d4e4715"></a><div class="table-contents">
            
            <table summary="Support by Database" border="1"><colgroup><col width="75"><col width="65"><col width="50"><col width="50"><col width="50"><col width="50"><col width="50"></colgroup><thead><tr><th>Database</th><th>Versions supported</th><th>Transaction Identifier</th><th>Fallback Update</th><th>Conditional Sync</th><th>Update Loop Prevention</th><th>BLOB Sync</th><th>CLOB Sync</th></tr></thead><tbody><tr><td>Oracle</td><td>8.1.7 and above</td><td>Y</td><td>Y</td><td>Y</td><td>Y</td><td>Y</td><td>Y</td></tr><tr><td>MySQL</td><td>5.0.2 and above</td><td>Y</td><td>Y</td><td>Y</td><td>Y</td><td>Y</td><td>Y</td></tr><tr><td>PostgreSQL</td><td>8.2.5 and above</td><td>Y (8.3 and above only)</td><td>Y</td><td>Y</td><td>Y</td><td>Y</td><td>Y</td></tr><tr><td>SQL Server</td><td>2005</td><td>Y</td><td>Y</td><td>Y</td><td>Y</td><td>Y</td><td>Y</td></tr><tr><td>HSQLDB</td><td>1.8</td><td>Y</td><td>Y</td><td>Y</td><td>Y</td><td>Y</td><td>Y</td></tr><tr><td>HSQLDB</td><td>2.0</td><td>N</td><td>Y</td><td>Y</td><td>Y</td><td>Y</td><td>Y</td></tr><tr><td>H2</td><td>1.x</td><td>Y</td><td>Y</td><td>Y</td><td>Y</td><td>Y</td><td>Y</td></tr><tr><td>Apache Derby</td><td>10.3.2.1</td><td>Y</td><td>Y</td><td>Y</td><td>Y</td><td>Y</td><td>Y</td></tr><tr><td>IBM DB2</td><td>9.5</td><td>N</td><td>Y</td><td>Y</td><td>Y</td><td>Y</td><td>Y</td></tr><tr><td>Firebird</td><td>2.0</td><td>Y</td><td>Y</td><td>Y</td><td>Y</td><td>Y</td><td>Y</td></tr><tr><td>Informix</td><td>11</td><td>N</td><td>Y</td><td>Y</td><td>Y</td><td>N</td><td>N</td></tr><tr><td>Interbase</td><td>9.0</td><td>N</td><td>Y</td><td>Y</td><td>Y</td><td>Y</td><td>Y</td></tr></tbody></table>
        </div><p class="title"><b>Table&nbsp;C.1.&nbsp;Support by Database</b></p></div><p><br class="table-break">
    </p>
    <div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="ap02-oracle"></a>C.1.&nbsp;Oracle</h2></div></div></div>
        
        <p>
            On Oracle Real Application Clusters (RAC), sequences should be ordered so data is processed 
            in the correct order.
            To offset the performance cost of ordering, the sequences should also be cached.
            </p><pre class="programlisting">
alter sequence SEQ_SYM_DATA_DATA_ID cache 1000 order;
alter sequence SEQ_SYM_OUTGOIN_BATCH_BATCH_ID cache 1000 order;
alter sequence SEQ_SYM_TRIGGER_RIGGER_HIST_ID cache 1000 order;
alter sequence SEQ_SYM_TRIGGER_TRIGGER_ID cache 1000 order;</pre><p>
        </p>
        <p>
            While BLOBs are supported on Oracle, the LONG data type is not.  LONG columns cannot be accessed from triggers.
        </p>
        <p>
            Note that while Oracle supports multiple triggers of the same type to be defined, the order
            in which the triggers occur appears to be arbitrary.
        </p>
        <p>
            The SymmetricDS user generally needs privileges for connecting and creating 
            tables (including indexes), triggers, sequences, and procedures (including packages and functions).
            The following is an example of the needed grant statements:
            </p><pre class="programlisting">
GRANT CONNECT TO SYMMETRIC;
GRANT RESOURCE TO SYMMETRIC;
GRANT CREATE ANY TRIGGER TO SYMMETRIC;
GRANT EXECUTE ON UTL_RAW TO SYMMETRIC;</pre><p>
        </p>
        <p>
            Partitioning the <a href="#table_data" title="A.20.&nbsp;DATA">DATA</a> table by channel can help
            insert, routing and extraction performance on concurrent, high throughput systems.  
            <a href="#table_trigger" title="A.13.&nbsp;TRIGGER">TRIGGER</a>s should be organized to put data that is 
            expected to be inserted concurrently on separate <a href="#table_channel" title="A.10.&nbsp;CHANNEL">CHANNEL</a>s.  The following is an example of
            partitioning.  Note that both the table and the index should be partitioned.  The default
            value allows for more channels to be added without having to modify the partitions. 
            </p><pre class="programlisting">
CREATE TABLE SYM_DATA
(
    data_id INTEGER NOT NULL ,
    table_name VARCHAR2(50) NOT NULL,
    event_type CHAR(1) NOT NULL,
    row_data CLOB,
    pk_data CLOB,
    old_data CLOB,
    trigger_hist_id INTEGER NOT NULL,
    channel_id VARCHAR2(20),
    transaction_id VARCHAR2(1000),
    source_node_id VARCHAR2(50),
    external_data VARCHAR2(50),
    create_time TIMESTAMP
) PARTITION BY LIST (channel_id) (  	
PARTITION P_CONFIG VALUES ('config'),
PARTITION P_CHANNEL_ONE VALUES ('channel_one'),
PARTITION P_CHANNEL_TWO VALUES ('channel_two'),
...
PARTITION P_CHANNEL_N VALUES ('channel_n'),
PARTITION P_DEFAULT VALUES (DEFAULT));            
            </pre><p>
            </p><pre class="programlisting">
CREATE UNIQUE INDEX IDX_D_CHANNEL_ID ON SYM_DATA (DATA_ID, CHANNEL_ID)  LOCAL
( 
 PARTITION I_CONFIG, 
 PARTITION I_CHANNEL_ONE, 
 PARTITION I_CHANNEL_TWO,
 ... 
 PARTITION I_CHANNEL_N, 
 PARTITION I_DEFAULT
);              
            </pre><p>            
        </p>        
    </div>
    <div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="ap02-mysql"></a>C.2.&nbsp;MySQL</h2></div></div></div>
        
        <p>
            MySQL supports several storage engines for different table types.  SymmetricDS requires
            a storage engine that handles transaction-safe tables.  The recommended storage engine
            is InnoDB, which is included by default in MySQL 5.0 distributions.
            Either select the InnoDB engine during installation or modify your server configuration.
            To make InnoDB the default storage engine, modify your MySQL server configuration file 
            (<code class="filename">my.ini</code> on Windows, <code class="filename">my.cnf</code> on Unix):
            </p><pre class="programlisting">default-storage_engine = innodb</pre><p>
            Alternatively, you can convert tables to the InnoDB storage engine with the following
            command:
            </p><pre class="programlisting">alter table t engine = innodb;</pre><p>            
        </p>
        <p>
            On MySQL 5.0, the SymmetricDS user needs the SUPER privilege in order to create triggers.

            </p><pre class="programlisting">grant super on *.* to symmetric;</pre><p>
            
            On MySQL 5.1, the SymmetricDS user needs the TRIGGER and CREATE ROUTINE privileges
            in order to create triggers and functions.

            </p><pre class="programlisting">grant trigger on *.* to symmetric;</pre><p>
            </p><pre class="programlisting">grant create routine on *.* to symmetric;</pre><p>

        </p>
        <p>
            MySQL allows '0000-00-00 00:00:00' to be entered as a value for datetime and timestamp columns.  
            JDBC can not deal with a date value with a year of 0.  In order to work around this SymmetricDS
            can be configured to treat date and time columns as varchar columns for data capture and data
            load.  To enable this feature set the <code class="code">db.treat.date.time.as.varchar.enabled</code> property 
            to <code class="code">true</code>.
        </p>
    </div>
    <div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="ap02-postgresql"></a>C.3.&nbsp;PostgreSQL</h2></div></div></div>
        
        <p>
            Starting with PostgreSQL 8.3, SymmetricDS supports the transaction identifier.
            Binary Large Object (BLOB) replication is supported for both byte array (BYTEA)
            and object ID (OID) data types.
        </p>
        <p>
            In order to function properly, SymmetricDS needs to use session variables.
            On PostgreSQL, session variables are enabled using a custom variable class.
            Add the following line to the <code class="filename">postgresql.conf</code> file
            of PostgreSQL server:
            
            </p><pre class="programlisting">
custom_variable_classes = 'symmetric'
</pre><p>

            This setting is required, and SymmetricDS will log an error and exit if it is not present.
        </p>
        <p>
            Before database triggers can be created by in PostgreSQL,
            the plpgsql language handler must be installed on the database.
            The following statements should be run by the administrator on the database:
            
            </p><pre class="programlisting">
CREATE FUNCTION plpgsql_call_handler() RETURNS language_handler AS
    '$libdir/plpgsql' LANGUAGE C;

CREATE FUNCTION plpgsql_validator(oid) RETURNS void AS
    '$libdir/plpgsql' LANGUAGE C;

CREATE TRUSTED PROCEDURAL LANGUAGE plpgsql
    HANDLER plpgsql_call_handler
    VALIDATOR plpgsql_validator;</pre><p>
        </p>
    </div>
    <div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="ap02-sql-server"></a>C.4.&nbsp;MS SQL Server</h2></div></div></div>
        
        <p>
            SQL Server was tested using the
            <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://jtds.sourceforge.net/" target="_top">
                jTDS
            </a>
            JDBC driver.
        </p>
    </div>
    <div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="ap02-hsqldb"></a>C.5.&nbsp;HSQLDB</h2></div></div></div>
        
        <p>
            HSQLDB was implemented with the intention that the database be run embedded in the same JVM process 
            as SymmetricDS.  Instead of dynamically generating static SQL-based triggers like the other databases, HSQLDB
            triggers are Java classes that re-use existing SymmetricDS services to read the configuration and insert data events
            accordingly.
        </p>
        <p>
            The transaction identifier support is based on SQL events that happen in a 'window' of time.  The trigger(s) track when the 
            last trigger fired.  If a trigger fired within X milliseconds of the previous firing, then the current event gets the same 
            transaction identifier as the last.  If the time window has passed, then a new transaction identifier is generated.
        </p>        
    </div>
    <div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="ap02-h2"></a>C.6.&nbsp;H2</h2></div></div></div>
        
        <p>
            The H2 database allows only Java-based triggers.  Therefore the H2 dialect requires that the SymmetricDS jar file be in the database's classpath.  
        </p>
    </div>
    <div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="ap02-derby"></a>C.7.&nbsp;Apache Derby</h2></div></div></div>
        
        <p>
            The Derby database can be run as an embedded database that is accessed by an application
            or a standalone server that can be accessed from the network.
            This dialect implementation creates database triggers that make method calls into
            Java classes.  This means that the supporting JAR files need to be in the classpath when
            running Derby as a standalone database, which includes symmetric-ds.jar and
            commons-lang.jar.
        </p>
    </div>    
    <div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="ap02-db2"></a>C.8.&nbsp;IBM DB2</h2></div></div></div>
        
        <p>
            The DB2 Dialect uses global variables to enable and disable node and trigger synchronization.
            These variables are created automatically during the first startup.  
            The DB2 JDBC driver should be placed in the "lib" folder.
        </p>
        <p>
            Currently, the DB2 Dialect for SymmetricDS does not provide support for transactional synchronization.
            Large objects (LOB) are supported, but are limited to 16,336 bytes in size.
            The current features in the DB2 Dialect have been tested using DB2 9.5 on Linux and Windows operating systems.  
        </p> 
        <p>
            There is currently a bug with the retrieval of auto increment columns with the DB2 9.5 JDBC drivers that causes
            some of the SymmetricDS configuration tables to be rebuilt when auto.config.database=true.  The DB2 9.7 JDBC drivers
            seem to have fixed the issue.  They may be used with the 9.5 database.
        </p>       
        <p>
            A system temporary tablespace with too small of a page size may cause the following trigger build errors:
            </p><pre class="programlisting">
SQL1424N Too many references to transition variables and transition table
columns or the row length for these references is too long. Reason
code="2". LINE NUMBER=1. SQLSTATE=54040            
            </pre><p>
            Simply create a system temporary tablespace that has a bigger page size.  A page size of 8k will probably suffice.
        </p>
    </div>      
    <div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="ap02-firebird"></a>C.9.&nbsp;Firebird</h2></div></div></div>
        
        <p>
            The Firebird Dialect requires the installation of a User Defined Function (UDF) library
            in order to provide functionality needed by the database triggers.
            SymmetricDS includes the required UDF library, called SYM_UDF, in both source form 
            (as a C program) and as pre-compiled libraries for both Windows and Linux.  
            The SYM_UDF library is copied into the UDF folder within the Firebird installation directory.
        </p>
        <p>
            For Linux users: 
        </p>
        <p>
            <span><strong class="command">cp databases/firebird/sym_udf.so /opt/firebird/UDF</strong></span>
        </p>
        <p>
            For Windows users: 
        </p>
        <p>
            <span><strong class="command">copy databases\firebird\sym_udf.dll C:\Program Files\Firebird\Firebird_2_0\UDF</strong></span>        
        </p>
        <p>
            The following limitations currently exist for this dialect:
        </p>
        <p>
          </p><div class="itemizedlist"><ul type="disc" compact><li>
                  <p>
                      The outgoing batch does not honor the channel size, and all 
                      outstanding data events are included in a batch.
                  </p>
              </li><li>
                  <p>
                      Syncing of Binary Large Object (BLOB) is limited to 16K bytes per column.
                  </p>
              </li><li>
                  <p>
                      Syncing of character data is limited to 32K bytes per column.
                  </p>
              </li></ul></div><p>
        </p>
    </div>      
    <div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="ap02-informix"></a>C.10.&nbsp;Informix</h2></div></div></div>
        
        <p>
            The Informix Dialect was tested against Informix Dynamic Server 11.50, but older versions
            may also work.  You need to download the Informix JDBC Driver (from the 
            <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www-01.ibm.com/software/data/informix/downloads.html" target="_top">IBM Download Site</a>)
            and put the <code class="filename">ifxjdbc.jar</code> and <code class="filename">ifxlang.jar</code> files
            in the SymmetricDS <code class="filename">lib</code> folder.
        </p>
        <p>    
            Make sure your database has logging enabled, which enables transaction
            support.  Enable logging when creating the database, like this:
            </p><pre class="programlisting">
CREATE DATABASE MYDB WITH LOG;
            </pre><p>
            
            Or enable logging on an existing database, like this:
            </p><pre class="programlisting">
ondblog mydb unbuf log
ontape -s -L 0
            </pre><p>
        </p>
        <p>
            The following features are not yet implemented:
        </p>
        <p>
          </p><div class="itemizedlist"><ul type="disc" compact><li>
                  <p>
                      Syncing of Binary and Character Large Objects (LOB) is disabled.
                  </p>
              </li><li>
                  <p>
                      There is no transaction ID recorded on data captured, so it is possible for data
                      to be committed within different transactions on the target database.
                      If transaction synchronization is required, either specify a custom transaction ID 
                      or configure the synchronization so data is always sent in a single batch.
                      A custom transaction ID can be specified with the tx_id_expression on  
                      <a href="#table_trigger" title="A.13.&nbsp;TRIGGER">TRIGGER</a>.
                      The batch size is controlled with the max_batch_size on                        
                      <a href="#table_channel" title="A.10.&nbsp;CHANNEL">CHANNEL</a>.
                      The pull and push jobs have runtime properties to control their interval.
                  </p>
              </li></ul></div><p>
        </p>
    </div>
    <div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="ap02-interbase"></a>C.11.&nbsp;Interbase</h2></div></div></div>
        
        <p>
            The Interbase Dialect requires the installation of a User Defined Function (UDF) library
            in order to provide functionality needed by the database triggers.
            SymmetricDS includes the required UDF library, called SYM_UDF, in both source form 
            (as a C program) and as pre-compiled libraries for both Windows and Linux.  
            The SYM_UDF library is copied into the UDF folder within the Interbase installation directory.
        </p>
        <p>
            For Linux users: 
        </p>
        <p>
            <span><strong class="command">cp databases/interbase/sym_udf.so /opt/interbase/UDF</strong></span>
        </p>
        <p>
            For Windows users: 
        </p>
        <p>
            <span><strong class="command">copy databases\interbase\sym_udf.dll C:\CodeGear\InterBase\UDF</strong></span>        
        </p>
        <p>
            The Interbase dialect currently has the following limitations:  
        </p>
        <div class="itemizedlist"><ul type="disc" compact><li>
                <p>
                    Data capture is limited to 4 KB per row, including large objects (LOB).
                </p>
            </li><li>
                <p>
                    There is no transaction ID recorded on data captured.
                    Either specify a tx_id_expression on the
                    <a href="#table_trigger" title="A.13.&nbsp;TRIGGER">TRIGGER</a> table,
                    or set a max_batch_size on the                        
                    <a href="#table_channel" title="A.10.&nbsp;CHANNEL">CHANNEL</a> table that
                    will accommodate your transactional data.
                </p>
            </li></ul></div>
    </div>
</div>
    <div class="appendix" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="data-format"></a>Appendix&nbsp;D.&nbsp;Data Format</h2></div></div></div>
    
    <p>
        The SymmetricDS Data Format is used to stream data from one node to another. The data format
        reader and writer are pluggable with an initial implementation using a format based on
        Comma Separated Values (CSV). Each line in the stream is a record with fields separated
        by commas. String fields are surrounded with double quotes. Double quotes and
        backslashes used in a string field are escaped with a backslash. Binary values are
        represented as a string with hex values in "\0xab" format. The absence of any value in
        the field indicates a null value. Extra spacing is ignored and lines starting with a
        hash are ignored.
    </p>
    <p>
        The first field of each line gives the directive for the line. The following directives
        are used:

        </p><div class="variablelist"><dl><dt><span class="term">
                    <span><strong class="command">nodeid, {node_id}</strong></span>
                </span></dt><dd>
                    <p>Identifies which node the data is coming from.  Occurs once in CSV file.</p>
                </dd><dt><span class="term">
                    <span><strong class="command">binary, {BASE64|NONE|HEX}</strong></span>
                </span></dt><dd>
                    <p>Identifies the type of decoding the loader needs to use to decode binary data in the pay load.  This varies depending on what database is the source of the data.</p>
                </dd><dt><span class="term">
                    <span><strong class="command">channel, {channel_id}</strong></span>
                </span></dt><dd>
                    <p>Identifies which channel a batch belongs to.  The SymmetricDS data loader expects the channel to be specified before the batch.</p>
                </dd><dt><span class="term">
                    <span><strong class="command">batch, {batch_id}</strong></span>
                </span></dt><dd>
                    <p>Uniquely identifies a batch.  Used to track whether a batch has been loaded before. A batch of -9999 is considered a virtual batch and will be loaded, but will not be recorded in incoming_batch.</p>
                </dd><dt><span class="term">
                    <span><strong class="command">schema, {schema name}</strong></span>
                </span></dt><dd>
                    <p>The name of the schema that is being targeted.</p>
                </dd><dt><span class="term">
                    <span><strong class="command">catalog, {catalog name}</strong></span>
                </span></dt><dd>
                    <p>The name of the catalog that is being targeted.</p>
                </dd><dt><span class="term">
                    <span><strong class="command">table, {table name}</strong></span>
                </span></dt><dd>
                    <p>The name of the table that is being targeted.</p>
                </dd><dt><span class="term">
                    <span><strong class="command">keys, {column name...}</strong></span>
                </span></dt><dd>
                    <p>
                        Lists the column names that are used as the primary key for the table.
                        Only needs to occur after the first occurrence of the table.
                    </p>
                </dd><dt><span class="term">
                    <span><strong class="command">columns, {column name...}</strong></span>
                </span></dt><dd>
                    <p>
                        Lists all the column names (including key columns) of the table. Only needs to occur after the
                        first occurrence of the table.
                    </p>
                </dd><dt><span class="term">
                    <span><strong class="command">insert, {column value...}</strong></span>
                </span></dt><dd>
                    <p>
                        Insert into the table with the values that correspond with the columns.
                    </p>
                </dd><dt><span class="term">
                    <span><strong class="command">update, {new column value...},{old key value...}</strong></span>
                </span></dt><dd>
                    <p>
                        Update the table using the old key values to set the new column values.
                    </p>
                </dd><dt><span class="term">
                    <span><strong class="command">old, {old column value...}</strong></span>
                </span></dt><dd>
                    <p>
                        Represent all the old values of the data.  This data can be used for conflict 
                        resolution.
                    </p>
                </dd><dt><span class="term">
                    <span><strong class="command">delete, {old key value...}</strong></span>
                </span></dt><dd>
                    <p>Delete from the table using the old key values.</p>
                </dd><dt><span class="term">
                    <span><strong class="command">sql, {sql statement}</strong></span>
                </span></dt><dd>
                    <p>Optional notation that instructs the data loader to run the accompanying SQL statement.</p>
                </dd><dt><span class="term">
                    <span><strong class="command">bsh, {bsh script}</strong></span>
                </span></dt><dd>
                    <p>Optional notation that instructs the data loader to run the accompanying  <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.beanshell.org/" target="_top">BeanShell</a> snippet.</p>
                </dd><dt><span class="term">
                    <span><strong class="command">create, {xml}</strong></span>
                </span></dt><dd>
                    <p>Optional notation that instructs the data loader to run the accompanying <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://db.apache.org/ddlutils/" target="_top">DdlUtils</a> XML table definition in order to create a database table.</p>
                </dd><dt><span class="term">
                    <span><strong class="command">commit, {batch_id}</strong></span>
                </span></dt><dd>
                    <p>An indicator that the batch has been transmitted and the data can be committed to the database.</p>
                </dd></dl></div><p>
    </p>
    <div class="example"><a name="d4e5047"></a><div class="example-contents">
        
        <pre class="programlisting">
nodeid, 1001
channel, pricing
binary, BASE64
batch, 100
schema,
catalog,
table, item_selling_price
keys, price_id
columns, price_id, price, cost
insert, 55, 0.65, 0.55
schema,
catalog,
table, item
keys, item_id 
columns, item_id, price_id, name
insert, 110000055, 55, "Soft Drink"
delete, 110000001
schema,
catalog,
table, item_selling_price
update, 55, 0.75, 0.65, 55
commit, 100
        </pre>
    </div><p class="title"><b>Example&nbsp;D.1.&nbsp;Data Format Stream</b></p></div><br class="example-break">
</div>
    <div class="appendix" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="version-numbering"></a>Appendix&nbsp;E.&nbsp;Version Numbering</h2></div></div></div>
    
    <p>
        The software is released with a version number based on the
        <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://apr.apache.org/versioning.html" target="_top">
            Apache Portable Runtime Project
        </a>
        version guidelines. In summary, the version is denoted as three integers in the
        format of MAJOR.MINOR.PATCH. Major versions are incompatible at the API level, and
        they can include any kind of change. Minor versions are compatible with older
        versions at the API and binary level, and they can introduce new functions or remove
        old ones. Patch versions are perfectly compatible, and they are released to fix
        defects.
    </p>
</div>

</div><p xmlns:fo="http://www.w3.org/1999/XSL/Format" class="copyright">&copy; 2007, 2008 Eric Long and Chris Henson</p></body></html>